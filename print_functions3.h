#include <iostream>
#include "rvcudefs.h" 
#include "xbudefs.h" 
#include "xbgdefs.h" 
#include "xbwincb.h" 
#include "pgnudefs.h" 
 #include <unordered_map>
 #include <tuple>
 #include <utility>
 #include <map> 
 #include <memory> 
 #include <functional>
 #include <cstring>
 #include <vector>
 #include <cmath>
 using namespace std;
std::unordered_map<std::string, std::pair<int, int>> PGNREVERSE = {
{ "AGSCritCmdAmbTemp" , {131007, -1} },
{ "AGSCritCmdDcI" , {131007, -1} },
{ "AGSCritCmdDcSoc" , {131007, -1} },
{ "AGSCritCmdDcV" , {131007, -1} },
{ "AGSCritStsAmbTemp" , {131008, -1} },
{ "AGSCritStsDcI" , {131008, -1} },
{ "AGSCritStsDcSoc" , {131008, -1} },
{ "AGSCritStsDcV" , {131008, -1} },
{ "AGSCritStsXferAcV" , {131008, -1} },
{ "AcFltCtrlCfgCmd1" , {130997, -1} },
{ "AcFltCtrlCfgCmd2" , {130996, -1} },
{ "AcFltCtrlCfgSts1" , {130999, -1} },
{ "AcFltCtrlCfgSts2" , {130998, -1} },
{ "AlarmCmd" , {130718, -1} },
{ "AlarmSts" , {130719, -1} },
{ "BattCmd" , {130698, -1} },
{ "BattSts1" , {130709, -1} },
{ "BattSts11" , {130699, -1} },
{ "BattSts2" , {130708, -1} },
{ "BattSts3" , {130707, -1} },
{ "BattSts4" , {130706, -1} },
{ "BattSts6" , {130704, -1} },
{ "BattSumm" , {130545, -1} },
{ "ChgAcFltCfgCmd1" , {130951, -1} },
{ "ChgAcFltCfgCmd2" , {130950, -1} },
{ "ChgAcFltCfgSts1" , {130953, -1} },
{ "ChgAcFltCfgSts2" , {130952, -1} },
{ "ChgAcSts1" , {131018, -1} },
{ "ChgAcSts2" , {131017, -1} },
{ "ChgAcSts3" , {131016, -1} },
{ "ChgAcSts4" , {130954, -1} },
{ "ChgCfgCmd1" , {131012, -1} },
{ "ChgCfgCmd2" , {130965, -1} },
{ "ChgCfgCmd3" , {130763, -1} },
{ "ChgCfgCmd4" , {130750, -1} },
{ "ChgCfgSts1" , {131014, -1} },
{ "ChgCfgSts2" , {130966, -1} },
{ "ChgCfgSts3" , {130764, -1} },
{ "ChgCfgSts4" , {130751, -1} },
{ "ChgCmd" , {131013, -1} },
{ "ChgEqlzCfgCmd" , {130967, -1} },
{ "ChgEqlzCfgSts" , {130968, -1} },
{ "ChgEqlzSts" , {130969, -1} },
{ "ChgStatsSts" , {131011, -1} },
{ "ChgSts" , {131015, -1} },
{ "ChgSts2" , {130723, -1} },
{ "ChgSts3" , {130506, -1} },
{ "CommSts1" , {131066, -1} },
{ "CommSts2" , {131065, -1} },
{ "CommSts3" , {131064, -1} },
{ "DCSrcSts1" , {131069, -1} },
{ "DCSrcSts2" , {131068, -1} },
{ "DCSrcSts3" , {131067, -1} },
{ "DCSrcSts4" , {130761, -1} },
{ "DcSrcCfgCmd3" , {130526, -1} },
{ "DcSrcCmd" , {130724, -1} },
{ "DcSrcConnSts" , {130512, -1} },
{ "DcSrcSts11" , {130725, -1} },
{ "DcSrcSts6" , {130759, -1} },
{ "DeviceStateSync" , {130513, -1} },
{ "DiagMsg1" , {130762, -1} },
{ "FileDnldBlk" , {78080, -1} },
{ "FileDnldInf" , {78336, -1} },
{ "FileDnldSts" , {80640, -1} },
{ "GenCmd" , {131034, -1} },
{ "GenDemandCmd" , {131009, -1} },
{ "GenDemandSts" , {131010, -1} },
{ "GenRst" , {98048, -1} },
{ "GenStartCfgCmd" , {131032, -1} },
{ "GenStartCfgSts" , {131033, -1} },
{ "GenSts1" , {131036, -1} },
{ "GenSts2" , {131035, -1} },
{ "InstAssign" , {97280, -1} },
{ "InstSts" , {97024, -1} },
{ "InvAcFltCfgCmd1" , {130956, -1} },
{ "InvAcFltCfgSts1" , {130958, -1} },
{ "InvAcSts1" , {131031, -1} },
{ "InvAcSts2" , {131030, -1} },
{ "InvAcSts3" , {131029, -1} },
{ "InvAcSts4" , {130959, -1} },
{ "InvApsSts" , {131021, -1} },
{ "InvCfgCmd1" , {131024, -1} },
{ "InvCfgCmd2" , {131023, -1} },
{ "InvCfgCmd3" , {130765, -1} },
{ "InvCfgCmd4" , {130714, -1} },
{ "InvCfgSts1" , {131026, -1} },
{ "InvCfgSts2" , {131025, -1} },
{ "InvCfgSts3" , {130766, -1} },
{ "InvCfgSts4" , {130715, -1} },
{ "InvCmd" , {131027, -1} },
{ "InvDcSts" , {130792, -1} },
{ "InvHvDcBusSts" , {131020, -1} },
{ "InvOpsSts" , {131019, -1} },
{ "InvStatsSts" , {131022, -1} },
{ "InvSts" , {131028, -1} },
{ "InvTempSts" , {130749, -1} },
{ "InvTempSts2" , {130507, -1} },
{ "IsoAck" , {59392, -1} },
{ "IsoAddrClaim" , {60928, -1} },
{ "IsoCmdAddr" , {65240, -1} },
{ "IsoReq" , {59904, -1} },
{ "IsoTpConnManAbort" , {60416, 255} },
{ "IsoTpConnManBam" , {60416, 32} },
{ "IsoTpConnManCts" , {60416, 17} },
{ "IsoTpConnManEom" , {60416, 19} },
{ "IsoTpConnManRts" , {60416, 16} },
{ "IsoTpXfer" , {60160, -1} },
{ "PmAcStsRms" , {61184, 15} },
{ "PmAcXferSwSts" , {61184, 16} },
{ "PmAssocCfg" , {61184, 1} },
{ "PmAssocSts" , {61184, 3} },
{ "PmChgSts" , {61184, 12} },
{ "PmDevMdCfg" , {61184, 4} },
{ "PmDevMdSts" , {61184, 6} },
{ "PmFXCCCfgCmd" , {61184, 5} },
{ "PmFXCCCfgSts" , {61184, 7} },
{ "PmGetConfigParam" , {61184, 17} },
{ "PmGetStatusParam" , {61184, 19} },
{ "PmInvCtrlCmd" , {61184, 14} },
{ "PmInvLdShSts" , {61184, 10} },
{ "PmInvSts" , {61184, 11} },
{ "PmLithionicsCmd" , {61184, 170} },
{ "PmLithionicsSts" , {61184, 171} },
{ "PmParamAssocCfg" , {59648, 2} },
{ "PmParamAuxCfg" , {59648, 3} },
{ "PmParamAuxCfgTrigDly" , {59648, 5} },
{ "PmParamAuxCfgTrigLvl" , {59648, 4} },
{ "PmParamAuxSts" , {59648, 7} },
{ "PmParamDevMdCfg" , {59648, 1} },
{ "PmPpnNakRsp" , {61184, 127} },
{ "PmPpnReadCmd" , {61184, 98} },
{ "PmPpnReadRsp" , {61184, 99} },
{ "PmPpnSessionCmd" , {61184, 96} },
{ "PmPpnSessionRsp" , {61184, 97} },
{ "PmPpnWriteCmd" , {61184, 100} },
{ "PmPpnWriteRsp" , {61184, 101} },
{ "PmReq" , {61184, 2} },
{ "PmRpcCmd" , {61184, 9} },
{ "PmSetConfigParam" , {61184, 18} },
{ "PmSwVerSts" , {61184, 8} },
{ "ProdIdent" , {65259, -1} },
{ "ProdInfoSts" , {126996, -1} },
{ "SccArraySts" , {130559, -1} },
{ "SccBattSts" , {130688, -1} },
{ "SccCfgCmd" , {130736, -1} },
{ "SccCfgCmd2" , {130557, -1} },
{ "SccCfgCmd3" , {130555, -1} },
{ "SccCfgCmd4" , {130553, -1} },
{ "SccCfgCmd5" , {130510, -1} },
{ "SccCfgSts" , {130738, -1} },
{ "SccCfgSts2" , {130558, -1} },
{ "SccCfgSts3" , {130556, -1} },
{ "SccCfgSts4" , {130554, -1} },
{ "SccCfgSts5" , {130511, -1} },
{ "SccCmd" , {130737, -1} },
{ "SccEqlzCfgCmd" , {130733, -1} },
{ "SccEqlzCfgSts" , {130734, -1} },
{ "SccEqlzSts" , {130735, -1} },
{ "SccSts" , {130739, -1} },
{ "SccSts2" , {130693, -1} },
{ "SccSts3" , {130692, -1} },
{ "SccSts4" , {130691, -1} },
{ "SccSts5" , {130690, -1} },
{ "SccSts6" , {130689, -1} },
{ "SetSysDateTime" , {131070, -1} },
{ "SimpleCalibCfg" , {79872, -1} },
{ "SwVerSts" , {129038, -1} },
{ "SysDateTimeSts" , {131071, -1} },
{ "VirtualTerminal" , {97792, -1} },
{ "XbResetCmd" , {74752, -1} },
};

std::unordered_map<int, std::unordered_map<int, std::string>> ENUMLOOKUP = {
{-2087867454, {{0, "CanAddr"}, {1, "BattInst"}, {2, "NumPacks"}, {3, "BankInst"}, {4, "ReserveLimit"}, {5, "MakeId"}, {6, "ModelNum1"}, {7, "ModelNum2"}, {8, "SerialNum"}, {9, "SwVer"}, {10, "ProdId"}, {11, "RatedCapacity"}, {12, "CellsInSeries"}, {13, "CellsInParallel"}, {14, "BmsSerialNum"}, {15, "BpcSerialNum1"}, {16, "BpcSerialNum2"}, {17, "BpcHwVer"}, {18, "BlueToothCfg"}, {19, "WiFiCfg"}, }},
{-1920850496, {{0, "Manual Off"}, {1, "Manual On"}, {2, "Automatic"}, }},
{-1891506457, {{0, "Normal"}, {1, "Extreme Under Voltage"}, {2, "Under Voltage"}, {3, "Over Voltage"}, {4, "Extreme Over Voltage"}, }},
{-1372759813, {{0, "App"}, {1, "XB Lib"}, {2, "RVC"}, {3, "Loader"}, }},
{-1191777267, {{0, "Standalone"}, {1, "Master"}, {2, "Slave"}, {3, "Series Line 2 Master"}, {4, "Series Line 1 Master"}, {5, "Series Line 2 Slave"}, {6, "Series Line 1 Slave"}, {7, "Phase 1 Master"}, {8, "Phase 2 Master"}, {9, "Phase 3 Master"}, {10, "Phase 1 Slave"}, {11, "Phase 2 Slave"}, {12, "Phase 3 Slave"}, {255, "No Data"}, }},
{-961307955, {{0, "Not On"}, {1, "Manual On"}, {2, "Not Off"}, {3, "Manual Off"}, {4, "No Active Trigger"}, {5, "Trigger Override"}, {6, "Battery Voltage Low"}, {7, "Battery Voltage High"}, {8, "Battery Temp Low"}, {9, "Battery Temp High"}, {10, "Fault"}, {11, "AC Good"}, {12, "Bulk Exit"}, {13, "Absorption Exit"}, {14, "Internal Temp High"}, {15, "State Of Charge"}, {16, "Time Of Day"}, }},
{-725723354, {{0, "Hibernate"}, {1, "Power Save"}, {2, "Safe"}, {3, "Operating"}, {4, "Diagnostic"}, {5, "Remote Power Off"}, {10, "Cbg Backup"}, {11, "Cbg Self Consump"}, {12, "Cbg Self Consump Time"}, {13, "Cbg Send Cfg"}, {14, "Cbg Push Cfg"}, {252, "Last Mode"}, {253, "Reserved"}, {254, "Out Of Range"}, {255, "Data Not Available Do Not Change"}, }},
{-710120228, {{0, "Invalid"}, {1, "3Stage"}, {2, "2StageNoFloat"}, {3, "CVCC"}, {4, "Trickle"}, {5, "4Stage"}, {253, "Reserved"}, {254, "Out of Range"}, {255, "Data Not Available Do Not Change"}, }},
{-624353124, {{0, "Normal"}, {1, "Extreme Under Temperature"}, {2, "Under Temperature"}, {3, "Over Temperature"}, {4, "Extreme Over Temperature"}, }},
{-595124272, {{0, "Unknown"}, {1, "Grid Priority"}, {2, "Generator Priority"}, {253, "Reserved"}, {254, "Out Of Range"}, {255, "Data Not Available Do Not Change"}, }},
{-100316561, {{0, "Inactive"}, {1, "Input1Active"}, {2, "Input2Active"}, {3, "Input1Delay"}, {4, "Input2Delay"}, }},
{8982, {{64, "Generator"}, {65, "Genstart Controller"}, {66, "Inverter"}, {67, "Inverter 2"}, {68, "Control Panel"}, {69, "Battery Monitor"}, {70, "Battery Monitor 2"}, {71, "Chassis Battery Monitor"}, {74, "Converter"}, {75, "Converter 2"}, {76, "Charge Controller"}, {77, "AC Load Monitor"}, {78, "AC Fault Protection"}, {79, "Transfer Switch"}, {131, "DC Load"}, {132, "DC_Input_Keypad"}, {137, "AC Load"}, {138, "DC Motor Controller"}, {140, "Generic AC Source"}, {141, "Solar Charge Controller"}, {249, "Service Tool"}, {250, "System Clock"}, {251, "Data Logger"}, {252, "Chassis Bridge"}, {253, "Network Bridge"}, {255, "Global"}, }},
{8986, {{0, "Gps"}, {1, "Glonass"}, {2, "Wwv"}, {3, "Local Cesium"}, {4, "Local Rubidium"}, {5, "Local Crystal"}, {6, "Reserved"}, {15, "Null"}, }},
{8989, {{0, "All"}, {1, "On Highway"}, {2, "Agriculture"}, {3, "Construction"}, {4, "Marine"}, {5, "Industrial"}, {6, "Reserved 1"}, {7, "Reserved 2"}, }},
{8991, {{0, "Ack"}, {1, "Nak"}, {2, "Dny"}, }},
{8996, {{-1, "Do Not Care"}, {241, "Unsupported"}, {242, "Not Available"}, {243, "Data Access Error"}, {244, "Data Not Available"}, {245, "Data Invalid"}, {246, "DLC Invalid"}, {247, "Message Count"}, {248, "CAC"}, {249, "Configuration Type"}, {250, "Protocol"}, {251, "Security"}, {252, "Wrong Mode"}, {253, "Memory Error"}, }},
{9001, {{0, "Default"}, {128, "User Interface"}, {129, "Inverter Charger"}, {130, "Inverter"}, {131, "Charger"}, {132, "Battery Monitor"}, {133, "AGS"}, {134, "Diagnostic Terminal"}, {135, "Gateway"}, {136, "Energy Management System"}, {137, "Battery Management System"}, {249, "Service Tool"}, {250, "System Clock"}, }},
{9002, {{0, "Reserved"}, {10, "System Tools"}, {20, "Safety"}, {25, "Gateway"}, {30, "Power Management"}, {40, "Steering"}, {50, "Propulsion"}, {60, "Navigation"}, {70, "Communications"}, {80, "Instrumentation And General"}, {90, "Environmental"}, {100, "Deck Cargo Fishing"}, }},
{9066, {{0, "Off"}, {1, "On"}, {2, "Reserved"}, {3, "No Change"}, }},
{9075, {{0, "Off"}, {1, "On"}, {2, "Error"}, {3, "Unknown"}, }},
{9275, {{0, "ReqMessage"}, {1, "CmndMessage"}, {2, "AckMessage"}, }},
{9276, {{0, "TxPGNListMessage"}, {1, "RxPGNListMessage"}, }},
{9404, {{0, "Disabled"}, {1, "Invert"}, {2, "AC Passthru"}, {3, "APS Only"}, {4, "Load Sense"}, {5, "Waiting To Invert"}, {6, "Generator Support"}, {255, "No Data"}, }},
{9405, {{0, "Disable"}, {1, "Enable Inverter"}, }},
{9407, {{0, "Disable"}, {1, "Not Charging"}, {2, "Bulk"}, {3, "Absorption"}, {4, "Overcharge"}, {5, "Equalize"}, {6, "Float"}, {7, "Constant Voltage Constant Current"}, {255, "No Data"}, }},
{9408, {{0, "Constant Voltage"}, {1, "Constant Current"}, {2, "3 Stage"}, {3, "2 Stage"}, {4, "Trickle"}, {249, "Custom 2"}, {250, "Custom 1"}, {255, "No Data"}, }},
{9409, {{0, "Standalone"}, {1, "Primary"}, {2, "Secondary"}, {3, "Linked To DC Source"}, {255, "No Data"}, }},
{9410, {{0, "Flooded"}, {1, "Gel"}, {2, "AGM"}, {3, "Lithium-Iron-Phosphate"}, {11, "BMS Directed Custom Li-Ion"}, {12, "Custom Li-Ion For CC/CV"}, {13, "Custom 1"}, {15, "No Data"}, }},
{9411, {{0, "Disable"}, {1, "Enable Charger"}, {2, "Start Equalization"}, {3, "Top Up Battery"}, {255, "Data Not Available"}, }},
{9415, {{0, "Stop"}, {1, "Start"}, {2, "Manual Prime"}, {3, "Manual Preheat"}, }},
{9417, {{1, "Run Crank Inputs"}, {2, "Crank Glow Stop Inputs"}, {3, "Preheat Start Prime Stop Inputs"}, {4, "Single On Off Input"}, }},
{9419, {{0, "Datum Above Normal Operating Range"}, {1, "Datum Below Normal Operating Range"}, {2, "Datum Erratic Intermittent Invalid"}, {3, "Short Circuit High Voltage"}, {4, "Short Circuit Low Voltage"}, {5, "Current Below Normal"}, {6, "Current Above Normal"}, {7, "Mechanical System Not Responding"}, {8, "Abnormal Frequency Pulse Width Period"}, {9, "Abnormal Update Rate"}, {10, "Abnormal Rate of Change"}, {11, "Failure Not Identifiable"}, {12, "Bad Intelligent Device Component"}, {13, "Out Of Calibration"}, {14, "None Of The Above"}, {15, "Datum Valid But Above Normal - Least Severe"}, {16, "Datum Valid But Above Normal - Moderately Severe"}, {17, "Datum Valid But Below Normal - Least Severe"}, {18, "Datum Valid But Below Normal - Moderately Severe"}, {19, "Received Invalid Network Datum"}, {20, "Polarity Reversed"}, {21, "Networked Device Not Responding"}, {22, "Reserved 1"}, {23, "Reserved 2"}, {24, "Reserved 3"}, {25, "Reserved 4"}, {26, "Reserved 5"}, {27, "Reserved 6"}, {28, "Reserved 7"}, {29, "Reserved 8"}, {30, "Reserved 9"}, {31, "No Failure Information Available"}, }},
{9421, {{0, "No Complementary Leg"}, {1, "In Phase"}, {2, "Split Phase"}, {3, "Variable Phase"}, {14, "Error"}, {15, "No Data"}, }},
{9422, {{0, "Dc Voltage"}, {1, "Dc Soc"}, {2, "Dc Current"}, {3, "Amb Temp"}, {4, "Xfer Switch Ac Point Voltage"}, {128, "Proprietary 1"}, {129, "Proprietary 2"}, {130, "Proprietary 3"}, }},
{101476251, {{0, "Wait File DL Inf"}, {1, "Wait File DL Blk"}, {2, "Writing Blk"}, {3, "Checking File"}, {4, "Wait Reboot"}, {5, "Erasing Blk"}, }},
{217496074, {{0, "DCDC Enable/Disable"}, {1, "Device Mode"}, {2, "Association"}, {3, "Auxiliary Configuration"}, {4, "Auxiliary Trigger Level"}, {5, "Auxiliary Trigger Delay"}, {6, "Audible Alarm Enable/Disable"}, {7, "Auxiliary Status"}, }},
{240482193, {{0, "Unknown"}, {1, "Grid Priority"}, {2, "Generator Priority"}, {3, "Inverter Priority"}, }},
{276767036, {{0, "Connected"}, {1, "Disconnected"}, }},
{281300007, {{0, "Invalid"}, {1, "Line 1"}, {2, "Line 2"}, {3, "Line 3"}, {13, "Reserved"}, {14, "Out Of Range"}, {15, "Data Not Available Do Not Change"}, }},
{321179986, {{0, "Invalid"}, {1, "None"}, {2, "Anonymous"}, {3, "Shore1"}, {4, "Shore2"}, {5, "Shore3"}, {6, "Shore4"}, {7, "Shore5"}, {8, "Shore6"}, {9, "Shore7"}, {10, "Shore8"}, {11, "Shore9"}, {12, "Shore10"}, {13, "Shore11"}, {14, "Shore12"}, {15, "Shore13"}, {16, "Shore14"}, {17, "Shore15"}, {18, "Shore16"}, {19, "Gen1"}, {20, "Gen2"}, {21, "Gen3"}, {22, "Gen4"}, {23, "Gen5"}, {24, "Gen6"}, {25, "Gen7"}, {26, "Gen8"}, {27, "Gen9"}, {28, "Gen10"}, {29, "Gen11"}, {30, "Gen12"}, {31, "Gen13"}, {32, "Gen14"}, {33, "Gen15"}, {34, "Gen16"}, {35, "AC1"}, {36, "AC2"}, {37, "AC3"}, {38, "AC4"}, {39, "AC5"}, {40, "AC6"}, {41, "AC7"}, {42, "AC8"}, {43, "AC9"}, {44, "AC10"}, {45, "AC11"}, {46, "AC12"}, {47, "AC13"}, {48, "AC14"}, {49, "AC15"}, {50, "AC16"}, {51, "AC Load1"}, {52, "AC Load2"}, {53, "AC Load3"}, {54, "AC Load4"}, {55, "AC Load5"}, {56, "AC Load6"}, {57, "AC Load7"}, {58, "AC Load8"}, {59, "AC Load9"}, {60, "AC Load10"}, {61, "AC Load11"}, {62, "AC Load12"}, {63, "AC Load13"}, {64, "AC Load14"}, {65, "AC Load15"}, {66, "AC Load16"}, {67, "Grid1"}, {68, "Grid2"}, {69, "Grid3"}, {70, "Grid4"}, {71, "Grid5"}, {72, "Grid6"}, {73, "Grid7"}, {74, "Grid8"}, {75, "Grid9"}, {76, "Grid10"}, {77, "Grid11"}, {78, "Grid12"}, {79, "Grid13"}, {80, "Grid14"}, {81, "Grid15"}, {82, "Grid16"}, {252, "All"}, {253, "Reserved"}, {254, "Out Of Range"}, {255, "Data Not Available Do Not Change"}, }},
{421711928, {{0, "Invalid"}, {1, "Main House Battery Bank"}, {2, "Chassis Start Battery"}, {3, "Secondary House Battery Bank"}, {255, "Unknown Do Not Change"}, }},
{498223742, {{0, "Invalid"}, {1, "Being Qualified"}, {2, "Bad Frequency"}, {3, "Bad Level"}, {4, "Good"}, {21, "Frequency Low"}, {22, "Frequency High"}, {31, "Voltage Low"}, {32, "Voltage High"}, {253, "Reserved"}, {254, "Out Of Range"}, {255, "Data Not Available Do Not Change"}, }},
{535997516, {{0, "XanBus"}, {1, "OperatingSystem"}, {2, "Application"}, {3, "Loader"}, {4, "Reserved2"}, {5, "Other1"}, {6, "Other2"}, {253, "Reserved"}, {254, "Out Of Range"}, {255, "Data Not Available Do Not Change"}, }},
{666383381, {{0, "Not Derating"}, {1, "High Internal Temperature"}, {2, "High Battery Temperature"}, {3, "Battery Voltage"}, {4, "AC Input Voltage"}, {5, "AC Input Current"}, }},
{872434401, {{0, "Unqualified No AC Present"}, {1, "Unqualified Bad AC"}, {2, "Waiting to Qualify"}, {3, "Qualifying"}, {4, "Qualified Good AC"}, {15, "Undefined Value"}, }},
{972277822, {{0, "Time to Empty"}, {1, "Time to Full"}, }},
{1426290752, {{0, "No Error"}, {1, "Invalid File DL Inf"}, {2, "Invalid File DL Blk"}, {3, "Blk Write Err"}, {4, "File CRC Err"}, }},
{1484268128, {{0, "Not pre-charging"}, {1, "Pre-charging for equalization"}, {2, "Reserved"}, {3, "Undefined Value"}, }},
{1484338823, {{0, "True Sine Wave"}, {1, "Not Sine Wave"}, {2, "Reserved"}, {3, "No Data"}, }},
{1484358105, {{0, "Charging Not Forced"}, {1, "Force Charge To Bulk"}, {2, "Force Charge To Float"}, {14, "No Change"}, {15, "Undefined"}, }},
{1485834791, {{0, "Voltage OK"}, {1, "Extremely Low Voltage"}, {2, "Low Voltage"}, {3, "High Voltage"}, {4, "Extremely High Voltage"}, {5, "Open Line 1 Detected"}, {6, "Open Line 2 Detected"}, {252, "Reserved"}, {254, "Out Of Range"}, {255, "Data Not Available"}, }},
{1486082168, {{20, "Voltmeter"}, {40, "Voltmeter Ammeter"}, {60, "Inverter"}, {80, "Charger"}, {100, "Inverter Charger"}, {120, "Battery SOC Device"}, {255, "No Data"}, }},
{1546649241, {{0, "Invalid"}, {1, "DCInput"}, {2, "DCOut"}, {3, "DCInputOut"}, {4, "Reserved"}, {5, "ACInput"}, {6, "ACOut"}, {7, "ACInputOut"}, }},
{1546651609, {{0, "Invalid"}, {1, "SinglePhaseStandAlone"}, {11, "SinglePhaseMaster"}, {12, "SinglePhaseSlave"}, {20, "SplitPhaseStandAlone"}, {21, "SplitPhaseMaster"}, {22, "SplitPhaseSlave"}, {23, "TwoPhase Phase1Master"}, {24, "TwoPhase Phase1Slave"}, {25, "TwoPhase Phase2Master"}, {26, "TwoPhase Phase2Slave"}, {30, "ThreePhaseStandAlone"}, {31, "ThreePhaseMaster"}, {32, "ThreePhaseSlave"}, {33, "ThreePhase Phase1Master"}, {34, "ThreePhase Phase1Slave"}, {35, "ThreePhase Phase2Master"}, {36, "ThreePhase Phase2Slave"}, {37, "ThreePhase Phase3Master"}, {38, "ThreePhase Phase3Slave"}, {253, "Reserved"}, {254, "Out Of Range"}, {255, "Data Not Available Do Not Change"}, }},
{1546979661, {{0, "Invalid"}, {1, "Assoc Cfg"}, {2, "Request"}, {3, "Assoc Sts"}, {4, "Dev Mode Cfg"}, {5, "FXCC Cfg Cmd"}, {6, "Dev Mode Sts"}, {7, "FXCC Cfg Sts"}, {8, "SW Ver Sts"}, {9, "RPC Cmd"}, {10, "Inv LS Sts"}, {11, "Inv Sts"}, {12, "Chg Sts"}, {14, "Inv Ctrl Cmd"}, {15, "AC Sts RMS"}, {16, "AC Xfer Sw Sts"}, {17, "Get Configuration Parameter"}, {18, "Set Configuration Parameter"}, {19, "Get Status Parameter"}, {96, "PpnSessionCmd"}, {97, "PpnSessionRsp"}, {98, "PpnReadCmd"}, {99, "PpnReadRsp"}, {100, "PpnWriteCmd"}, {101, "PpnWriteRsp"}, {127, "PpnNakRsp"}, {170, "Lithionics Cmd"}, {171, "Lithionics Sts"}, }},
{1552924287, {{0, "Off"}, {1, "Lock Out"}, {2, "Auto Off"}, {3, "Error"}, }},
{1558143328, {{1, "Battery Current"}, {2, "Battery Voltage"}, {3, "APS Voltage"}, {4, "AC1_In Current L1"}, {5, "AC1_In Current L2"}, {6, "AC1_In Voltage L1"}, {7, "AC1_In Voltage L2"}, {8, "AC1_In Voltage L1L2"}, {9, "AC2_In Current L1"}, {10, "AC2_In Current L2"}, {11, "AC2_In Voltage L1"}, {12, "AC2_In Voltage L2"}, {13, "AC2_In Voltage L1L2"}, {14, "AC Out Voltage"}, {15, "AC Out Current"}, {16, "AC Out Hi Res Current"}, {17, "AC Out Current L1"}, {18, "AC Out Current L2"}, {19, "Ref AC Out Voltage RMS"}, {20, "Ref DC Out Voltage"}, {21, "Ref DC Out Current"}, {22, "DC_DC Out Current"}, {23, "DC_DC Out Voltage"}, }},
{1576267937, {{0, "Invalid"}, {1, "AC Input 1"}, {2, "AC Input 2"}, {3, "AC Input 3"}, {4, "AC Input 4"}, {5, "AC Output 1"}, {6, "AC Output 2"}, {7, "AC Output 3"}, {8, "AC Output 4"}, {13, "Reserved"}, {14, "Out Of Range"}, {15, "Data Not Available Do Not Change"}, }},
{1594080027, {{0, "Auto On"}, {1, "Auto Off"}, {2, "Manual On"}, {3, "Manual Off"}, }},
{1594238759, {{0, "Battery Voltage Low Set"}, {1, "Battery Voltage Low Clr"}, {2, "Battery Voltage High Set"}, {3, "Battery Voltage High Clr"}, {4, "Battery Temp Low Set"}, {5, "Battery Temp Low Clr"}, {6, "Battery Temp High Set"}, {7, "Battery Temp High Clr"}, {8, "Fault Set"}, {9, "Fault Clr"}, {10, "AC Good Set"}, {11, "AC Good Clr"}, {12, "Bulk Exit Clr"}, {13, "Absorption Exit Clr"}, {14, "Internal Temp High Set"}, {15, "Internal Temp High Clr"}, {16, "Time Of Day Set"}, {17, "Time Of Day Clr"}, }},
{1599683911, {{0, "Undefined Source Decides"}, {1, "Do Not Charge"}, {2, "Bulk"}, {3, "Absorption"}, {4, "Overcharge"}, {5, "Equalize"}, {6, "Float"}, {7, "CVCC"}, {255, "No Data"}, }},
{1608161778, {{0, "Off"}, {1, "On"}, }},
{1650332213, {{0, "Not Charging"}, {1, "Bulk"}, {2, "Absorption"}, {3, "Overcharge"}, {4, "Equalize"}, {5, "Float"}, {6, "No Float"}, {7, "Constant VI"}, {8, "Charger Disabled"}, {9, "Qualifying AC"}, {10, "Qualifying APS"}, {11, "Engaging Charger"}, {12, "Charge Fault"}, {13, "Charger Suspend"}, {14, "AC Good"}, {15, "APS Good"}, {16, "AC Fault"}, {17, "Charge"}, {18, "Absorption Exit Pending"}, {19, "Ground Fault"}, {20, "AC Good Pending"}, {21, "Load Shaving"}, {22, "AC Support"}, {23, "AC Coupled"}, {24, "AC Coupled Bulk"}, {25, "AC Coupled Absorption"}, {26, "AC Coupled Float"}, {27, "AC Coupled No Float"}, {28, "External BMS"}, {29, "Load Sense"}, }},
{1653075463, {{0, "Cell Not Balance"}, {1, "Balance Process Active"}, }},
{1659473592, {{0, "Off"}, {1, "On"}, {254, "Reserved"}, {255, "No Data"}, }},
{1663267569, {{0, "DCDC Voltage"}, {1, "DCDC Current"}, {2, "Auxiliary Status"}, }},
{1671234938, {{0, "Invalid"}, {1, "Source Connection"}, {2, "Load Connection"}, {3, "Primary To Secondary Bridge"}, {4, "Main Battery Contactor"}, {5, "Reserved1"}, {6, "Reserved2"}, {7, "Reserved3"}, {8, "Reserved4"}, {9, "Reserved5"}, {10, "Reserved6"}, {11, "Reserved7"}, {12, "Reserved8"}, {13, "Reserved9"}, {14, "Reserved10"}, {15, "Unspecified"}, }},
{1679608493, {{0, "Standalone"}, {1, "Primary"}, {2, "Secondary"}, {3, "Echo"}, {253, "Reserved"}, {254, "Out of Range"}, {255, "Data Not Available Do Not Change"}, }},
{1687015300, {{0, "Invert"}, {1, "AC Passthru"}, {2, "APSOnly"}, {3, "Load Sense Active"}, {4, "Inverter Disabled"}, {5, "Load Sense Ready"}, {6, "Engaging Inverter"}, {7, "Invert Fault"}, {8, "Inverter Standby"}, {9, "Grid Tied"}, {10, "Grid Support"}, {11, "Gen Support"}, {12, "Sell To Grid"}, {13, "Load Shaving"}, {14, "Grid Frequency Stabilization"}, {15, "AC Coupling"}, {16, "Reverse Ibatt"}, }},
{2027188828, {{0, "Reboot"}, {1, "RebootDLMode"}, {2, "Factory"}, {3, "OEM"}, {4, "Clear Nv And Reboot"}, {252, "NoChange"}, {253, "Reserved"}, {254, "Out Of Range"}, {255, "Data Not Available Do Not Change"}, }},
{2041349348, {{0, "Charger Not Derating"}, {1, "Charger Derating"}, }},
{2056474510, {{0, "Line 1"}, {1, "Line 2"}, {2, "Reserved"}, {3, "Undefined"}, }},
{2110464705, {{0, "Active Low"}, {1, "Active High"}, {2, "Data Not Supported"}, }},
};

std::map<std::tuple<int, int, int>, std::string> global_spns = {
    {std::make_tuple(0, 0, 0), "Specific Point Unknown"},
    {std::make_tuple(0, 0, 1), "Node Microprocessor (or ECM)"},
    {std::make_tuple(0, 0, 2), "Node Analog-Digital Converter"},
    {std::make_tuple(0, 0, 3), "Node Settings or Configuration"},
    {std::make_tuple(0, 0, 4), "Node RAM"},
    {std::make_tuple(0, 0, 5), "Node Power Supply"},
    {std::make_tuple(0, 0, 6), "Node Temperature"},
    {std::make_tuple(0, 0, 7), "Node Clock / Timer"},
    {std::make_tuple(0, 1, 0), "Node Date / Time"},
    {std::make_tuple(0, 1, 1), "Node RV-C Connection"},
    {std::make_tuple(0, 1, 2), "Node Serial/ID Number"},
    {std::make_tuple(0, 1, 3), "Node Processor Supervisor (Watchdog)"},
    {std::make_tuple(0, 1, 4), "Node Firmware"},
    {std::make_tuple(0, 1, 5), "Node Internal Subnetwork Communications"},
};


    std::map<int, std::map<std::tuple<int, int>, std::string>> spn_mapping = {
        {65, {
        {std::make_tuple(1, 0), "Invalid Configuration"},
        {std::make_tuple(1, 1), "Data Not Available"},
    }},
    {66, {
        {std::make_tuple(1, 0), "DC Voltage"},
        {std::make_tuple(1, 1), "DC Current"},
        {std::make_tuple(1, 2), "Battery Temperature"},
        {std::make_tuple(1, 3), "DC Source State of Charge"},
        {std::make_tuple(1, 4), "DC Source State of Health"},
        {std::make_tuple(1, 5), "DC Source Capacity"},
        {std::make_tuple(1, 6), "DC Source AC Ripple"},
        {std::make_tuple(1, 7), "AC Backfeed"},
        {std::make_tuple(2, 0), "FET #1 Temperature"},
        {std::make_tuple(2, 1), "FET #2 Temperature"},
        {std::make_tuple(2, 2), "Control/Power Board Temperature"},
        {std::make_tuple(2, 3), "Cooling Fan"},
        {std::make_tuple(3, 0), "DC Bulk Capacitor Temperature"},
        {std::make_tuple(3, 1), "Transformer Temperature"},
        {std::make_tuple(3, 2), "Ambient Temperature"},
        {std::make_tuple(3, 3), "Battery Charger Timeout"},
        {std::make_tuple(3, 4), "Battery Equalization"},
        {std::make_tuple(3, 5), "DC Bridge"},
        {std::make_tuple(3, 6), "Transfer Relay"},
        {std::make_tuple(3, 7), "Stacking Configuration"},
        {std::make_tuple(4, 0), "Stacking Communication"},
        {std::make_tuple(4, 1), "Stacking Sync Clock"},
        {std::make_tuple(129, 0), "RMS Voltage"},
        {std::make_tuple(129, 1), "RMS Current"},
        {std::make_tuple(129, 2), "Frequency"},
        {std::make_tuple(129, 3), "Open Ground"},
        {std::make_tuple(129, 4), "Open Neutral"},
        {std::make_tuple(129, 5), "Reverse Polarity"},
        {std::make_tuple(129, 6), "Ground Fault"},
        {std::make_tuple(129, 7), "Peak Voltage"},
        {std::make_tuple(130, 0), "Peak Current"},
        {std::make_tuple(130, 1), "Ground Current"},
        {std::make_tuple(130, 2), "Real Power"},
        {std::make_tuple(130, 3), "Reactive Power"},
        {std::make_tuple(130, 4), "Harmonic Distortion"},
        {std::make_tuple(130, 5), "AC Phase Status"},
        {std::make_tuple(131, 0), "Anti-Islanding Frequency"},
        {std::make_tuple(131, 1), "Anti-Islanding Voltage"},
        {std::make_tuple(132, 0), "APS Voltage"},
        {std::make_tuple(132, 1), "APS Current"},
        {std::make_tuple(132, 2), "APS Temperature"},
        {std::make_tuple(133, 0), "OPS Voltage"},
        {std::make_tuple(133, 1), "OPS Current"},
        {std::make_tuple(133, 2), "OPS Temperature"},
        {std::make_tuple(134, 0), "DC Bus Voltage"},
        {std::make_tuple(134, 1), "DC Bus Current"},
        {std::make_tuple(134, 2), "DC Bus Temperature"},
    }},
    {141, {
        {std::make_tuple(1, 0), "DC Voltage"},
        {std::make_tuple(1, 1), "DC Current"},
        {std::make_tuple(1, 2), "Battery Temperature"},
        {std::make_tuple(1, 3), "DC Source State of Charge"},
        {std::make_tuple(1, 4), "DC Source State of Health"},
        {std::make_tuple(1, 5), "DC Source Capacity"},
        {std::make_tuple(1, 6), "DC Source AC Ripple"},
        {std::make_tuple(1, 7), "DC Source Reverse Polarity"},
        {std::make_tuple(2, 0), "Ambient Temperature"},
        {std::make_tuple(2, 1), "Battery Equalization"},
        {std::make_tuple(2, 2), "Solar Array Voltage"},
        {std::make_tuple(2, 3), "Solar Array Current"},
    }},
};

typedef struct MessageBase {
virtual ~MessageBase() = default;
virtual std::string fnGetValue(const std::string mnem) const = 0;
virtual uint32 fnGetRawValue(const std::string mnem) const = 0;
virtual long double fnGetFloatValue(const std::string mnem) const = 0;
virtual void Print() const = 0;
virtual string fnTranslate(string func, const string param_value="") const = 0;
virtual void fnSend(uint32 pgn, int grpfunc, int addr) = 0;
virtual bool isInteger(const std::string& str) {
    try {
        std::size_t pos;
        uint32 num = std::stoll(str, &pos);
        cout << "is_int: " << (pos == str.size()) << endl;
        return pos == str.size();  // Check if the entire string was converted
    } catch (std::invalid_argument&) {
        return false;  // Not an integer
    } catch (std::out_of_range&) {
        return false;  // The number is out of the range for an int
    }
}
virtual uint32 stringToInt(const std::string& buffer, uint32 noDataValue, uint32 outOfRangeValue, uint32 reservedValue, long double scale = 1, long double offset = 0) { 
    if (isInteger(buffer)) return std::stoll(buffer);
    else if (buffer == "No Data") {
        return noDataValue;
    } else if (buffer == "Out of range") {
        return outOfRangeValue;
    } else if (buffer == "Reserved") {
        return reservedValue;
    } else {
        // Extract the numeric value from the buffer
        std::string numericPart = buffer.substr(0, buffer.find(' '));
        try {
            long double value = std::stold(numericPart);  // Convert to integer
            value /= scale;
            value -= offset;
            return (uint32)(value+0.5);
        } catch (const std::invalid_argument&) {
            cout <<  "Conversion failed" << endl;
        } catch (const std::out_of_range&) {
            cout << "Value was out of range for uint32" << endl; 
        }
    }
    return 0xFFFFFFFF;
}
virtual int findEnumValue(const std::unordered_map<int, std::string>& enumMap, const std::string& value) {
    for (const auto& [key, valStr] : enumMap) {
        if (valStr == value) {
            return key;
        }
    }
    return -1;  // If not found
}
virtual void fnSetValue(const std::string mnem, const std::string value) = 0;
virtual bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const = 0;
} MessageBase;

// Auto-generated class definition for RVC_tzPGN_PROD_IDENT
typedef struct ProdIdent : public MessageBase {
RVC_tzPGN_PROD_IDENT msg;
ProdIdent () {  memset(&msg, 0xFF, sizeof(msg));  };
ProdIdent (void * pvStruct) {  msg = *(RVC_tzPGN_PROD_IDENT *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Data") {
            std::string s;
            for(int i =0; i < msg.uiExtraCount; i++) {
            uchar8 ucData = msg.ptzExtra[i].ucData;
            s += (ucData);
          }
            return s;
        }
if (mnem == "Make"){
    std::string s;
    for (int i = 0; i < msg.uiExtraCount; i++) {
        uchar8 ucData = msg.ptzExtra[i].ucData;
        if (ucData == '*') break;
        s += (ucData);
    }
    return s;
}
else if (mnem == "Model"){
    std::string s;
    int c = 0;
    for (int i = 0; i < msg.uiExtraCount; i++) {
        uchar8 ucData = msg.ptzExtra[i].ucData;
        if (c == 1 && ucData != '*') s += (ucData);
        if (ucData == '*') c++;
        if (c == 2) break;
    }
    return s;
}
else if (mnem == "Serial"){
    std::string s;
    int c = 0;
    for (int i = 0; i < msg.uiExtraCount; i++) {
        uchar8 ucData = msg.ptzExtra[i].ucData;
        if (c == 2 && ucData != '*') s += (ucData);
        if (ucData == '*') c++;
        if (c == 3) break;
    }
    return s;
}
else if (mnem == "Unit"){
    std::string s;
    int c = 0;
    for (int i = 0; i < msg.uiExtraCount; i++) {
        uchar8 ucData = msg.ptzExtra[i].ucData;
        if (c == 3 && ucData != '*') s += (ucData);
        if (ucData == '*') c++;
        if (c == 4) break;
    }
    return s;
}
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ProdIdent" << std::endl;
        cout << "Data      : " << fnGetValue("Data") << endl;
     cout << "   " << fnGetValue("Make") << endl;
     cout << "   " << fnGetValue("Model") << endl;
     cout << "   " << fnGetValue("Serial") << endl;
     cout << "   " << fnGetValue("Unit") << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        return 0.0;
    }
} ProdIdent;

// Auto-generated class definition for RVC_tzPGN_FILE_DNLD_BLK
typedef struct FileDnldBlk : public MessageBase {
RVC_tzPGN_FILE_DNLD_BLK msg;
FileDnldBlk () {  memset(&msg, 0xFF, sizeof(msg));  };
FileDnldBlk (void * pvStruct) {  msg = *(RVC_tzPGN_FILE_DNLD_BLK *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "BlkNum") {
            return (msg.uiBlkNum == 0xffff) ? "No Data" : (msg.uiBlkNum == 0xfffe) ? "Out of range" : (msg.uiBlkNum == 0xfffd) ? "Reserved" : std::to_string(msg.uiBlkNum);
        }
        else if (mnem == "BlkSz") {
            return (msg.uiBlkSz == 0xffff) ? "No Data" : (msg.uiBlkSz == 0xfffe) ? "Out of range" : (msg.uiBlkSz == 0xfffd) ? "Reserved" : std::to_string(msg.uiBlkSz);
        }
        else if (mnem == "BlkData") {
            std::string s;
            for(int i =0; i < msg.uiExtraCount; i++) {
            uchar8 ucBlkData = msg.ptzExtra[i].ucBlkData;
            char buffer[50];
            auto engval = 1.0 * (long double) (ucBlkData + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "8-Bit Bytes");
            s += (ucBlkData == 0xff) ? "No Data" : (ucBlkData == 0xfe) ? "Out of range" : (ucBlkData == 0xfd) ? "Reserved" : (buffer);
          }
            return s;
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: FileDnldBlk" << std::endl;
        cout << "BlkNum      : " << fnGetValue("BlkNum") << " (" << fnGetRawValue("BlkNum") << ")" << endl;
        cout << "BlkSz      : " << fnGetValue("BlkSz") << " (" << fnGetRawValue("BlkSz") << ")" << endl;
        cout << "BlkData      : " << fnGetValue("BlkData") << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "BlkNum") {
            return static_cast<uint32_t>(msg.uiBlkNum);
        }
        else if (mnem == "BlkSz") {
            return static_cast<uint32_t>(msg.uiBlkSz);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "BlkNum") {
     msg.uiBlkNum = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "BlkSz") {
     msg.uiBlkSz = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "BlkNum") {
            return 1.0 * (long double)(msg.uiBlkNum + 0.0);
        }
        else if (mnem == "BlkSz") {
            return 1.0 * (long double)(msg.uiBlkSz + 0.0);
        }
        return 0.0;
    }
} FileDnldBlk;

// Auto-generated class definition for RVC_tzPGN_SW_VER_STS
typedef struct SwVerSts : public MessageBase {
RVC_tzPGN_SW_VER_STS msg;
SwVerSts () {  memset(&msg, 0xFF, sizeof(msg));  };
SwVerSts (void * pvStruct) {  msg = *(RVC_tzPGN_SW_VER_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgCount") {
            return std::to_string(msg.ucMsgCount);
        }
        else if (mnem == "ProcessorInst") {
            std::string s;
            for(int i =0; i < msg.uiExtraCount; i++) {
            uchar8 ucProcessorInst = msg.ptzExtra[i].ucProcessorInst;
            s += std::to_string(ucProcessorInst);
          }
            return s;
        }
        else if (mnem == "SwModId") {
            std::string s;
            for(int i =0; i < msg.uiExtraCount; i++) {
            RVC_teSW_MOD_ID teSwModId = msg.ptzExtra[i].teSwModId;
            if (ENUMLOOKUP[535997516].find(teSwModId) == ENUMLOOKUP[535997516].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", teSwModId);
                 s += (buffer);
            } else {
                 s += ENUMLOOKUP[535997516][teSwModId];
              }
          }
            return s;
        }
        else if (mnem == "SwVer") {
            std::string s;
            for(int i =0; i < msg.uiExtraCount; i++) {
            uint32 ulSwVer = msg.ptzExtra[i].ulSwVer;
            s += (ulSwVer == 0xffffffff) ? "No Data" : (ulSwVer == 0xfffffffe) ? "Out of range" : (ulSwVer == 0xfffffffd) ? "Reserved" : std::to_string(ulSwVer);
          }
            return s;
        }
        else if (mnem == "SwBldNum") {
            std::string s;
            for(int i =0; i < msg.uiExtraCount; i++) {
            uint16 uiSwBldNum = msg.ptzExtra[i].uiSwBldNum;
            s += (uiSwBldNum == 0xffff) ? "No Data" : (uiSwBldNum == 0xfffe) ? "Out of range" : (uiSwBldNum == 0xfffd) ? "Reserved" : std::to_string(uiSwBldNum);
          }
            return s;
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SwVerSts" << std::endl;
        cout << "MsgCount      : " << fnGetValue("MsgCount") << " (" << fnGetRawValue("MsgCount") << ")" << endl;
        cout << "ProcessorInst      : " << fnGetValue("ProcessorInst") << endl;
        cout << "SwModId      : " << fnGetValue("SwModId") << endl;
        cout << "SwVer      : " << fnGetValue("SwVer") << endl;
        cout << "SwBldNum      : " << fnGetValue("SwBldNum") << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgCount") {
            return static_cast<uint32_t>(msg.ucMsgCount);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgCount") {
     msg.ucMsgCount = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgCount") {
            return 1.0 * (long double)(msg.ucMsgCount + 0.0);
        }
        return 0.0;
    }
} SwVerSts;

// Auto-generated class definition for RVC_tzPGN_DIAG_MSG1
typedef struct DiagMsg1 : public MessageBase {
RVC_tzPGN_DIAG_MSG1 msg;
DiagMsg1 () {  memset(&msg, 0xFF, sizeof(msg));  };
DiagMsg1 (void * pvStruct) {  msg = *(RVC_tzPGN_DIAG_MSG1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "OpStsProdOn") {
            if (ENUMLOOKUP[9075].find(msg.teOpStsProdOn) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOpStsProdOn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teOpStsProdOn];
              }
        }
        else if (mnem == "OpStsProdActive") {
            if (ENUMLOOKUP[9075].find(msg.teOpStsProdActive) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOpStsProdActive);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teOpStsProdActive];
              }
        }
        else if (mnem == "OpStsYel") {
            if (ENUMLOOKUP[9075].find(msg.teOpStsYel) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOpStsYel);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teOpStsYel];
              }
        }
        else if (mnem == "OpStsRed") {
            if (ENUMLOOKUP[9075].find(msg.teOpStsRed) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOpStsRed);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teOpStsRed];
              }
        }
        else if (mnem == "ProdId") {
            if (ENUMLOOKUP[8982].find(msg.teProdId) == ENUMLOOKUP[8982].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teProdId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[8982][msg.teProdId];
              }
        }
        else if (mnem == "SpnMsb") {
            std::string s;
            for(int i =0; i < msg.uiExtraCount; i++) {
            uchar8 ucSpnMsb = msg.ptzExtra[i].ucSpnMsb;
            s += (ucSpnMsb == 0xff) ? "No Data" : (ucSpnMsb == 0xfe) ? "Out of range" : (ucSpnMsb == 0xfd) ? "Reserved" : std::to_string(ucSpnMsb);
          }
            return s;
        }
        else if (mnem == "SpnIsb") {
            std::string s;
            for(int i =0; i < msg.uiExtraCount; i++) {
            uchar8 ucSpnIsb = msg.ptzExtra[i].ucSpnIsb;
            s += (ucSpnIsb == 0xff) ? "No Data" : (ucSpnIsb == 0xfe) ? "Out of range" : (ucSpnIsb == 0xfd) ? "Reserved" : std::to_string(ucSpnIsb);
          }
            return s;
        }
        else if (mnem == "Fmi") {
            std::string s;
            for(int i =0; i < msg.uiExtraCount; i++) {
            RVC_teSAEJ1939FMI teFmi = msg.ptzExtra[i].teFmi;
            if (ENUMLOOKUP[9419].find(teFmi) == ENUMLOOKUP[9419].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", teFmi);
                 s += (buffer);
            } else {
                 s += ENUMLOOKUP[9419][teFmi];
              }
          }
            return s;
        }
        else if (mnem == "SpnLsb") {
            std::string s;
            for(int i =0; i < msg.uiExtraCount; i++) {
            uchar8 ucSpnLsb = msg.ptzExtra[i].ucSpnLsb;
            s += std::to_string(ucSpnLsb);
          }
            return s;
        }
        else if (mnem == "OccurrenceCnt") {
            std::string s;
            for(int i =0; i < msg.uiExtraCount; i++) {
            uchar8 ucOccurrenceCnt = msg.ptzExtra[i].ucOccurrenceCnt;
            s += std::to_string(ucOccurrenceCnt);
          }
            return s;
        }
        else if (mnem == "ProdIdExt") {
            std::string s;
            for(int i =0; i < msg.uiExtraCount; i++) {
            uchar8 ucProdIdExt = msg.ptzExtra[i].ucProdIdExt;
            s += (ucProdIdExt == 0xff) ? "No Data" : (ucProdIdExt == 0xfe) ? "Out of range" : (ucProdIdExt == 0xfd) ? "Reserved" : std::to_string(ucProdIdExt);
          }
            return s;
        }
       else if (mnem == "Spn"){
            std::string s;
            for(int i = 0; i < msg.uiExtraCount; i++) {
                uchar8 msb = msg.ptzExtra[i].ucSpnMsb, lsb = msg.ptzExtra[i].ucSpnLsb, isb = msg.ptzExtra[i].ucSpnIsb;
                int spn = (msb << 11) + (isb << 3) + lsb;

                if (msb == 0){
                    std::tuple<int, int, int> key = {msb, isb, lsb};
                    auto it = global_spns.find(key);
                    if (it != global_spns.end()) {
                        s += it->second;
                        if(i < (msg.uiExtraCount-1)) s += '\n';
                        continue;
                    }
                }
                else{
                    auto it = spn_mapping.find(msg.teProdId);
                    if (it != spn_mapping.end()) {
                        auto& spn_dict = it->second;
                        std::tuple<int, int> key = std::make_tuple(msb, lsb);
                        auto spn_it = spn_dict.find(key);
                        if (spn_it != spn_dict.end()) {
                            s += spn_it->second + " " + std::to_string(isb);
                            if(i < (msg.uiExtraCount-1)) s += '\n';
                            continue;
                        }
                    }
                }
                char buffer[50];
                snprintf(buffer, sizeof(buffer), "?%02x-%d-%d?", msb, isb, lsb);
                s += buffer;
                if(i < (msg.uiExtraCount-1)) s += '\n';
            }
            return s;
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: DiagMsg1" << std::endl;
        cout << "OpStsProdOn      : " << fnGetValue("OpStsProdOn") << " (" << fnGetRawValue("OpStsProdOn") << ")" << endl;
        cout << "OpStsProdActive      : " << fnGetValue("OpStsProdActive") << " (" << fnGetRawValue("OpStsProdActive") << ")" << endl;
        cout << "OpStsYel      : " << fnGetValue("OpStsYel") << " (" << fnGetRawValue("OpStsYel") << ")" << endl;
        cout << "OpStsRed      : " << fnGetValue("OpStsRed") << " (" << fnGetRawValue("OpStsRed") << ")" << endl;
        cout << "ProdId      : " << fnGetValue("ProdId") << " (" << fnGetRawValue("ProdId") << ")" << endl;
        cout << "SpnMsb      : " << fnGetValue("SpnMsb") << endl;
        cout << "SpnIsb      : " << fnGetValue("SpnIsb") << endl;
        cout << "Fmi      : " << fnGetValue("Fmi") << endl;
        cout << "SpnLsb      : " << fnGetValue("SpnLsb") << endl;
        cout << "OccurrenceCnt      : " << fnGetValue("OccurrenceCnt") << endl;
        cout << "ProdIdExt      : " << fnGetValue("ProdIdExt") << endl;
        cout << "   " << fnGetValue("Spn") << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "OpStsProdOn") {
            return static_cast<uint32_t>(msg.teOpStsProdOn);
        }
        else if (mnem == "OpStsProdActive") {
            return static_cast<uint32_t>(msg.teOpStsProdActive);
        }
        else if (mnem == "OpStsYel") {
            return static_cast<uint32_t>(msg.teOpStsYel);
        }
        else if (mnem == "OpStsRed") {
            return static_cast<uint32_t>(msg.teOpStsRed);
        }
        else if (mnem == "ProdId") {
            return static_cast<uint32_t>(msg.teProdId);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "OpStsProdOn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teOpStsProdOn = static_cast<decltype(msg.teOpStsProdOn)>(enumValue);
     else msg.teOpStsProdOn = static_cast<decltype(msg.teOpStsProdOn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OpStsProdActive") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teOpStsProdActive = static_cast<decltype(msg.teOpStsProdActive)>(enumValue);
     else msg.teOpStsProdActive = static_cast<decltype(msg.teOpStsProdActive)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OpStsYel") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teOpStsYel = static_cast<decltype(msg.teOpStsYel)>(enumValue);
     else msg.teOpStsYel = static_cast<decltype(msg.teOpStsYel)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OpStsRed") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teOpStsRed = static_cast<decltype(msg.teOpStsRed)>(enumValue);
     else msg.teOpStsRed = static_cast<decltype(msg.teOpStsRed)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ProdId") {
     int enumValue = findEnumValue(ENUMLOOKUP[8982], value);
     if (enumValue != -1) msg.teProdId = static_cast<decltype(msg.teProdId)>(enumValue);
     else msg.teProdId = static_cast<decltype(msg.teProdId)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "OpStsProdOn") {
            return 1.0 * (long double)(msg.teOpStsProdOn + 0.0);
        }
        else if (mnem == "OpStsProdActive") {
            return 1.0 * (long double)(msg.teOpStsProdActive + 0.0);
        }
        else if (mnem == "OpStsYel") {
            return 1.0 * (long double)(msg.teOpStsYel + 0.0);
        }
        else if (mnem == "OpStsRed") {
            return 1.0 * (long double)(msg.teOpStsRed + 0.0);
        }
        else if (mnem == "ProdId") {
            return 1.0 * (long double)(msg.teProdId + 0.0);
        }
        return 0.0;
    }
} DiagMsg1;

// Auto-generated class definition for RVC_tzPGN_ISO_ACK
typedef struct IsoAck : public MessageBase {
RVC_tzPGN_ISO_ACK msg;
IsoAck () {  memset(&msg, 0xFF, sizeof(msg));  };
IsoAck (void * pvStruct) {  msg = *(RVC_tzPGN_ISO_ACK *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "CtrlByte") {
            if (ENUMLOOKUP[8991].find(msg.teCtrlByte) == ENUMLOOKUP[8991].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCtrlByte);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[8991][msg.teCtrlByte];
              }
        }
        else if (mnem == "GroupFunctionValue") {
            if (ENUMLOOKUP[8996].find(msg.teGroupFunctionValue) == ENUMLOOKUP[8996].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teGroupFunctionValue);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[8996][msg.teGroupFunctionValue];
              }
        }
        else if (mnem == "ParmGrpNum") {
            return std::to_string(msg.ulParmGrpNum);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: IsoAck" << std::endl;
        cout << "CtrlByte      : " << fnGetValue("CtrlByte") << " (" << fnGetRawValue("CtrlByte") << ")" << endl;
        cout << "GroupFunctionValue      : " << fnGetValue("GroupFunctionValue") << " (" << fnGetRawValue("GroupFunctionValue") << ")" << endl;
        cout << "ParmGrpNum      : " << fnGetValue("ParmGrpNum") << " (" << fnGetRawValue("ParmGrpNum") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "CtrlByte") {
            return static_cast<uint32_t>(msg.teCtrlByte);
        }
        else if (mnem == "GroupFunctionValue") {
            return static_cast<uint32_t>(msg.teGroupFunctionValue);
        }
        else if (mnem == "ParmGrpNum") {
            return static_cast<uint32_t>(msg.ulParmGrpNum);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "CtrlByte") {
     int enumValue = findEnumValue(ENUMLOOKUP[8991], value);
     if (enumValue != -1) msg.teCtrlByte = static_cast<decltype(msg.teCtrlByte)>(enumValue);
     else msg.teCtrlByte = static_cast<decltype(msg.teCtrlByte)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "GroupFunctionValue") {
     int enumValue = findEnumValue(ENUMLOOKUP[8996], value);
     if (enumValue != -1) msg.teGroupFunctionValue = static_cast<decltype(msg.teGroupFunctionValue)>(enumValue);
     else msg.teGroupFunctionValue = static_cast<decltype(msg.teGroupFunctionValue)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ParmGrpNum") {
     msg.ulParmGrpNum = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "CtrlByte") {
            return 1.0 * (long double)(msg.teCtrlByte + 0.0);
        }
        else if (mnem == "GroupFunctionValue") {
            return 1.0 * (long double)(msg.teGroupFunctionValue + 0.0);
        }
        else if (mnem == "ParmGrpNum") {
            return 1.0 * (long double)(msg.ulParmGrpNum + 0.0);
        }
        return 0.0;
    }
} IsoAck;

// Auto-generated class definition for RVC_tzPGN_PM_PARAM_DEV_MD_CFG
typedef struct PmParamDevMdCfg : public MessageBase {
RVC_tzPGN_PM_PARAM_DEV_MD_CFG msg;
PmParamDevMdCfg () {  memset(&msg, 0xFF, sizeof(msg));  };
PmParamDevMdCfg (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PARAM_DEV_MD_CFG *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "DesiredMode") {
            if (ENUMLOOKUP[-725723354].find(msg.teDesiredMode) == ENUMLOOKUP[-725723354].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDesiredMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-725723354][msg.teDesiredMode];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmParamDevMdCfg" << std::endl;
        cout << "DesiredMode      : " << fnGetValue("DesiredMode") << " (" << fnGetRawValue("DesiredMode") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "DesiredMode") {
            return static_cast<uint32_t>(msg.teDesiredMode);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "DesiredMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[-725723354], value);
     if (enumValue != -1) msg.teDesiredMode = static_cast<decltype(msg.teDesiredMode)>(enumValue);
     else msg.teDesiredMode = static_cast<decltype(msg.teDesiredMode)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "DesiredMode") {
            return 1.0 * (long double)(msg.teDesiredMode + 0.0);
        }
        return 0.0;
    }
} PmParamDevMdCfg;

// Auto-generated class definition for RVC_tzPGN_PM_PARAM_ASSOC_CFG
typedef struct PmParamAssocCfg : public MessageBase {
RVC_tzPGN_PM_PARAM_ASSOC_CFG msg;
PmParamAssocCfg () {  memset(&msg, 0xFF, sizeof(msg));  };
PmParamAssocCfg (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PARAM_ASSOC_CFG *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "AssocType") {
            if (ENUMLOOKUP[1546649241].find(msg.teAssocType) == ENUMLOOKUP[1546649241].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAssocType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546649241][msg.teAssocType];
              }
        }
        else if (mnem == "AssocInst") {
            return std::to_string(msg.ucAssocInst);
        }
        else if (mnem == "AssocId") {
            return (msg.ucAssocId == 0xff) ? "No Data" : (msg.ucAssocId == 0xfe) ? "Out of range" : (msg.ucAssocId == 0xfd) ? "Reserved" : std::to_string(msg.ucAssocId);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmParamAssocCfg" << std::endl;
        cout << "AssocType      : " << fnGetValue("AssocType") << " (" << fnGetRawValue("AssocType") << ")" << endl;
        cout << "AssocInst      : " << fnGetValue("AssocInst") << " (" << fnGetRawValue("AssocInst") << ")" << endl;
        cout << "AssocId      : " << fnGetValue("AssocId") << " (" << fnGetRawValue("AssocId") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "AssocType") {
            return static_cast<uint32_t>(msg.teAssocType);
        }
        else if (mnem == "AssocInst") {
            return static_cast<uint32_t>(msg.ucAssocInst);
        }
        else if (mnem == "AssocId") {
            return static_cast<uint32_t>(msg.ucAssocId);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "AssocType") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546649241], value);
     if (enumValue != -1) msg.teAssocType = static_cast<decltype(msg.teAssocType)>(enumValue);
     else msg.teAssocType = static_cast<decltype(msg.teAssocType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AssocInst") {
     msg.ucAssocInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "AssocId") {
     msg.ucAssocId = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "AssocType") {
            return 1.0 * (long double)(msg.teAssocType + 0.0);
        }
        else if (mnem == "AssocInst") {
            return 1.0 * (long double)(msg.ucAssocInst + 0.0);
        }
        else if (mnem == "AssocId") {
            return 1.0 * (long double)(msg.ucAssocId + 0.0);
        }
        return 0.0;
    }
} PmParamAssocCfg;

// Auto-generated class definition for RVC_tzPGN_PM_PARAM_AUX_CFG
typedef struct PmParamAuxCfg : public MessageBase {
RVC_tzPGN_PM_PARAM_AUX_CFG msg;
PmParamAuxCfg () {  memset(&msg, 0xFF, sizeof(msg));  };
PmParamAuxCfg (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PARAM_AUX_CFG *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "OutputId") {
            return std::to_string(msg.ucOutputId);
        }
        else if (mnem == "DesiredState") {
            if (ENUMLOOKUP[-1920850496].find(msg.teDesiredState) == ENUMLOOKUP[-1920850496].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDesiredState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-1920850496][msg.teDesiredState];
              }
        }
        else if (mnem == "ActiveLevel") {
            if (ENUMLOOKUP[2110464705].find(msg.teActiveLevel) == ENUMLOOKUP[2110464705].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teActiveLevel);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2110464705][msg.teActiveLevel];
              }
        }
        else if (mnem == "SetTrigger") {
            if (ENUMLOOKUP[1594238759].find(msg.teSetTrigger) == ENUMLOOKUP[1594238759].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teSetTrigger);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1594238759][msg.teSetTrigger];
              }
        }
        else if (mnem == "ClrTrigger") {
            if (ENUMLOOKUP[1594238759].find(msg.teClrTrigger) == ENUMLOOKUP[1594238759].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teClrTrigger);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1594238759][msg.teClrTrigger];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmParamAuxCfg" << std::endl;
        cout << "OutputId      : " << fnGetValue("OutputId") << " (" << fnGetRawValue("OutputId") << ")" << endl;
        cout << "DesiredState      : " << fnGetValue("DesiredState") << " (" << fnGetRawValue("DesiredState") << ")" << endl;
        cout << "ActiveLevel      : " << fnGetValue("ActiveLevel") << " (" << fnGetRawValue("ActiveLevel") << ")" << endl;
        cout << "SetTrigger      : " << fnGetValue("SetTrigger") << " (" << fnGetRawValue("SetTrigger") << ")" << endl;
        cout << "ClrTrigger      : " << fnGetValue("ClrTrigger") << " (" << fnGetRawValue("ClrTrigger") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "OutputId") {
            return static_cast<uint32_t>(msg.ucOutputId);
        }
        else if (mnem == "DesiredState") {
            return static_cast<uint32_t>(msg.teDesiredState);
        }
        else if (mnem == "ActiveLevel") {
            return static_cast<uint32_t>(msg.teActiveLevel);
        }
        else if (mnem == "SetTrigger") {
            return static_cast<uint32_t>(msg.teSetTrigger);
        }
        else if (mnem == "ClrTrigger") {
            return static_cast<uint32_t>(msg.teClrTrigger);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "OutputId") {
     msg.ucOutputId = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DesiredState") {
     int enumValue = findEnumValue(ENUMLOOKUP[-1920850496], value);
     if (enumValue != -1) msg.teDesiredState = static_cast<decltype(msg.teDesiredState)>(enumValue);
     else msg.teDesiredState = static_cast<decltype(msg.teDesiredState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ActiveLevel") {
     int enumValue = findEnumValue(ENUMLOOKUP[2110464705], value);
     if (enumValue != -1) msg.teActiveLevel = static_cast<decltype(msg.teActiveLevel)>(enumValue);
     else msg.teActiveLevel = static_cast<decltype(msg.teActiveLevel)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SetTrigger") {
     int enumValue = findEnumValue(ENUMLOOKUP[1594238759], value);
     if (enumValue != -1) msg.teSetTrigger = static_cast<decltype(msg.teSetTrigger)>(enumValue);
     else msg.teSetTrigger = static_cast<decltype(msg.teSetTrigger)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ClrTrigger") {
     int enumValue = findEnumValue(ENUMLOOKUP[1594238759], value);
     if (enumValue != -1) msg.teClrTrigger = static_cast<decltype(msg.teClrTrigger)>(enumValue);
     else msg.teClrTrigger = static_cast<decltype(msg.teClrTrigger)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "OutputId") {
            return 1.0 * (long double)(msg.ucOutputId + 0.0);
        }
        else if (mnem == "DesiredState") {
            return 1.0 * (long double)(msg.teDesiredState + 0.0);
        }
        else if (mnem == "ActiveLevel") {
            return 1.0 * (long double)(msg.teActiveLevel + 0.0);
        }
        else if (mnem == "SetTrigger") {
            return 1.0 * (long double)(msg.teSetTrigger + 0.0);
        }
        else if (mnem == "ClrTrigger") {
            return 1.0 * (long double)(msg.teClrTrigger + 0.0);
        }
        return 0.0;
    }
} PmParamAuxCfg;

// Auto-generated class definition for RVC_tzPGN_PM_PARAM_AUX_CFG_TRIG_LVL
typedef struct PmParamAuxCfgTrigLvl : public MessageBase {
RVC_tzPGN_PM_PARAM_AUX_CFG_TRIG_LVL msg;
PmParamAuxCfgTrigLvl () {  memset(&msg, 0xFF, sizeof(msg));  };
PmParamAuxCfgTrigLvl (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PARAM_AUX_CFG_TRIG_LVL *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "TriggerId") {
            if (ENUMLOOKUP[1594238759].find(msg.teTriggerId) == ENUMLOOKUP[1594238759].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teTriggerId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1594238759][msg.teTriggerId];
              }
        }
        else if (mnem == "TriggerLvl") {
            return (msg.siTriggerLvl == 0x7fff) ? "No Data" : (msg.siTriggerLvl == 0x7ffe) ? "Out of range" : (msg.siTriggerLvl == 0x7ffd) ? "Reserved" : std::to_string(msg.siTriggerLvl);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmParamAuxCfgTrigLvl" << std::endl;
        cout << "TriggerId      : " << fnGetValue("TriggerId") << " (" << fnGetRawValue("TriggerId") << ")" << endl;
        cout << "TriggerLvl      : " << fnGetValue("TriggerLvl") << " (" << fnGetRawValue("TriggerLvl") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "TriggerId") {
            return static_cast<uint32_t>(msg.teTriggerId);
        }
        else if (mnem == "TriggerLvl") {
            return static_cast<uint32_t>(msg.siTriggerLvl);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "TriggerId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1594238759], value);
     if (enumValue != -1) msg.teTriggerId = static_cast<decltype(msg.teTriggerId)>(enumValue);
     else msg.teTriggerId = static_cast<decltype(msg.teTriggerId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "TriggerLvl") {
     msg.siTriggerLvl = stringToInt(value, 0x7fff, 0x7ffe, 0x7ffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "TriggerId") {
            return 1.0 * (long double)(msg.teTriggerId + 0.0);
        }
        else if (mnem == "TriggerLvl") {
            return 1.0 * (long double)(msg.siTriggerLvl + 0.0);
        }
        return 0.0;
    }
} PmParamAuxCfgTrigLvl;

// Auto-generated class definition for RVC_tzPGN_PM_PARAM_AUX_CFG_TRIG_DLY
typedef struct PmParamAuxCfgTrigDly : public MessageBase {
RVC_tzPGN_PM_PARAM_AUX_CFG_TRIG_DLY msg;
PmParamAuxCfgTrigDly () {  memset(&msg, 0xFF, sizeof(msg));  };
PmParamAuxCfgTrigDly (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PARAM_AUX_CFG_TRIG_DLY *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "TriggerId") {
            if (ENUMLOOKUP[1594238759].find(msg.teTriggerId) == ENUMLOOKUP[1594238759].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teTriggerId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1594238759][msg.teTriggerId];
              }
        }
        else if (mnem == "TriggerDly") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiTriggerDly + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.uiTriggerDly == 0xffff) ? "No Data" : (msg.uiTriggerDly == 0xfffe) ? "Out of range" : (msg.uiTriggerDly == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmParamAuxCfgTrigDly" << std::endl;
        cout << "TriggerId      : " << fnGetValue("TriggerId") << " (" << fnGetRawValue("TriggerId") << ")" << endl;
        cout << "TriggerDly      : " << fnGetValue("TriggerDly") << " (" << fnGetRawValue("TriggerDly") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "TriggerId") {
            return static_cast<uint32_t>(msg.teTriggerId);
        }
        else if (mnem == "TriggerDly") {
            return static_cast<uint32_t>(msg.uiTriggerDly);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "TriggerId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1594238759], value);
     if (enumValue != -1) msg.teTriggerId = static_cast<decltype(msg.teTriggerId)>(enumValue);
     else msg.teTriggerId = static_cast<decltype(msg.teTriggerId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "TriggerDly") {
     msg.uiTriggerDly = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "TriggerId") {
            return 1.0 * (long double)(msg.teTriggerId + 0.0);
        }
        else if (mnem == "TriggerDly") {
            return 1.0 * (long double)(msg.uiTriggerDly + 0.0);
        }
        return 0.0;
    }
} PmParamAuxCfgTrigDly;

// Auto-generated class definition for RVC_tzPGN_PM_PARAM_AUX_STS
typedef struct PmParamAuxSts : public MessageBase {
RVC_tzPGN_PM_PARAM_AUX_STS msg;
PmParamAuxSts () {  memset(&msg, 0xFF, sizeof(msg));  };
PmParamAuxSts (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PARAM_AUX_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "OutputId") {
            return std::to_string(msg.ucOutputId);
        }
        else if (mnem == "OpState") {
            if (ENUMLOOKUP[1594080027].find(msg.teOpState) == ENUMLOOKUP[1594080027].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOpState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1594080027][msg.teOpState];
              }
        }
        else if (mnem == "OnReason") {
            if (ENUMLOOKUP[-961307955].find(msg.teOnReason) == ENUMLOOKUP[-961307955].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOnReason);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-961307955][msg.teOnReason];
              }
        }
        else if (mnem == "OffReason") {
            if (ENUMLOOKUP[-961307955].find(msg.teOffReason) == ENUMLOOKUP[-961307955].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOffReason);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-961307955][msg.teOffReason];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmParamAuxSts" << std::endl;
        cout << "OutputId      : " << fnGetValue("OutputId") << " (" << fnGetRawValue("OutputId") << ")" << endl;
        cout << "OpState      : " << fnGetValue("OpState") << " (" << fnGetRawValue("OpState") << ")" << endl;
        cout << "OnReason      : " << fnGetValue("OnReason") << " (" << fnGetRawValue("OnReason") << ")" << endl;
        cout << "OffReason      : " << fnGetValue("OffReason") << " (" << fnGetRawValue("OffReason") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "OutputId") {
            return static_cast<uint32_t>(msg.ucOutputId);
        }
        else if (mnem == "OpState") {
            return static_cast<uint32_t>(msg.teOpState);
        }
        else if (mnem == "OnReason") {
            return static_cast<uint32_t>(msg.teOnReason);
        }
        else if (mnem == "OffReason") {
            return static_cast<uint32_t>(msg.teOffReason);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "OutputId") {
     msg.ucOutputId = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "OpState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1594080027], value);
     if (enumValue != -1) msg.teOpState = static_cast<decltype(msg.teOpState)>(enumValue);
     else msg.teOpState = static_cast<decltype(msg.teOpState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OnReason") {
     int enumValue = findEnumValue(ENUMLOOKUP[-961307955], value);
     if (enumValue != -1) msg.teOnReason = static_cast<decltype(msg.teOnReason)>(enumValue);
     else msg.teOnReason = static_cast<decltype(msg.teOnReason)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OffReason") {
     int enumValue = findEnumValue(ENUMLOOKUP[-961307955], value);
     if (enumValue != -1) msg.teOffReason = static_cast<decltype(msg.teOffReason)>(enumValue);
     else msg.teOffReason = static_cast<decltype(msg.teOffReason)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "OutputId") {
            return 1.0 * (long double)(msg.ucOutputId + 0.0);
        }
        else if (mnem == "OpState") {
            return 1.0 * (long double)(msg.teOpState + 0.0);
        }
        else if (mnem == "OnReason") {
            return 1.0 * (long double)(msg.teOnReason + 0.0);
        }
        else if (mnem == "OffReason") {
            return 1.0 * (long double)(msg.teOffReason + 0.0);
        }
        return 0.0;
    }
} PmParamAuxSts;

// Auto-generated class definition for RVC_tzPGN_ISO_REQ
typedef struct IsoReq : public MessageBase {
RVC_tzPGN_ISO_REQ msg;
IsoReq () {  memset(&msg, 0xFF, sizeof(msg));  };
IsoReq (void * pvStruct) {  msg = *(RVC_tzPGN_ISO_REQ *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "ParmGrpNum") {
            return std::to_string(msg.ulParmGrpNum);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: IsoReq" << std::endl;
        cout << "ParmGrpNum      : " << fnGetValue("ParmGrpNum") << " (" << fnGetRawValue("ParmGrpNum") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "ParmGrpNum") {
            return static_cast<uint32_t>(msg.ulParmGrpNum);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "ParmGrpNum") {
     msg.ulParmGrpNum = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "ParmGrpNum") {
            return 1.0 * (long double)(msg.ulParmGrpNum + 0.0);
        }
        return 0.0;
    }
} IsoReq;

// Auto-generated class definition for RVC_tzPGN_ISO_TP_XFER
typedef struct IsoTpXfer : public MessageBase {
RVC_tzPGN_ISO_TP_XFER msg;
IsoTpXfer () {  memset(&msg, 0xFF, sizeof(msg));  };
IsoTpXfer (void * pvStruct) {  msg = *(RVC_tzPGN_ISO_TP_XFER *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "SeqNumMultiPacketFrame") {
            return (msg.ucSeqNumMultiPacketFrame == 0xff) ? "No Data" : (msg.ucSeqNumMultiPacketFrame == 0xfe) ? "Out of range" : (msg.ucSeqNumMultiPacketFrame == 0xfd) ? "Reserved" : std::to_string(msg.ucSeqNumMultiPacketFrame);
        }
        else if (mnem == "MultiPacketPacketizedData") {
            return reinterpret_cast< char const* >(msg.aucMultiPacketPacketizedData);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: IsoTpXfer" << std::endl;
        cout << "SeqNumMultiPacketFrame      : " << fnGetValue("SeqNumMultiPacketFrame") << " (" << fnGetRawValue("SeqNumMultiPacketFrame") << ")" << endl;
        cout << "MultiPacketPacketizedData      : " << fnGetValue("MultiPacketPacketizedData") << " (" << fnGetRawValue("MultiPacketPacketizedData") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "SeqNumMultiPacketFrame") {
            return static_cast<uint32_t>(msg.ucSeqNumMultiPacketFrame);
        }
        else if (mnem == "MultiPacketPacketizedData") {
            return UINT32_MAX;
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "SeqNumMultiPacketFrame") {
     msg.ucSeqNumMultiPacketFrame = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "MultiPacketPacketizedData") {
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "SeqNumMultiPacketFrame") {
            return 1.0 * (long double)(msg.ucSeqNumMultiPacketFrame + 0.0);
        }
        else if (mnem == "MultiPacketPacketizedData") {
            return 0.0;
        }
        return 0.0;
    }
} IsoTpXfer;

// Auto-generated class definition for RVC_tzPGN_ISO_TP_CONN_MAN_RTS
typedef struct IsoTpConnManRts : public MessageBase {
RVC_tzPGN_ISO_TP_CONN_MAN_RTS msg;
IsoTpConnManRts () {  memset(&msg, 0xFF, sizeof(msg));  };
IsoTpConnManRts (void * pvStruct) {  msg = *(RVC_tzPGN_ISO_TP_CONN_MAN_RTS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "RtsGroupFunctionCode") {
            return (msg.ucRtsGroupFunctionCode == 0xff) ? "No Data" : (msg.ucRtsGroupFunctionCode == 0xfe) ? "Out of range" : (msg.ucRtsGroupFunctionCode == 0xfd) ? "Reserved" : std::to_string(msg.ucRtsGroupFunctionCode);
        }
        else if (mnem == "TotalMsgSz") {
            return (msg.uiTotalMsgSz == 0xffff) ? "No Data" : (msg.uiTotalMsgSz == 0xfffe) ? "Out of range" : (msg.uiTotalMsgSz == 0xfffd) ? "Reserved" : std::to_string(msg.uiTotalMsgSz);
        }
        else if (mnem == "TotalNumFramesXmit") {
            return (msg.ucTotalNumFramesXmit == 0xff) ? "No Data" : (msg.ucTotalNumFramesXmit == 0xfe) ? "Out of range" : (msg.ucTotalNumFramesXmit == 0xfd) ? "Reserved" : std::to_string(msg.ucTotalNumFramesXmit);
        }
        else if (mnem == "ParmGrpNum") {
            return std::to_string(msg.ulParmGrpNum);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: IsoTpConnManRts" << std::endl;
        cout << "RtsGroupFunctionCode      : " << fnGetValue("RtsGroupFunctionCode") << " (" << fnGetRawValue("RtsGroupFunctionCode") << ")" << endl;
        cout << "TotalMsgSz      : " << fnGetValue("TotalMsgSz") << " (" << fnGetRawValue("TotalMsgSz") << ")" << endl;
        cout << "TotalNumFramesXmit      : " << fnGetValue("TotalNumFramesXmit") << " (" << fnGetRawValue("TotalNumFramesXmit") << ")" << endl;
        cout << "ParmGrpNum      : " << fnGetValue("ParmGrpNum") << " (" << fnGetRawValue("ParmGrpNum") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "RtsGroupFunctionCode") {
            return static_cast<uint32_t>(msg.ucRtsGroupFunctionCode);
        }
        else if (mnem == "TotalMsgSz") {
            return static_cast<uint32_t>(msg.uiTotalMsgSz);
        }
        else if (mnem == "TotalNumFramesXmit") {
            return static_cast<uint32_t>(msg.ucTotalNumFramesXmit);
        }
        else if (mnem == "ParmGrpNum") {
            return static_cast<uint32_t>(msg.ulParmGrpNum);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "RtsGroupFunctionCode") {
     msg.ucRtsGroupFunctionCode = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "TotalMsgSz") {
     msg.uiTotalMsgSz = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "TotalNumFramesXmit") {
     msg.ucTotalNumFramesXmit = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "ParmGrpNum") {
     msg.ulParmGrpNum = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "RtsGroupFunctionCode") {
            return 1.0 * (long double)(msg.ucRtsGroupFunctionCode + 0.0);
        }
        else if (mnem == "TotalMsgSz") {
            return 1.0 * (long double)(msg.uiTotalMsgSz + 0.0);
        }
        else if (mnem == "TotalNumFramesXmit") {
            return 1.0 * (long double)(msg.ucTotalNumFramesXmit + 0.0);
        }
        else if (mnem == "ParmGrpNum") {
            return 1.0 * (long double)(msg.ulParmGrpNum + 0.0);
        }
        return 0.0;
    }
} IsoTpConnManRts;

// Auto-generated class definition for RVC_tzPGN_ISO_TP_CONN_MAN_CTS
typedef struct IsoTpConnManCts : public MessageBase {
RVC_tzPGN_ISO_TP_CONN_MAN_CTS msg;
IsoTpConnManCts () {  memset(&msg, 0xFF, sizeof(msg));  };
IsoTpConnManCts (void * pvStruct) {  msg = *(RVC_tzPGN_ISO_TP_CONN_MAN_CTS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "CtsGroupFunctionCode") {
            return (msg.ucCtsGroupFunctionCode == 0xff) ? "No Data" : (msg.ucCtsGroupFunctionCode == 0xfe) ? "Out of range" : (msg.ucCtsGroupFunctionCode == 0xfd) ? "Reserved" : std::to_string(msg.ucCtsGroupFunctionCode);
        }
        else if (mnem == "NumFramesThatCanBeSent") {
            return (msg.ucNumFramesThatCanBeSent == 0xff) ? "No Data" : (msg.ucNumFramesThatCanBeSent == 0xfe) ? "Out of range" : (msg.ucNumFramesThatCanBeSent == 0xfd) ? "Reserved" : std::to_string(msg.ucNumFramesThatCanBeSent);
        }
        else if (mnem == "NumNextFrameToBeSent") {
            return (msg.ucNumNextFrameToBeSent == 0xff) ? "No Data" : (msg.ucNumNextFrameToBeSent == 0xfe) ? "Out of range" : (msg.ucNumNextFrameToBeSent == 0xfd) ? "Reserved" : std::to_string(msg.ucNumNextFrameToBeSent);
        }
        else if (mnem == "ParmGrpNum") {
            return std::to_string(msg.ulParmGrpNum);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: IsoTpConnManCts" << std::endl;
        cout << "CtsGroupFunctionCode      : " << fnGetValue("CtsGroupFunctionCode") << " (" << fnGetRawValue("CtsGroupFunctionCode") << ")" << endl;
        cout << "NumFramesThatCanBeSent      : " << fnGetValue("NumFramesThatCanBeSent") << " (" << fnGetRawValue("NumFramesThatCanBeSent") << ")" << endl;
        cout << "NumNextFrameToBeSent      : " << fnGetValue("NumNextFrameToBeSent") << " (" << fnGetRawValue("NumNextFrameToBeSent") << ")" << endl;
        cout << "ParmGrpNum      : " << fnGetValue("ParmGrpNum") << " (" << fnGetRawValue("ParmGrpNum") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "CtsGroupFunctionCode") {
            return static_cast<uint32_t>(msg.ucCtsGroupFunctionCode);
        }
        else if (mnem == "NumFramesThatCanBeSent") {
            return static_cast<uint32_t>(msg.ucNumFramesThatCanBeSent);
        }
        else if (mnem == "NumNextFrameToBeSent") {
            return static_cast<uint32_t>(msg.ucNumNextFrameToBeSent);
        }
        else if (mnem == "ParmGrpNum") {
            return static_cast<uint32_t>(msg.ulParmGrpNum);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "CtsGroupFunctionCode") {
     msg.ucCtsGroupFunctionCode = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "NumFramesThatCanBeSent") {
     msg.ucNumFramesThatCanBeSent = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "NumNextFrameToBeSent") {
     msg.ucNumNextFrameToBeSent = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "ParmGrpNum") {
     msg.ulParmGrpNum = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "CtsGroupFunctionCode") {
            return 1.0 * (long double)(msg.ucCtsGroupFunctionCode + 0.0);
        }
        else if (mnem == "NumFramesThatCanBeSent") {
            return 1.0 * (long double)(msg.ucNumFramesThatCanBeSent + 0.0);
        }
        else if (mnem == "NumNextFrameToBeSent") {
            return 1.0 * (long double)(msg.ucNumNextFrameToBeSent + 0.0);
        }
        else if (mnem == "ParmGrpNum") {
            return 1.0 * (long double)(msg.ulParmGrpNum + 0.0);
        }
        return 0.0;
    }
} IsoTpConnManCts;

// Auto-generated class definition for RVC_tzPGN_ISO_TP_CONN_MAN_EOM
typedef struct IsoTpConnManEom : public MessageBase {
RVC_tzPGN_ISO_TP_CONN_MAN_EOM msg;
IsoTpConnManEom () {  memset(&msg, 0xFF, sizeof(msg));  };
IsoTpConnManEom (void * pvStruct) {  msg = *(RVC_tzPGN_ISO_TP_CONN_MAN_EOM *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "EomGroupFunctionCode") {
            return (msg.ucEomGroupFunctionCode == 0xff) ? "No Data" : (msg.ucEomGroupFunctionCode == 0xfe) ? "Out of range" : (msg.ucEomGroupFunctionCode == 0xfd) ? "Reserved" : std::to_string(msg.ucEomGroupFunctionCode);
        }
        else if (mnem == "TotalMsgSz") {
            return (msg.uiTotalMsgSz == 0xffff) ? "No Data" : (msg.uiTotalMsgSz == 0xfffe) ? "Out of range" : (msg.uiTotalMsgSz == 0xfffd) ? "Reserved" : std::to_string(msg.uiTotalMsgSz);
        }
        else if (mnem == "TotalNumFramesRxed") {
            return (msg.ucTotalNumFramesRxed == 0xff) ? "No Data" : (msg.ucTotalNumFramesRxed == 0xfe) ? "Out of range" : (msg.ucTotalNumFramesRxed == 0xfd) ? "Reserved" : std::to_string(msg.ucTotalNumFramesRxed);
        }
        else if (mnem == "ParmGrpNum") {
            return std::to_string(msg.ulParmGrpNum);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: IsoTpConnManEom" << std::endl;
        cout << "EomGroupFunctionCode      : " << fnGetValue("EomGroupFunctionCode") << " (" << fnGetRawValue("EomGroupFunctionCode") << ")" << endl;
        cout << "TotalMsgSz      : " << fnGetValue("TotalMsgSz") << " (" << fnGetRawValue("TotalMsgSz") << ")" << endl;
        cout << "TotalNumFramesRxed      : " << fnGetValue("TotalNumFramesRxed") << " (" << fnGetRawValue("TotalNumFramesRxed") << ")" << endl;
        cout << "ParmGrpNum      : " << fnGetValue("ParmGrpNum") << " (" << fnGetRawValue("ParmGrpNum") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "EomGroupFunctionCode") {
            return static_cast<uint32_t>(msg.ucEomGroupFunctionCode);
        }
        else if (mnem == "TotalMsgSz") {
            return static_cast<uint32_t>(msg.uiTotalMsgSz);
        }
        else if (mnem == "TotalNumFramesRxed") {
            return static_cast<uint32_t>(msg.ucTotalNumFramesRxed);
        }
        else if (mnem == "ParmGrpNum") {
            return static_cast<uint32_t>(msg.ulParmGrpNum);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "EomGroupFunctionCode") {
     msg.ucEomGroupFunctionCode = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "TotalMsgSz") {
     msg.uiTotalMsgSz = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "TotalNumFramesRxed") {
     msg.ucTotalNumFramesRxed = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "ParmGrpNum") {
     msg.ulParmGrpNum = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "EomGroupFunctionCode") {
            return 1.0 * (long double)(msg.ucEomGroupFunctionCode + 0.0);
        }
        else if (mnem == "TotalMsgSz") {
            return 1.0 * (long double)(msg.uiTotalMsgSz + 0.0);
        }
        else if (mnem == "TotalNumFramesRxed") {
            return 1.0 * (long double)(msg.ucTotalNumFramesRxed + 0.0);
        }
        else if (mnem == "ParmGrpNum") {
            return 1.0 * (long double)(msg.ulParmGrpNum + 0.0);
        }
        return 0.0;
    }
} IsoTpConnManEom;

// Auto-generated class definition for RVC_tzPGN_ISO_TP_CONN_MAN_BAM
typedef struct IsoTpConnManBam : public MessageBase {
RVC_tzPGN_ISO_TP_CONN_MAN_BAM msg;
IsoTpConnManBam () {  memset(&msg, 0xFF, sizeof(msg));  };
IsoTpConnManBam (void * pvStruct) {  msg = *(RVC_tzPGN_ISO_TP_CONN_MAN_BAM *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "BamGroupFunctionCode") {
            return (msg.ucBamGroupFunctionCode == 0xff) ? "No Data" : (msg.ucBamGroupFunctionCode == 0xfe) ? "Out of range" : (msg.ucBamGroupFunctionCode == 0xfd) ? "Reserved" : std::to_string(msg.ucBamGroupFunctionCode);
        }
        else if (mnem == "TotalMsgSz") {
            return (msg.uiTotalMsgSz == 0xffff) ? "No Data" : (msg.uiTotalMsgSz == 0xfffe) ? "Out of range" : (msg.uiTotalMsgSz == 0xfffd) ? "Reserved" : std::to_string(msg.uiTotalMsgSz);
        }
        else if (mnem == "TotalNumFramesToBeSent") {
            return (msg.ucTotalNumFramesToBeSent == 0xff) ? "No Data" : (msg.ucTotalNumFramesToBeSent == 0xfe) ? "Out of range" : (msg.ucTotalNumFramesToBeSent == 0xfd) ? "Reserved" : std::to_string(msg.ucTotalNumFramesToBeSent);
        }
        else if (mnem == "ParmGrpNum") {
            return std::to_string(msg.ulParmGrpNum);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: IsoTpConnManBam" << std::endl;
        cout << "BamGroupFunctionCode      : " << fnGetValue("BamGroupFunctionCode") << " (" << fnGetRawValue("BamGroupFunctionCode") << ")" << endl;
        cout << "TotalMsgSz      : " << fnGetValue("TotalMsgSz") << " (" << fnGetRawValue("TotalMsgSz") << ")" << endl;
        cout << "TotalNumFramesToBeSent      : " << fnGetValue("TotalNumFramesToBeSent") << " (" << fnGetRawValue("TotalNumFramesToBeSent") << ")" << endl;
        cout << "ParmGrpNum      : " << fnGetValue("ParmGrpNum") << " (" << fnGetRawValue("ParmGrpNum") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "BamGroupFunctionCode") {
            return static_cast<uint32_t>(msg.ucBamGroupFunctionCode);
        }
        else if (mnem == "TotalMsgSz") {
            return static_cast<uint32_t>(msg.uiTotalMsgSz);
        }
        else if (mnem == "TotalNumFramesToBeSent") {
            return static_cast<uint32_t>(msg.ucTotalNumFramesToBeSent);
        }
        else if (mnem == "ParmGrpNum") {
            return static_cast<uint32_t>(msg.ulParmGrpNum);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "BamGroupFunctionCode") {
     msg.ucBamGroupFunctionCode = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "TotalMsgSz") {
     msg.uiTotalMsgSz = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "TotalNumFramesToBeSent") {
     msg.ucTotalNumFramesToBeSent = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "ParmGrpNum") {
     msg.ulParmGrpNum = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "BamGroupFunctionCode") {
            return 1.0 * (long double)(msg.ucBamGroupFunctionCode + 0.0);
        }
        else if (mnem == "TotalMsgSz") {
            return 1.0 * (long double)(msg.uiTotalMsgSz + 0.0);
        }
        else if (mnem == "TotalNumFramesToBeSent") {
            return 1.0 * (long double)(msg.ucTotalNumFramesToBeSent + 0.0);
        }
        else if (mnem == "ParmGrpNum") {
            return 1.0 * (long double)(msg.ulParmGrpNum + 0.0);
        }
        return 0.0;
    }
} IsoTpConnManBam;

// Auto-generated class definition for RVC_tzPGN_ISO_TP_CONN_MAN_ABORT
typedef struct IsoTpConnManAbort : public MessageBase {
RVC_tzPGN_ISO_TP_CONN_MAN_ABORT msg;
IsoTpConnManAbort () {  memset(&msg, 0xFF, sizeof(msg));  };
IsoTpConnManAbort (void * pvStruct) {  msg = *(RVC_tzPGN_ISO_TP_CONN_MAN_ABORT *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "AbortGroupFunctionCode") {
            return (msg.ucAbortGroupFunctionCode == 0xff) ? "No Data" : (msg.ucAbortGroupFunctionCode == 0xfe) ? "Out of range" : (msg.ucAbortGroupFunctionCode == 0xfd) ? "Reserved" : std::to_string(msg.ucAbortGroupFunctionCode);
        }
        else if (mnem == "ParmGrpNum") {
            return std::to_string(msg.ulParmGrpNum);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: IsoTpConnManAbort" << std::endl;
        cout << "AbortGroupFunctionCode      : " << fnGetValue("AbortGroupFunctionCode") << " (" << fnGetRawValue("AbortGroupFunctionCode") << ")" << endl;
        cout << "ParmGrpNum      : " << fnGetValue("ParmGrpNum") << " (" << fnGetRawValue("ParmGrpNum") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "AbortGroupFunctionCode") {
            return static_cast<uint32_t>(msg.ucAbortGroupFunctionCode);
        }
        else if (mnem == "ParmGrpNum") {
            return static_cast<uint32_t>(msg.ulParmGrpNum);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "AbortGroupFunctionCode") {
     msg.ucAbortGroupFunctionCode = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "ParmGrpNum") {
     msg.ulParmGrpNum = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "AbortGroupFunctionCode") {
            return 1.0 * (long double)(msg.ucAbortGroupFunctionCode + 0.0);
        }
        else if (mnem == "ParmGrpNum") {
            return 1.0 * (long double)(msg.ulParmGrpNum + 0.0);
        }
        return 0.0;
    }
} IsoTpConnManAbort;

// Auto-generated class definition for RVC_tzPGN_ISO_ADDR_CLAIM
typedef struct IsoAddrClaim : public MessageBase {
RVC_tzPGN_ISO_ADDR_CLAIM msg;
IsoAddrClaim () {  memset(&msg, 0xFF, sizeof(msg));  };
IsoAddrClaim (void * pvStruct) {  msg = *(RVC_tzPGN_ISO_ADDR_CLAIM *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "UniqueNumber") {
            return std::to_string(msg.ulUniqueNumber);
        }
        else if (mnem == "ManufacturerCode") {
            return std::to_string(msg.uiManufacturerCode);
        }
        else if (mnem == "DeviceInstanceLower") {
            return std::to_string(msg.ucDeviceInstanceLower);
        }
        else if (mnem == "DeviceInstanceUpper") {
            return std::to_string(msg.ucDeviceInstanceUpper);
        }
        else if (mnem == "DeviceFunction") {
            if (ENUMLOOKUP[9001].find(msg.teDeviceFunction) == ENUMLOOKUP[9001].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDeviceFunction);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9001][msg.teDeviceFunction];
              }
        }
        else if (mnem == "RsvBit") {
            return std::to_string(msg.ucRsvBit);
        }
        else if (mnem == "DeviceClass") {
            if (ENUMLOOKUP[9002].find(msg.teDeviceClass) == ENUMLOOKUP[9002].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDeviceClass);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9002][msg.teDeviceClass];
              }
        }
        else if (mnem == "SystemInstance") {
            return std::to_string(msg.ucSystemInstance);
        }
        else if (mnem == "IndustryGroup") {
            if (ENUMLOOKUP[8989].find(msg.teIndustryGroup) == ENUMLOOKUP[8989].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teIndustryGroup);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[8989][msg.teIndustryGroup];
              }
        }
        else if (mnem == "SelfCfgAddr") {
            return std::to_string(msg.ucSelfCfgAddr);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: IsoAddrClaim" << std::endl;
        cout << "UniqueNumber      : " << fnGetValue("UniqueNumber") << " (" << fnGetRawValue("UniqueNumber") << ")" << endl;
        cout << "ManufacturerCode      : " << fnGetValue("ManufacturerCode") << " (" << fnGetRawValue("ManufacturerCode") << ")" << endl;
        cout << "DeviceInstanceLower      : " << fnGetValue("DeviceInstanceLower") << " (" << fnGetRawValue("DeviceInstanceLower") << ")" << endl;
        cout << "DeviceInstanceUpper      : " << fnGetValue("DeviceInstanceUpper") << " (" << fnGetRawValue("DeviceInstanceUpper") << ")" << endl;
        cout << "DeviceFunction      : " << fnGetValue("DeviceFunction") << " (" << fnGetRawValue("DeviceFunction") << ")" << endl;
        cout << "RsvBit      : " << fnGetValue("RsvBit") << " (" << fnGetRawValue("RsvBit") << ")" << endl;
        cout << "DeviceClass      : " << fnGetValue("DeviceClass") << " (" << fnGetRawValue("DeviceClass") << ")" << endl;
        cout << "SystemInstance      : " << fnGetValue("SystemInstance") << " (" << fnGetRawValue("SystemInstance") << ")" << endl;
        cout << "IndustryGroup      : " << fnGetValue("IndustryGroup") << " (" << fnGetRawValue("IndustryGroup") << ")" << endl;
        cout << "SelfCfgAddr      : " << fnGetValue("SelfCfgAddr") << " (" << fnGetRawValue("SelfCfgAddr") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "UniqueNumber") {
            return static_cast<uint32_t>(msg.ulUniqueNumber);
        }
        else if (mnem == "ManufacturerCode") {
            return static_cast<uint32_t>(msg.uiManufacturerCode);
        }
        else if (mnem == "DeviceInstanceLower") {
            return static_cast<uint32_t>(msg.ucDeviceInstanceLower);
        }
        else if (mnem == "DeviceInstanceUpper") {
            return static_cast<uint32_t>(msg.ucDeviceInstanceUpper);
        }
        else if (mnem == "DeviceFunction") {
            return static_cast<uint32_t>(msg.teDeviceFunction);
        }
        else if (mnem == "RsvBit") {
            return static_cast<uint32_t>(msg.ucRsvBit);
        }
        else if (mnem == "DeviceClass") {
            return static_cast<uint32_t>(msg.teDeviceClass);
        }
        else if (mnem == "SystemInstance") {
            return static_cast<uint32_t>(msg.ucSystemInstance);
        }
        else if (mnem == "IndustryGroup") {
            return static_cast<uint32_t>(msg.teIndustryGroup);
        }
        else if (mnem == "SelfCfgAddr") {
            return static_cast<uint32_t>(msg.ucSelfCfgAddr);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "UniqueNumber") {
     msg.ulUniqueNumber = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ManufacturerCode") {
     msg.uiManufacturerCode = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DeviceInstanceLower") {
     msg.ucDeviceInstanceLower = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DeviceInstanceUpper") {
     msg.ucDeviceInstanceUpper = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DeviceFunction") {
     int enumValue = findEnumValue(ENUMLOOKUP[9001], value);
     if (enumValue != -1) msg.teDeviceFunction = static_cast<decltype(msg.teDeviceFunction)>(enumValue);
     else msg.teDeviceFunction = static_cast<decltype(msg.teDeviceFunction)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RsvBit") {
     msg.ucRsvBit = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DeviceClass") {
     int enumValue = findEnumValue(ENUMLOOKUP[9002], value);
     if (enumValue != -1) msg.teDeviceClass = static_cast<decltype(msg.teDeviceClass)>(enumValue);
     else msg.teDeviceClass = static_cast<decltype(msg.teDeviceClass)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SystemInstance") {
     msg.ucSystemInstance = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "IndustryGroup") {
     int enumValue = findEnumValue(ENUMLOOKUP[8989], value);
     if (enumValue != -1) msg.teIndustryGroup = static_cast<decltype(msg.teIndustryGroup)>(enumValue);
     else msg.teIndustryGroup = static_cast<decltype(msg.teIndustryGroup)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SelfCfgAddr") {
     msg.ucSelfCfgAddr = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "UniqueNumber") {
            return 1.0 * (long double)(msg.ulUniqueNumber + 0.0);
        }
        else if (mnem == "ManufacturerCode") {
            return 1.0 * (long double)(msg.uiManufacturerCode + 0.0);
        }
        else if (mnem == "DeviceInstanceLower") {
            return 1.0 * (long double)(msg.ucDeviceInstanceLower + 0.0);
        }
        else if (mnem == "DeviceInstanceUpper") {
            return 1.0 * (long double)(msg.ucDeviceInstanceUpper + 0.0);
        }
        else if (mnem == "DeviceFunction") {
            return 1.0 * (long double)(msg.teDeviceFunction + 0.0);
        }
        else if (mnem == "RsvBit") {
            return 1.0 * (long double)(msg.ucRsvBit + 0.0);
        }
        else if (mnem == "DeviceClass") {
            return 1.0 * (long double)(msg.teDeviceClass + 0.0);
        }
        else if (mnem == "SystemInstance") {
            return 1.0 * (long double)(msg.ucSystemInstance + 0.0);
        }
        else if (mnem == "IndustryGroup") {
            return 1.0 * (long double)(msg.teIndustryGroup + 0.0);
        }
        else if (mnem == "SelfCfgAddr") {
            return 1.0 * (long double)(msg.ucSelfCfgAddr + 0.0);
        }
        return 0.0;
    }
} IsoAddrClaim;

// Auto-generated class definition for RVC_tzPGN_PM_ASSOC_CFG
typedef struct PmAssocCfg : public MessageBase {
RVC_tzPGN_PM_ASSOC_CFG msg;
PmAssocCfg () {  memset(&msg, 0xFF, sizeof(msg));  };
PmAssocCfg (void * pvStruct) {  msg = *(RVC_tzPGN_PM_ASSOC_CFG *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "AssocType") {
            if (ENUMLOOKUP[1546649241].find(msg.teAssocType) == ENUMLOOKUP[1546649241].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAssocType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546649241][msg.teAssocType];
              }
        }
        else if (mnem == "AssocInst") {
            return std::to_string(msg.ucAssocInst);
        }
        else if (mnem == "AssocId") {
            return (msg.ucAssocId == 0xff) ? "No Data" : (msg.ucAssocId == 0xfe) ? "Out of range" : (msg.ucAssocId == 0xfd) ? "Reserved" : std::to_string(msg.ucAssocId);
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmAssocCfg" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "AssocType      : " << fnGetValue("AssocType") << " (" << fnGetRawValue("AssocType") << ")" << endl;
        cout << "AssocInst      : " << fnGetValue("AssocInst") << " (" << fnGetRawValue("AssocInst") << ")" << endl;
        cout << "AssocId      : " << fnGetValue("AssocId") << " (" << fnGetRawValue("AssocId") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "AssocType") {
            return static_cast<uint32_t>(msg.teAssocType);
        }
        else if (mnem == "AssocInst") {
            return static_cast<uint32_t>(msg.ucAssocInst);
        }
        else if (mnem == "AssocId") {
            return static_cast<uint32_t>(msg.ucAssocId);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AssocType") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546649241], value);
     if (enumValue != -1) msg.teAssocType = static_cast<decltype(msg.teAssocType)>(enumValue);
     else msg.teAssocType = static_cast<decltype(msg.teAssocType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AssocInst") {
     msg.ucAssocInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "AssocId") {
     msg.ucAssocId = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "AssocType") {
            return 1.0 * (long double)(msg.teAssocType + 0.0);
        }
        else if (mnem == "AssocInst") {
            return 1.0 * (long double)(msg.ucAssocInst + 0.0);
        }
        else if (mnem == "AssocId") {
            return 1.0 * (long double)(msg.ucAssocId + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmAssocCfg;

// Auto-generated class definition for RVC_tzPGN_PM_REQ
typedef struct PmReq : public MessageBase {
RVC_tzPGN_PM_REQ msg;
PmReq () {  memset(&msg, 0xFF, sizeof(msg));  };
PmReq (void * pvStruct) {  msg = *(RVC_tzPGN_PM_REQ *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "ReqId") {
            if (ENUMLOOKUP[1546979661].find(msg.teReqId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teReqId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teReqId];
              }
        }
        else if (mnem == "Param1") {
            return (msg.ucParam1 == 0xff) ? "No Data" : (msg.ucParam1 == 0xfe) ? "Out of range" : (msg.ucParam1 == 0xfd) ? "Reserved" : std::to_string(msg.ucParam1);
        }
        else if (mnem == "Param2") {
            return (msg.ucParam2 == 0xff) ? "No Data" : (msg.ucParam2 == 0xfe) ? "Out of range" : (msg.ucParam2 == 0xfd) ? "Reserved" : std::to_string(msg.ucParam2);
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmReq" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "ReqId      : " << fnGetValue("ReqId") << " (" << fnGetRawValue("ReqId") << ")" << endl;
        cout << "Param1      : " << fnGetValue("Param1") << " (" << fnGetRawValue("Param1") << ")" << endl;
        cout << "Param2      : " << fnGetValue("Param2") << " (" << fnGetRawValue("Param2") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "ReqId") {
            return static_cast<uint32_t>(msg.teReqId);
        }
        else if (mnem == "Param1") {
            return static_cast<uint32_t>(msg.ucParam1);
        }
        else if (mnem == "Param2") {
            return static_cast<uint32_t>(msg.ucParam2);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ReqId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teReqId = static_cast<decltype(msg.teReqId)>(enumValue);
     else msg.teReqId = static_cast<decltype(msg.teReqId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Param1") {
     msg.ucParam1 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Param2") {
     msg.ucParam2 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "ReqId") {
            return 1.0 * (long double)(msg.teReqId + 0.0);
        }
        else if (mnem == "Param1") {
            return 1.0 * (long double)(msg.ucParam1 + 0.0);
        }
        else if (mnem == "Param2") {
            return 1.0 * (long double)(msg.ucParam2 + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmReq;

// Auto-generated class definition for RVC_tzPGN_PM_ASSOC_STS
typedef struct PmAssocSts : public MessageBase {
RVC_tzPGN_PM_ASSOC_STS msg;
PmAssocSts () {  memset(&msg, 0xFF, sizeof(msg));  };
PmAssocSts (void * pvStruct) {  msg = *(RVC_tzPGN_PM_ASSOC_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "AssocType") {
            if (ENUMLOOKUP[1546649241].find(msg.teAssocType) == ENUMLOOKUP[1546649241].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAssocType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546649241][msg.teAssocType];
              }
        }
        else if (mnem == "AssocInst") {
            return std::to_string(msg.ucAssocInst);
        }
        else if (mnem == "AssocId") {
            return (msg.ucAssocId == 0xff) ? "No Data" : (msg.ucAssocId == 0xfe) ? "Out of range" : (msg.ucAssocId == 0xfd) ? "Reserved" : std::to_string(msg.ucAssocId);
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmAssocSts" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "AssocType      : " << fnGetValue("AssocType") << " (" << fnGetRawValue("AssocType") << ")" << endl;
        cout << "AssocInst      : " << fnGetValue("AssocInst") << " (" << fnGetRawValue("AssocInst") << ")" << endl;
        cout << "AssocId      : " << fnGetValue("AssocId") << " (" << fnGetRawValue("AssocId") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "AssocType") {
            return static_cast<uint32_t>(msg.teAssocType);
        }
        else if (mnem == "AssocInst") {
            return static_cast<uint32_t>(msg.ucAssocInst);
        }
        else if (mnem == "AssocId") {
            return static_cast<uint32_t>(msg.ucAssocId);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AssocType") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546649241], value);
     if (enumValue != -1) msg.teAssocType = static_cast<decltype(msg.teAssocType)>(enumValue);
     else msg.teAssocType = static_cast<decltype(msg.teAssocType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AssocInst") {
     msg.ucAssocInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "AssocId") {
     msg.ucAssocId = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "AssocType") {
            return 1.0 * (long double)(msg.teAssocType + 0.0);
        }
        else if (mnem == "AssocInst") {
            return 1.0 * (long double)(msg.ucAssocInst + 0.0);
        }
        else if (mnem == "AssocId") {
            return 1.0 * (long double)(msg.ucAssocId + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmAssocSts;

// Auto-generated class definition for RVC_tzPGN_PM_DEV_MD_CFG
typedef struct PmDevMdCfg : public MessageBase {
RVC_tzPGN_PM_DEV_MD_CFG msg;
PmDevMdCfg () {  memset(&msg, 0xFF, sizeof(msg));  };
PmDevMdCfg (void * pvStruct) {  msg = *(RVC_tzPGN_PM_DEV_MD_CFG *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "DesiredMode") {
            if (ENUMLOOKUP[-725723354].find(msg.teDesiredMode) == ENUMLOOKUP[-725723354].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDesiredMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-725723354][msg.teDesiredMode];
              }
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmDevMdCfg" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "DesiredMode      : " << fnGetValue("DesiredMode") << " (" << fnGetRawValue("DesiredMode") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "DesiredMode") {
            return static_cast<uint32_t>(msg.teDesiredMode);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DesiredMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[-725723354], value);
     if (enumValue != -1) msg.teDesiredMode = static_cast<decltype(msg.teDesiredMode)>(enumValue);
     else msg.teDesiredMode = static_cast<decltype(msg.teDesiredMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "DesiredMode") {
            return 1.0 * (long double)(msg.teDesiredMode + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmDevMdCfg;

// Auto-generated class definition for RVC_tzPGN_PM_FXCC_CFG_CMD
typedef struct PmFxccCfgCmd : public MessageBase {
RVC_tzPGN_PM_FXCC_CFG_CMD msg;
PmFxccCfgCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
PmFxccCfgCmd (void * pvStruct) {  msg = *(RVC_tzPGN_PM_FXCC_CFG_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "PwrSvHr") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucPwrSvHr + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "h");
            return (msg.ucPwrSvHr == 0xff) ? "No Data" : (msg.ucPwrSvHr == 0xfe) ? "Out of range" : (msg.ucPwrSvHr == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "InvIgnCtrl") {
            if (ENUMLOOKUP[1552924287].find(msg.teInvIgnCtrl) == ENUMLOOKUP[1552924287].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInvIgnCtrl);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1552924287][msg.teInvIgnCtrl];
              }
        }
        else if (mnem == "TransMode") {
            if (ENUMLOOKUP[9075].find(msg.teTransMode) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teTransMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teTransMode];
              }
        }
        else if (mnem == "AlarmEnDis") {
            if (ENUMLOOKUP[9075].find(msg.teAlarmEnDis) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAlarmEnDis);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teAlarmEnDis];
              }
        }
        else if (mnem == "OverFltRecEnDis") {
            if (ENUMLOOKUP[9075].find(msg.teOverFltRecEnDis) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOverFltRecEnDis);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teOverFltRecEnDis];
              }
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmFxccCfgCmd" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "PwrSvHr      : " << fnGetValue("PwrSvHr") << " (" << fnGetRawValue("PwrSvHr") << ")" << endl;
        cout << "InvIgnCtrl      : " << fnGetValue("InvIgnCtrl") << " (" << fnGetRawValue("InvIgnCtrl") << ")" << endl;
        cout << "TransMode      : " << fnGetValue("TransMode") << " (" << fnGetRawValue("TransMode") << ")" << endl;
        cout << "AlarmEnDis      : " << fnGetValue("AlarmEnDis") << " (" << fnGetRawValue("AlarmEnDis") << ")" << endl;
        cout << "OverFltRecEnDis      : " << fnGetValue("OverFltRecEnDis") << " (" << fnGetRawValue("OverFltRecEnDis") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "PwrSvHr") {
            return static_cast<uint32_t>(msg.ucPwrSvHr);
        }
        else if (mnem == "InvIgnCtrl") {
            return static_cast<uint32_t>(msg.teInvIgnCtrl);
        }
        else if (mnem == "TransMode") {
            return static_cast<uint32_t>(msg.teTransMode);
        }
        else if (mnem == "AlarmEnDis") {
            return static_cast<uint32_t>(msg.teAlarmEnDis);
        }
        else if (mnem == "OverFltRecEnDis") {
            return static_cast<uint32_t>(msg.teOverFltRecEnDis);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PwrSvHr") {
     msg.ucPwrSvHr = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "InvIgnCtrl") {
     int enumValue = findEnumValue(ENUMLOOKUP[1552924287], value);
     if (enumValue != -1) msg.teInvIgnCtrl = static_cast<decltype(msg.teInvIgnCtrl)>(enumValue);
     else msg.teInvIgnCtrl = static_cast<decltype(msg.teInvIgnCtrl)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "TransMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teTransMode = static_cast<decltype(msg.teTransMode)>(enumValue);
     else msg.teTransMode = static_cast<decltype(msg.teTransMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AlarmEnDis") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teAlarmEnDis = static_cast<decltype(msg.teAlarmEnDis)>(enumValue);
     else msg.teAlarmEnDis = static_cast<decltype(msg.teAlarmEnDis)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OverFltRecEnDis") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teOverFltRecEnDis = static_cast<decltype(msg.teOverFltRecEnDis)>(enumValue);
     else msg.teOverFltRecEnDis = static_cast<decltype(msg.teOverFltRecEnDis)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnInvFaultRecovery2Cmd") return fnInvFaultRecovery2Cmd(param_value);
        if (func == "fnPwrSaveTime2Cmd") return fnPwrSaveTime2Cmd(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "PwrSvHr") {
            return 1.0 * (long double)(msg.ucPwrSvHr + 0.0);
        }
        else if (mnem == "InvIgnCtrl") {
            return 1.0 * (long double)(msg.teInvIgnCtrl + 0.0);
        }
        else if (mnem == "TransMode") {
            return 1.0 * (long double)(msg.teTransMode + 0.0);
        }
        else if (mnem == "AlarmEnDis") {
            return 1.0 * (long double)(msg.teAlarmEnDis + 0.0);
        }
        else if (mnem == "OverFltRecEnDis") {
            return 1.0 * (long double)(msg.teOverFltRecEnDis + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmFxccCfgCmd;

// Auto-generated class definition for RVC_tzPGN_PM_DEV_MD_STS
typedef struct PmDevMdSts : public MessageBase {
RVC_tzPGN_PM_DEV_MD_STS msg;
PmDevMdSts () {  memset(&msg, 0xFF, sizeof(msg));  };
PmDevMdSts (void * pvStruct) {  msg = *(RVC_tzPGN_PM_DEV_MD_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "CurrentMode") {
            if (ENUMLOOKUP[-725723354].find(msg.teCurrentMode) == ENUMLOOKUP[-725723354].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCurrentMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-725723354][msg.teCurrentMode];
              }
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmDevMdSts" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "CurrentMode      : " << fnGetValue("CurrentMode") << " (" << fnGetRawValue("CurrentMode") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "CurrentMode") {
            return static_cast<uint32_t>(msg.teCurrentMode);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CurrentMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[-725723354], value);
     if (enumValue != -1) msg.teCurrentMode = static_cast<decltype(msg.teCurrentMode)>(enumValue);
     else msg.teCurrentMode = static_cast<decltype(msg.teCurrentMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "CurrentMode") {
            return 1.0 * (long double)(msg.teCurrentMode + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmDevMdSts;

// Auto-generated class definition for RVC_tzPGN_PM_FXCC_CFG_STS
typedef struct PmFxccCfgSts : public MessageBase {
RVC_tzPGN_PM_FXCC_CFG_STS msg;
PmFxccCfgSts () {  memset(&msg, 0xFF, sizeof(msg));  };
PmFxccCfgSts (void * pvStruct) {  msg = *(RVC_tzPGN_PM_FXCC_CFG_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "PwrSvHr") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucPwrSvHr + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "h");
            return (msg.ucPwrSvHr == 0xff) ? "No Data" : (msg.ucPwrSvHr == 0xfe) ? "Out of range" : (msg.ucPwrSvHr == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "InvIgnCtrl") {
            if (ENUMLOOKUP[1552924287].find(msg.teInvIgnCtrl) == ENUMLOOKUP[1552924287].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInvIgnCtrl);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1552924287][msg.teInvIgnCtrl];
              }
        }
        else if (mnem == "TransMode") {
            if (ENUMLOOKUP[9075].find(msg.teTransMode) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teTransMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teTransMode];
              }
        }
        else if (mnem == "AlarmEnDis") {
            if (ENUMLOOKUP[9075].find(msg.teAlarmEnDis) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAlarmEnDis);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teAlarmEnDis];
              }
        }
        else if (mnem == "OvrFltRecEnDis") {
            if (ENUMLOOKUP[9075].find(msg.teOvrFltRecEnDis) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOvrFltRecEnDis);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teOvrFltRecEnDis];
              }
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmFxccCfgSts" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "PwrSvHr      : " << fnGetValue("PwrSvHr") << " (" << fnGetRawValue("PwrSvHr") << ")" << endl;
        cout << "InvIgnCtrl      : " << fnGetValue("InvIgnCtrl") << " (" << fnGetRawValue("InvIgnCtrl") << ")" << endl;
        cout << "TransMode      : " << fnGetValue("TransMode") << " (" << fnGetRawValue("TransMode") << ")" << endl;
        cout << "AlarmEnDis      : " << fnGetValue("AlarmEnDis") << " (" << fnGetRawValue("AlarmEnDis") << ")" << endl;
        cout << "OvrFltRecEnDis      : " << fnGetValue("OvrFltRecEnDis") << " (" << fnGetRawValue("OvrFltRecEnDis") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "PwrSvHr") {
            return static_cast<uint32_t>(msg.ucPwrSvHr);
        }
        else if (mnem == "InvIgnCtrl") {
            return static_cast<uint32_t>(msg.teInvIgnCtrl);
        }
        else if (mnem == "TransMode") {
            return static_cast<uint32_t>(msg.teTransMode);
        }
        else if (mnem == "AlarmEnDis") {
            return static_cast<uint32_t>(msg.teAlarmEnDis);
        }
        else if (mnem == "OvrFltRecEnDis") {
            return static_cast<uint32_t>(msg.teOvrFltRecEnDis);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PwrSvHr") {
     msg.ucPwrSvHr = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "InvIgnCtrl") {
     int enumValue = findEnumValue(ENUMLOOKUP[1552924287], value);
     if (enumValue != -1) msg.teInvIgnCtrl = static_cast<decltype(msg.teInvIgnCtrl)>(enumValue);
     else msg.teInvIgnCtrl = static_cast<decltype(msg.teInvIgnCtrl)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "TransMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teTransMode = static_cast<decltype(msg.teTransMode)>(enumValue);
     else msg.teTransMode = static_cast<decltype(msg.teTransMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AlarmEnDis") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teAlarmEnDis = static_cast<decltype(msg.teAlarmEnDis)>(enumValue);
     else msg.teAlarmEnDis = static_cast<decltype(msg.teAlarmEnDis)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OvrFltRecEnDis") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teOvrFltRecEnDis = static_cast<decltype(msg.teOvrFltRecEnDis)>(enumValue);
     else msg.teOvrFltRecEnDis = static_cast<decltype(msg.teOvrFltRecEnDis)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnSts2InvFaultRecovery") return fnSts2InvFaultRecovery(param_value);
        if (func == "fnSts2PwrSaveTime") return fnSts2PwrSaveTime(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "PwrSvHr") {
            return 1.0 * (long double)(msg.ucPwrSvHr + 0.0);
        }
        else if (mnem == "InvIgnCtrl") {
            return 1.0 * (long double)(msg.teInvIgnCtrl + 0.0);
        }
        else if (mnem == "TransMode") {
            return 1.0 * (long double)(msg.teTransMode + 0.0);
        }
        else if (mnem == "AlarmEnDis") {
            return 1.0 * (long double)(msg.teAlarmEnDis + 0.0);
        }
        else if (mnem == "OvrFltRecEnDis") {
            return 1.0 * (long double)(msg.teOvrFltRecEnDis + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmFxccCfgSts;

// Auto-generated class definition for RVC_tzPGN_PM_SW_VER_STS
typedef struct PmSwVerSts : public MessageBase {
RVC_tzPGN_PM_SW_VER_STS msg;
PmSwVerSts () {  memset(&msg, 0xFF, sizeof(msg));  };
PmSwVerSts (void * pvStruct) {  msg = *(RVC_tzPGN_PM_SW_VER_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "ProcInst") {
            return std::to_string(msg.ucProcInst);
        }
        else if (mnem == "SwModIdent") {
            if (ENUMLOOKUP[-1372759813].find(msg.teSwModIdent) == ENUMLOOKUP[-1372759813].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teSwModIdent);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-1372759813][msg.teSwModIdent];
              }
        }
        else if (mnem == "SwVerMsb") {
            return std::to_string(msg.ucSwVerMsb);
        }
        else if (mnem == "SwVerIsb") {
            return std::to_string(msg.ucSwVerIsb);
        }
        else if (mnem == "SwVerLsb") {
            return std::to_string(msg.ucSwVerLsb);
        }
        else if (mnem == "SwBldNumMsb") {
            return std::to_string(msg.ucSwBldNumMsb);
        }
        else if (mnem == "SwBldNumLsb") {
            return std::to_string(msg.ucSwBldNumLsb);
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmSwVerSts" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "ProcInst      : " << fnGetValue("ProcInst") << " (" << fnGetRawValue("ProcInst") << ")" << endl;
        cout << "SwModIdent      : " << fnGetValue("SwModIdent") << " (" << fnGetRawValue("SwModIdent") << ")" << endl;
        cout << "SwVerMsb      : " << fnGetValue("SwVerMsb") << " (" << fnGetRawValue("SwVerMsb") << ")" << endl;
        cout << "SwVerIsb      : " << fnGetValue("SwVerIsb") << " (" << fnGetRawValue("SwVerIsb") << ")" << endl;
        cout << "SwVerLsb      : " << fnGetValue("SwVerLsb") << " (" << fnGetRawValue("SwVerLsb") << ")" << endl;
        cout << "SwBldNumMsb      : " << fnGetValue("SwBldNumMsb") << " (" << fnGetRawValue("SwBldNumMsb") << ")" << endl;
        cout << "SwBldNumLsb      : " << fnGetValue("SwBldNumLsb") << " (" << fnGetRawValue("SwBldNumLsb") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "ProcInst") {
            return static_cast<uint32_t>(msg.ucProcInst);
        }
        else if (mnem == "SwModIdent") {
            return static_cast<uint32_t>(msg.teSwModIdent);
        }
        else if (mnem == "SwVerMsb") {
            return static_cast<uint32_t>(msg.ucSwVerMsb);
        }
        else if (mnem == "SwVerIsb") {
            return static_cast<uint32_t>(msg.ucSwVerIsb);
        }
        else if (mnem == "SwVerLsb") {
            return static_cast<uint32_t>(msg.ucSwVerLsb);
        }
        else if (mnem == "SwBldNumMsb") {
            return static_cast<uint32_t>(msg.ucSwBldNumMsb);
        }
        else if (mnem == "SwBldNumLsb") {
            return static_cast<uint32_t>(msg.ucSwBldNumLsb);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ProcInst") {
     msg.ucProcInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "SwModIdent") {
     int enumValue = findEnumValue(ENUMLOOKUP[-1372759813], value);
     if (enumValue != -1) msg.teSwModIdent = static_cast<decltype(msg.teSwModIdent)>(enumValue);
     else msg.teSwModIdent = static_cast<decltype(msg.teSwModIdent)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SwVerMsb") {
     msg.ucSwVerMsb = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "SwVerIsb") {
     msg.ucSwVerIsb = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "SwVerLsb") {
     msg.ucSwVerLsb = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "SwBldNumMsb") {
     msg.ucSwBldNumMsb = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "SwBldNumLsb") {
     msg.ucSwBldNumLsb = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "ProcInst") {
            return 1.0 * (long double)(msg.ucProcInst + 0.0);
        }
        else if (mnem == "SwModIdent") {
            return 1.0 * (long double)(msg.teSwModIdent + 0.0);
        }
        else if (mnem == "SwVerMsb") {
            return 1.0 * (long double)(msg.ucSwVerMsb + 0.0);
        }
        else if (mnem == "SwVerIsb") {
            return 1.0 * (long double)(msg.ucSwVerIsb + 0.0);
        }
        else if (mnem == "SwVerLsb") {
            return 1.0 * (long double)(msg.ucSwVerLsb + 0.0);
        }
        else if (mnem == "SwBldNumMsb") {
            return 1.0 * (long double)(msg.ucSwBldNumMsb + 0.0);
        }
        else if (mnem == "SwBldNumLsb") {
            return 1.0 * (long double)(msg.ucSwBldNumLsb + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmSwVerSts;

// Auto-generated class definition for RVC_tzPGN_PM_RPC_CMD
typedef struct PmRpcCmd : public MessageBase {
RVC_tzPGN_PM_RPC_CMD msg;
PmRpcCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
PmRpcCmd (void * pvStruct) {  msg = *(RVC_tzPGN_PM_RPC_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "ProcedureId") {
            return std::to_string(msg.ucProcedureId);
        }
        else if (mnem == "ProcedureArg") {
            return (msg.ulProcedureArg == 0xffffffff) ? "No Data" : (msg.ulProcedureArg == 0xfffffffe) ? "Out of range" : (msg.ulProcedureArg == 0xfffffffd) ? "Reserved" : std::to_string(msg.ulProcedureArg);
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmRpcCmd" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "ProcedureId      : " << fnGetValue("ProcedureId") << " (" << fnGetRawValue("ProcedureId") << ")" << endl;
        cout << "ProcedureArg      : " << fnGetValue("ProcedureArg") << " (" << fnGetRawValue("ProcedureArg") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "ProcedureId") {
            return static_cast<uint32_t>(msg.ucProcedureId);
        }
        else if (mnem == "ProcedureArg") {
            return static_cast<uint32_t>(msg.ulProcedureArg);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ProcedureId") {
     msg.ucProcedureId = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ProcedureArg") {
     msg.ulProcedureArg = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd);
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "ProcedureId") {
            return 1.0 * (long double)(msg.ucProcedureId + 0.0);
        }
        else if (mnem == "ProcedureArg") {
            return 1.0 * (long double)(msg.ulProcedureArg + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmRpcCmd;

// Auto-generated class definition for RVC_tzPGN_PM_INV_LD_SH_STS
typedef struct PmInvLdShSts : public MessageBase {
RVC_tzPGN_PM_INV_LD_SH_STS msg;
PmInvLdShSts () {  memset(&msg, 0xFF, sizeof(msg));  };
PmInvLdShSts (void * pvStruct) {  msg = *(RVC_tzPGN_PM_INV_LD_SH_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "AcSrcId") {
            if (ENUMLOOKUP[321179986].find(msg.teAcSrcId) == ENUMLOOKUP[321179986].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAcSrcId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[321179986][msg.teAcSrcId];
              }
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[281300007].find(msg.teLine) == ENUMLOOKUP[281300007].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[281300007][msg.teLine];
              }
        }
        else if (mnem == "InvOutPwr_1") {
            return std::to_string(msg.ucInvOutPwr_1);
        }
        else if (mnem == "InvOutPwr_2") {
            return std::to_string(msg.ucInvOutPwr_2);
        }
        else if (mnem == "InvOutPwr_3") {
            return std::to_string(msg.ucInvOutPwr_3);
        }
        else if (mnem == "Current_1") {
            return std::to_string(msg.ucCurrent_1);
        }
        else if (mnem == "Current_2") {
            return std::to_string(msg.ucCurrent_2);
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmInvLdShSts" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "AcSrcId      : " << fnGetValue("AcSrcId") << " (" << fnGetRawValue("AcSrcId") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InvOutPwr_1      : " << fnGetValue("InvOutPwr_1") << " (" << fnGetRawValue("InvOutPwr_1") << ")" << endl;
        cout << "InvOutPwr_2      : " << fnGetValue("InvOutPwr_2") << " (" << fnGetRawValue("InvOutPwr_2") << ")" << endl;
        cout << "InvOutPwr_3      : " << fnGetValue("InvOutPwr_3") << " (" << fnGetRawValue("InvOutPwr_3") << ")" << endl;
        cout << "Current_1      : " << fnGetValue("Current_1") << " (" << fnGetRawValue("Current_1") << ")" << endl;
        cout << "Current_2      : " << fnGetValue("Current_2") << " (" << fnGetRawValue("Current_2") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "AcSrcId") {
            return static_cast<uint32_t>(msg.teAcSrcId);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InvOutPwr_1") {
            return static_cast<uint32_t>(msg.ucInvOutPwr_1);
        }
        else if (mnem == "InvOutPwr_2") {
            return static_cast<uint32_t>(msg.ucInvOutPwr_2);
        }
        else if (mnem == "InvOutPwr_3") {
            return static_cast<uint32_t>(msg.ucInvOutPwr_3);
        }
        else if (mnem == "Current_1") {
            return static_cast<uint32_t>(msg.ucCurrent_1);
        }
        else if (mnem == "Current_2") {
            return static_cast<uint32_t>(msg.ucCurrent_2);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AcSrcId") {
     int enumValue = findEnumValue(ENUMLOOKUP[321179986], value);
     if (enumValue != -1) msg.teAcSrcId = static_cast<decltype(msg.teAcSrcId)>(enumValue);
     else msg.teAcSrcId = static_cast<decltype(msg.teAcSrcId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[281300007], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InvOutPwr_1") {
     msg.ucInvOutPwr_1 = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "InvOutPwr_2") {
     msg.ucInvOutPwr_2 = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "InvOutPwr_3") {
     msg.ucInvOutPwr_3 = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Current_1") {
     msg.ucCurrent_1 = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Current_2") {
     msg.ucCurrent_2 = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "AcSrcId") {
            return 1.0 * (long double)(msg.teAcSrcId + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InvOutPwr_1") {
            return 1.0 * (long double)(msg.ucInvOutPwr_1 + 0.0);
        }
        else if (mnem == "InvOutPwr_2") {
            return 1.0 * (long double)(msg.ucInvOutPwr_2 + 0.0);
        }
        else if (mnem == "InvOutPwr_3") {
            return 1.0 * (long double)(msg.ucInvOutPwr_3 + 0.0);
        }
        else if (mnem == "Current_1") {
            return 1.0 * (long double)(msg.ucCurrent_1 + 0.0);
        }
        else if (mnem == "Current_2") {
            return 1.0 * (long double)(msg.ucCurrent_2 + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmInvLdShSts;

// Auto-generated class definition for RVC_tzPGN_PM_INV_STS
typedef struct PmInvSts : public MessageBase {
RVC_tzPGN_PM_INV_STS msg;
PmInvSts () {  memset(&msg, 0xFF, sizeof(msg));  };
PmInvSts (void * pvStruct) {  msg = *(RVC_tzPGN_PM_INV_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "AcSrcId") {
            if (ENUMLOOKUP[321179986].find(msg.teAcSrcId) == ENUMLOOKUP[321179986].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAcSrcId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[321179986][msg.teAcSrcId];
              }
        }
        else if (mnem == "InvMode") {
            if (ENUMLOOKUP[1546651609].find(msg.teInvMode) == ENUMLOOKUP[1546651609].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInvMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546651609][msg.teInvMode];
              }
        }
        else if (mnem == "OpState") {
            if (ENUMLOOKUP[1687015300].find(msg.teOpState) == ENUMLOOKUP[1687015300].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOpState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1687015300][msg.teOpState];
              }
        }
        else if (mnem == "InvEnDis") {
            if (ENUMLOOKUP[9066].find(msg.teInvEnDis) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInvEnDis);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teInvEnDis];
              }
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmInvSts" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "AcSrcId      : " << fnGetValue("AcSrcId") << " (" << fnGetRawValue("AcSrcId") << ")" << endl;
        cout << "InvMode      : " << fnGetValue("InvMode") << " (" << fnGetRawValue("InvMode") << ")" << endl;
        cout << "OpState      : " << fnGetValue("OpState") << " (" << fnGetRawValue("OpState") << ")" << endl;
        cout << "InvEnDis      : " << fnGetValue("InvEnDis") << " (" << fnGetRawValue("InvEnDis") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "AcSrcId") {
            return static_cast<uint32_t>(msg.teAcSrcId);
        }
        else if (mnem == "InvMode") {
            return static_cast<uint32_t>(msg.teInvMode);
        }
        else if (mnem == "OpState") {
            return static_cast<uint32_t>(msg.teOpState);
        }
        else if (mnem == "InvEnDis") {
            return static_cast<uint32_t>(msg.teInvEnDis);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AcSrcId") {
     int enumValue = findEnumValue(ENUMLOOKUP[321179986], value);
     if (enumValue != -1) msg.teAcSrcId = static_cast<decltype(msg.teAcSrcId)>(enumValue);
     else msg.teAcSrcId = static_cast<decltype(msg.teAcSrcId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InvMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546651609], value);
     if (enumValue != -1) msg.teInvMode = static_cast<decltype(msg.teInvMode)>(enumValue);
     else msg.teInvMode = static_cast<decltype(msg.teInvMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OpState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1687015300], value);
     if (enumValue != -1) msg.teOpState = static_cast<decltype(msg.teOpState)>(enumValue);
     else msg.teOpState = static_cast<decltype(msg.teOpState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InvEnDis") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teInvEnDis = static_cast<decltype(msg.teInvEnDis)>(enumValue);
     else msg.teInvEnDis = static_cast<decltype(msg.teInvEnDis)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "AcSrcId") {
            return 1.0 * (long double)(msg.teAcSrcId + 0.0);
        }
        else if (mnem == "InvMode") {
            return 1.0 * (long double)(msg.teInvMode + 0.0);
        }
        else if (mnem == "OpState") {
            return 1.0 * (long double)(msg.teOpState + 0.0);
        }
        else if (mnem == "InvEnDis") {
            return 1.0 * (long double)(msg.teInvEnDis + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmInvSts;

// Auto-generated class definition for RVC_tzPGN_PM_CHG_STS
typedef struct PmChgSts : public MessageBase {
RVC_tzPGN_PM_CHG_STS msg;
PmChgSts () {  memset(&msg, 0xFF, sizeof(msg));  };
PmChgSts (void * pvStruct) {  msg = *(RVC_tzPGN_PM_CHG_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "DcInOutAssocId") {
            if (ENUMLOOKUP[421711928].find(msg.teDcInOutAssocId) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDcInOutAssocId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teDcInOutAssocId];
              }
        }
        else if (mnem == "BattTempSensorPresent") {
            if (ENUMLOOKUP[9075].find(msg.teBattTempSensorPresent) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattTempSensorPresent);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBattTempSensorPresent];
              }
        }
        else if (mnem == "OpState") {
            if (ENUMLOOKUP[1650332213].find(msg.teOpState) == ENUMLOOKUP[1650332213].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOpState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1650332213][msg.teOpState];
              }
        }
        else if (mnem == "ChgMode") {
            if (ENUMLOOKUP[1679608493].find(msg.teChgMode) == ENUMLOOKUP[1679608493].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1679608493][msg.teChgMode];
              }
        }
        else if (mnem == "ChgAlgorithm") {
            if (ENUMLOOKUP[-710120228].find(msg.teChgAlgorithm) == ENUMLOOKUP[-710120228].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgAlgorithm);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-710120228][msg.teChgAlgorithm];
              }
        }
        else if (mnem == "CtrlVolts") {
            char buffer[50];
            auto engval = 0.010000000707805157 * (long double) (msg.siCtrlVolts + 0.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "V");
            return (msg.siCtrlVolts == 0x7fff) ? "No Data" : (msg.siCtrlVolts == 0x7ffe) ? "Out of range" : (msg.siCtrlVolts == 0x7ffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmChgSts" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "DcInOutAssocId      : " << fnGetValue("DcInOutAssocId") << " (" << fnGetRawValue("DcInOutAssocId") << ")" << endl;
        cout << "BattTempSensorPresent      : " << fnGetValue("BattTempSensorPresent") << " (" << fnGetRawValue("BattTempSensorPresent") << ")" << endl;
        cout << "OpState      : " << fnGetValue("OpState") << " (" << fnGetRawValue("OpState") << ")" << endl;
        cout << "ChgMode      : " << fnGetValue("ChgMode") << " (" << fnGetRawValue("ChgMode") << ")" << endl;
        cout << "ChgAlgorithm      : " << fnGetValue("ChgAlgorithm") << " (" << fnGetRawValue("ChgAlgorithm") << ")" << endl;
        cout << "CtrlVolts      : " << fnGetValue("CtrlVolts") << " (" << fnGetRawValue("CtrlVolts") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "DcInOutAssocId") {
            return static_cast<uint32_t>(msg.teDcInOutAssocId);
        }
        else if (mnem == "BattTempSensorPresent") {
            return static_cast<uint32_t>(msg.teBattTempSensorPresent);
        }
        else if (mnem == "OpState") {
            return static_cast<uint32_t>(msg.teOpState);
        }
        else if (mnem == "ChgMode") {
            return static_cast<uint32_t>(msg.teChgMode);
        }
        else if (mnem == "ChgAlgorithm") {
            return static_cast<uint32_t>(msg.teChgAlgorithm);
        }
        else if (mnem == "CtrlVolts") {
            return static_cast<uint32_t>(msg.siCtrlVolts);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInOutAssocId") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teDcInOutAssocId = static_cast<decltype(msg.teDcInOutAssocId)>(enumValue);
     else msg.teDcInOutAssocId = static_cast<decltype(msg.teDcInOutAssocId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattTempSensorPresent") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBattTempSensorPresent = static_cast<decltype(msg.teBattTempSensorPresent)>(enumValue);
     else msg.teBattTempSensorPresent = static_cast<decltype(msg.teBattTempSensorPresent)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OpState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1650332213], value);
     if (enumValue != -1) msg.teOpState = static_cast<decltype(msg.teOpState)>(enumValue);
     else msg.teOpState = static_cast<decltype(msg.teOpState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[1679608493], value);
     if (enumValue != -1) msg.teChgMode = static_cast<decltype(msg.teChgMode)>(enumValue);
     else msg.teChgMode = static_cast<decltype(msg.teChgMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgAlgorithm") {
     int enumValue = findEnumValue(ENUMLOOKUP[-710120228], value);
     if (enumValue != -1) msg.teChgAlgorithm = static_cast<decltype(msg.teChgAlgorithm)>(enumValue);
     else msg.teChgAlgorithm = static_cast<decltype(msg.teChgAlgorithm)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CtrlVolts") {
     msg.siCtrlVolts = stringToInt(value, 0x7fff, 0x7ffe, 0x7ffd, 0.010000000707805157, 0.0);
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "DcInOutAssocId") {
            return 1.0 * (long double)(msg.teDcInOutAssocId + 0.0);
        }
        else if (mnem == "BattTempSensorPresent") {
            return 1.0 * (long double)(msg.teBattTempSensorPresent + 0.0);
        }
        else if (mnem == "OpState") {
            return 1.0 * (long double)(msg.teOpState + 0.0);
        }
        else if (mnem == "ChgMode") {
            return 1.0 * (long double)(msg.teChgMode + 0.0);
        }
        else if (mnem == "ChgAlgorithm") {
            return 1.0 * (long double)(msg.teChgAlgorithm + 0.0);
        }
        else if (mnem == "CtrlVolts") {
            return 0.010000000707805157 * (long double)(msg.siCtrlVolts + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmChgSts;

// Auto-generated class definition for RVC_tzPGN_PM_INV_CTRL_CMD
typedef struct PmInvCtrlCmd : public MessageBase {
RVC_tzPGN_PM_INV_CTRL_CMD msg;
PmInvCtrlCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
PmInvCtrlCmd (void * pvStruct) {  msg = *(RVC_tzPGN_PM_INV_CTRL_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "AcSrcId") {
            if (ENUMLOOKUP[321179986].find(msg.teAcSrcId) == ENUMLOOKUP[321179986].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAcSrcId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[321179986][msg.teAcSrcId];
              }
        }
        else if (mnem == "InvEnDis") {
            if (ENUMLOOKUP[9066].find(msg.teInvEnDis) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInvEnDis);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teInvEnDis];
              }
        }
        else if (mnem == "SellToGridEnDis") {
            if (ENUMLOOKUP[9066].find(msg.teSellToGridEnDis) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teSellToGridEnDis);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teSellToGridEnDis];
              }
        }
        else if (mnem == "ForceSell") {
            if (ENUMLOOKUP[9066].find(msg.teForceSell) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teForceSell);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teForceSell];
              }
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmInvCtrlCmd" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "AcSrcId      : " << fnGetValue("AcSrcId") << " (" << fnGetRawValue("AcSrcId") << ")" << endl;
        cout << "InvEnDis      : " << fnGetValue("InvEnDis") << " (" << fnGetRawValue("InvEnDis") << ")" << endl;
        cout << "SellToGridEnDis      : " << fnGetValue("SellToGridEnDis") << " (" << fnGetRawValue("SellToGridEnDis") << ")" << endl;
        cout << "ForceSell      : " << fnGetValue("ForceSell") << " (" << fnGetRawValue("ForceSell") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "AcSrcId") {
            return static_cast<uint32_t>(msg.teAcSrcId);
        }
        else if (mnem == "InvEnDis") {
            return static_cast<uint32_t>(msg.teInvEnDis);
        }
        else if (mnem == "SellToGridEnDis") {
            return static_cast<uint32_t>(msg.teSellToGridEnDis);
        }
        else if (mnem == "ForceSell") {
            return static_cast<uint32_t>(msg.teForceSell);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AcSrcId") {
     int enumValue = findEnumValue(ENUMLOOKUP[321179986], value);
     if (enumValue != -1) msg.teAcSrcId = static_cast<decltype(msg.teAcSrcId)>(enumValue);
     else msg.teAcSrcId = static_cast<decltype(msg.teAcSrcId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InvEnDis") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teInvEnDis = static_cast<decltype(msg.teInvEnDis)>(enumValue);
     else msg.teInvEnDis = static_cast<decltype(msg.teInvEnDis)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SellToGridEnDis") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teSellToGridEnDis = static_cast<decltype(msg.teSellToGridEnDis)>(enumValue);
     else msg.teSellToGridEnDis = static_cast<decltype(msg.teSellToGridEnDis)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ForceSell") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teForceSell = static_cast<decltype(msg.teForceSell)>(enumValue);
     else msg.teForceSell = static_cast<decltype(msg.teForceSell)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "AcSrcId") {
            return 1.0 * (long double)(msg.teAcSrcId + 0.0);
        }
        else if (mnem == "InvEnDis") {
            return 1.0 * (long double)(msg.teInvEnDis + 0.0);
        }
        else if (mnem == "SellToGridEnDis") {
            return 1.0 * (long double)(msg.teSellToGridEnDis + 0.0);
        }
        else if (mnem == "ForceSell") {
            return 1.0 * (long double)(msg.teForceSell + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmInvCtrlCmd;

// Auto-generated class definition for RVC_tzPGN_PM_AC_STS_RMS
typedef struct PmAcStsRms : public MessageBase {
RVC_tzPGN_PM_AC_STS_RMS msg;
PmAcStsRms () {  memset(&msg, 0xFF, sizeof(msg));  };
PmAcStsRms (void * pvStruct) {  msg = *(RVC_tzPGN_PM_AC_STS_RMS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "AcSrcId") {
            if (ENUMLOOKUP[321179986].find(msg.teAcSrcId) == ENUMLOOKUP[321179986].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAcSrcId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[321179986][msg.teAcSrcId];
              }
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[281300007].find(msg.teLine) == ENUMLOOKUP[281300007].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[281300007][msg.teLine];
              }
        }
        else if (mnem == "AcConn") {
            if (ENUMLOOKUP[1576267937].find(msg.teAcConn) == ENUMLOOKUP[1576267937].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAcConn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1576267937][msg.teAcConn];
              }
        }
        else if (mnem == "Quality") {
            if (ENUMLOOKUP[498223742].find(msg.teQuality) == ENUMLOOKUP[498223742].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teQuality);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[498223742][msg.teQuality];
              }
        }
        else if (mnem == "Freq") {
            char buffer[50];
            auto engval = 0.009999999776482582 * (long double) (msg.uiFreq + 0.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "Hz");
            return (msg.uiFreq == 0xffff) ? "No Data" : (msg.uiFreq == 0xfffe) ? "Out of range" : (msg.uiFreq == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmAcStsRms" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "AcSrcId      : " << fnGetValue("AcSrcId") << " (" << fnGetRawValue("AcSrcId") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "AcConn      : " << fnGetValue("AcConn") << " (" << fnGetRawValue("AcConn") << ")" << endl;
        cout << "Quality      : " << fnGetValue("Quality") << " (" << fnGetRawValue("Quality") << ")" << endl;
        cout << "Freq      : " << fnGetValue("Freq") << " (" << fnGetRawValue("Freq") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "AcSrcId") {
            return static_cast<uint32_t>(msg.teAcSrcId);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "AcConn") {
            return static_cast<uint32_t>(msg.teAcConn);
        }
        else if (mnem == "Quality") {
            return static_cast<uint32_t>(msg.teQuality);
        }
        else if (mnem == "Freq") {
            return static_cast<uint32_t>(msg.uiFreq);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AcSrcId") {
     int enumValue = findEnumValue(ENUMLOOKUP[321179986], value);
     if (enumValue != -1) msg.teAcSrcId = static_cast<decltype(msg.teAcSrcId)>(enumValue);
     else msg.teAcSrcId = static_cast<decltype(msg.teAcSrcId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[281300007], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AcConn") {
     int enumValue = findEnumValue(ENUMLOOKUP[1576267937], value);
     if (enumValue != -1) msg.teAcConn = static_cast<decltype(msg.teAcConn)>(enumValue);
     else msg.teAcConn = static_cast<decltype(msg.teAcConn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Quality") {
     int enumValue = findEnumValue(ENUMLOOKUP[498223742], value);
     if (enumValue != -1) msg.teQuality = static_cast<decltype(msg.teQuality)>(enumValue);
     else msg.teQuality = static_cast<decltype(msg.teQuality)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Freq") {
     msg.uiFreq = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.009999999776482582, 0.0);
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "AcSrcId") {
            return 1.0 * (long double)(msg.teAcSrcId + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "AcConn") {
            return 1.0 * (long double)(msg.teAcConn + 0.0);
        }
        else if (mnem == "Quality") {
            return 1.0 * (long double)(msg.teQuality + 0.0);
        }
        else if (mnem == "Freq") {
            return 0.009999999776482582 * (long double)(msg.uiFreq + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmAcStsRms;

// Auto-generated class definition for RVC_tzPGN_PM_AC_XFER_SW_STS
typedef struct PmAcXferSwSts : public MessageBase {
RVC_tzPGN_PM_AC_XFER_SW_STS msg;
PmAcXferSwSts () {  memset(&msg, 0xFF, sizeof(msg));  };
PmAcXferSwSts (void * pvStruct) {  msg = *(RVC_tzPGN_PM_AC_XFER_SW_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "OpState") {
            if (ENUMLOOKUP[-100316561].find(msg.teOpState) == ENUMLOOKUP[-100316561].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOpState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-100316561][msg.teOpState];
              }
        }
        else if (mnem == "XferSwMode") {
            if (ENUMLOOKUP[240482193].find(msg.teXferSwMode) == ENUMLOOKUP[240482193].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teXferSwMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[240482193][msg.teXferSwMode];
              }
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmAcXferSwSts" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "OpState      : " << fnGetValue("OpState") << " (" << fnGetRawValue("OpState") << ")" << endl;
        cout << "XferSwMode      : " << fnGetValue("XferSwMode") << " (" << fnGetRawValue("XferSwMode") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "OpState") {
            return static_cast<uint32_t>(msg.teOpState);
        }
        else if (mnem == "XferSwMode") {
            return static_cast<uint32_t>(msg.teXferSwMode);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OpState") {
     int enumValue = findEnumValue(ENUMLOOKUP[-100316561], value);
     if (enumValue != -1) msg.teOpState = static_cast<decltype(msg.teOpState)>(enumValue);
     else msg.teOpState = static_cast<decltype(msg.teOpState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "XferSwMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[240482193], value);
     if (enumValue != -1) msg.teXferSwMode = static_cast<decltype(msg.teXferSwMode)>(enumValue);
     else msg.teXferSwMode = static_cast<decltype(msg.teXferSwMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "OpState") {
            return 1.0 * (long double)(msg.teOpState + 0.0);
        }
        else if (mnem == "XferSwMode") {
            return 1.0 * (long double)(msg.teXferSwMode + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmAcXferSwSts;

// Auto-generated class definition for RVC_tzPGN_PM_GET_CONFIG_PARAM
typedef struct PmGetConfigParam : public MessageBase {
RVC_tzPGN_PM_GET_CONFIG_PARAM msg;
PmGetConfigParam () {  memset(&msg, 0xFF, sizeof(msg));  };
PmGetConfigParam (void * pvStruct) {  msg = *(RVC_tzPGN_PM_GET_CONFIG_PARAM *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "CfgParamId") {
            if (ENUMLOOKUP[217496074].find(msg.teCfgParamId) == ENUMLOOKUP[217496074].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCfgParamId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[217496074][msg.teCfgParamId];
              }
        }
        else if (mnem == "ParamValue") {
            return (msg.ulParamValue == 0xffffffff) ? "No Data" : (msg.ulParamValue == 0xfffffffe) ? "Out of range" : (msg.ulParamValue == 0xfffffffd) ? "Reserved" : std::to_string(msg.ulParamValue);
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmGetConfigParam" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "CfgParamId      : " << fnGetValue("CfgParamId") << " (" << fnGetRawValue("CfgParamId") << ")" << endl;
        cout << "ParamValue      : " << fnGetValue("ParamValue") << " (" << fnGetRawValue("ParamValue") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "CfgParamId") {
            return static_cast<uint32_t>(msg.teCfgParamId);
        }
        else if (mnem == "ParamValue") {
            return static_cast<uint32_t>(msg.ulParamValue);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CfgParamId") {
     int enumValue = findEnumValue(ENUMLOOKUP[217496074], value);
     if (enumValue != -1) msg.teCfgParamId = static_cast<decltype(msg.teCfgParamId)>(enumValue);
     else msg.teCfgParamId = static_cast<decltype(msg.teCfgParamId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ParamValue") {
     msg.ulParamValue = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd);
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "CfgParamId") {
            return 1.0 * (long double)(msg.teCfgParamId + 0.0);
        }
        else if (mnem == "ParamValue") {
            return 1.0 * (long double)(msg.ulParamValue + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmGetConfigParam;

// Auto-generated class definition for RVC_tzPGN_PM_SET_CONFIG_PARAM
typedef struct PmSetConfigParam : public MessageBase {
RVC_tzPGN_PM_SET_CONFIG_PARAM msg;
PmSetConfigParam () {  memset(&msg, 0xFF, sizeof(msg));  };
PmSetConfigParam (void * pvStruct) {  msg = *(RVC_tzPGN_PM_SET_CONFIG_PARAM *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "CfgParamId") {
            if (ENUMLOOKUP[217496074].find(msg.teCfgParamId) == ENUMLOOKUP[217496074].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCfgParamId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[217496074][msg.teCfgParamId];
              }
        }
        else if (mnem == "ParamValue") {
            return (msg.ulParamValue == 0xffffffff) ? "No Data" : (msg.ulParamValue == 0xfffffffe) ? "Out of range" : (msg.ulParamValue == 0xfffffffd) ? "Reserved" : std::to_string(msg.ulParamValue);
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmSetConfigParam" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "CfgParamId      : " << fnGetValue("CfgParamId") << " (" << fnGetRawValue("CfgParamId") << ")" << endl;
        cout << "ParamValue      : " << fnGetValue("ParamValue") << " (" << fnGetRawValue("ParamValue") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "CfgParamId") {
            return static_cast<uint32_t>(msg.teCfgParamId);
        }
        else if (mnem == "ParamValue") {
            return static_cast<uint32_t>(msg.ulParamValue);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CfgParamId") {
     int enumValue = findEnumValue(ENUMLOOKUP[217496074], value);
     if (enumValue != -1) msg.teCfgParamId = static_cast<decltype(msg.teCfgParamId)>(enumValue);
     else msg.teCfgParamId = static_cast<decltype(msg.teCfgParamId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ParamValue") {
     msg.ulParamValue = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd);
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "CfgParamId") {
            return 1.0 * (long double)(msg.teCfgParamId + 0.0);
        }
        else if (mnem == "ParamValue") {
            return 1.0 * (long double)(msg.ulParamValue + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmSetConfigParam;

// Auto-generated class definition for RVC_tzPGN_PM_GET_STATUS_PARAM
typedef struct PmGetStatusParam : public MessageBase {
RVC_tzPGN_PM_GET_STATUS_PARAM msg;
PmGetStatusParam () {  memset(&msg, 0xFF, sizeof(msg));  };
PmGetStatusParam (void * pvStruct) {  msg = *(RVC_tzPGN_PM_GET_STATUS_PARAM *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "StsParamId") {
            if (ENUMLOOKUP[1663267569].find(msg.teStsParamId) == ENUMLOOKUP[1663267569].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teStsParamId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1663267569][msg.teStsParamId];
              }
        }
        else if (mnem == "ParamValue") {
            return (msg.ulParamValue == 0xffffffff) ? "No Data" : (msg.ulParamValue == 0xfffffffe) ? "Out of range" : (msg.ulParamValue == 0xfffffffd) ? "Reserved" : std::to_string(msg.ulParamValue);
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmGetStatusParam" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "StsParamId      : " << fnGetValue("StsParamId") << " (" << fnGetRawValue("StsParamId") << ")" << endl;
        cout << "ParamValue      : " << fnGetValue("ParamValue") << " (" << fnGetRawValue("ParamValue") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "StsParamId") {
            return static_cast<uint32_t>(msg.teStsParamId);
        }
        else if (mnem == "ParamValue") {
            return static_cast<uint32_t>(msg.ulParamValue);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "StsParamId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1663267569], value);
     if (enumValue != -1) msg.teStsParamId = static_cast<decltype(msg.teStsParamId)>(enumValue);
     else msg.teStsParamId = static_cast<decltype(msg.teStsParamId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ParamValue") {
     msg.ulParamValue = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd);
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "StsParamId") {
            return 1.0 * (long double)(msg.teStsParamId + 0.0);
        }
        else if (mnem == "ParamValue") {
            return 1.0 * (long double)(msg.ulParamValue + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        return 0.0;
    }
} PmGetStatusParam;

// Auto-generated class definition for RVC_tzPGN_PM_PPN_SESSION_CMD
typedef struct PmPpnSessionCmd : public MessageBase {
RVC_tzPGN_PM_PPN_SESSION_CMD msg;
PmPpnSessionCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
PmPpnSessionCmd (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PPN_SESSION_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "SessEnDis") {
            if (ENUMLOOKUP[1659473592].find(msg.teSessEnDis) == ENUMLOOKUP[1659473592].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teSessEnDis);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1659473592][msg.teSessEnDis];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmPpnSessionCmd" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "SessEnDis      : " << fnGetValue("SessEnDis") << " (" << fnGetRawValue("SessEnDis") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "SessEnDis") {
            return static_cast<uint32_t>(msg.teSessEnDis);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SessEnDis") {
     int enumValue = findEnumValue(ENUMLOOKUP[1659473592], value);
     if (enumValue != -1) msg.teSessEnDis = static_cast<decltype(msg.teSessEnDis)>(enumValue);
     else msg.teSessEnDis = static_cast<decltype(msg.teSessEnDis)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "SessEnDis") {
            return 1.0 * (long double)(msg.teSessEnDis + 0.0);
        }
        return 0.0;
    }
} PmPpnSessionCmd;

// Auto-generated class definition for RVC_tzPGN_PM_PPN_SESSION_RSP
typedef struct PmPpnSessionRsp : public MessageBase {
RVC_tzPGN_PM_PPN_SESSION_RSP msg;
PmPpnSessionRsp () {  memset(&msg, 0xFF, sizeof(msg));  };
PmPpnSessionRsp (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PPN_SESSION_RSP *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "SessEnDis") {
            if (ENUMLOOKUP[1659473592].find(msg.teSessEnDis) == ENUMLOOKUP[1659473592].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teSessEnDis);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1659473592][msg.teSessEnDis];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmPpnSessionRsp" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "SessEnDis      : " << fnGetValue("SessEnDis") << " (" << fnGetRawValue("SessEnDis") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "SessEnDis") {
            return static_cast<uint32_t>(msg.teSessEnDis);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SessEnDis") {
     int enumValue = findEnumValue(ENUMLOOKUP[1659473592], value);
     if (enumValue != -1) msg.teSessEnDis = static_cast<decltype(msg.teSessEnDis)>(enumValue);
     else msg.teSessEnDis = static_cast<decltype(msg.teSessEnDis)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "SessEnDis") {
            return 1.0 * (long double)(msg.teSessEnDis + 0.0);
        }
        return 0.0;
    }
} PmPpnSessionRsp;

// Auto-generated class definition for RVC_tzPGN_PM_PPN_READ_CMD
typedef struct PmPpnReadCmd : public MessageBase {
RVC_tzPGN_PM_PPN_READ_CMD msg;
PmPpnReadCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
PmPpnReadCmd (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PPN_READ_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "ParamId") {
            if (ENUMLOOKUP[-2087867454].find(msg.teParamId) == ENUMLOOKUP[-2087867454].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teParamId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-2087867454][msg.teParamId];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmPpnReadCmd" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "ParamId      : " << fnGetValue("ParamId") << " (" << fnGetRawValue("ParamId") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "ParamId") {
            return static_cast<uint32_t>(msg.teParamId);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ParamId") {
     int enumValue = findEnumValue(ENUMLOOKUP[-2087867454], value);
     if (enumValue != -1) msg.teParamId = static_cast<decltype(msg.teParamId)>(enumValue);
     else msg.teParamId = static_cast<decltype(msg.teParamId)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "ParamId") {
            return 1.0 * (long double)(msg.teParamId + 0.0);
        }
        return 0.0;
    }
} PmPpnReadCmd;

// Auto-generated class definition for RVC_tzPGN_PM_PPN_READ_RSP
typedef struct PmPpnReadRsp : public MessageBase {
RVC_tzPGN_PM_PPN_READ_RSP msg;
PmPpnReadRsp () {  memset(&msg, 0xFF, sizeof(msg));  };
PmPpnReadRsp (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PPN_READ_RSP *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "ParamId") {
            if (ENUMLOOKUP[-2087867454].find(msg.teParamId) == ENUMLOOKUP[-2087867454].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teParamId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-2087867454][msg.teParamId];
              }
        }
        else if (mnem == "Value0") {
            return (msg.ucValue0 == 0xff) ? "No Data" : (msg.ucValue0 == 0xfe) ? "Out of range" : (msg.ucValue0 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue0);
        }
        else if (mnem == "Value1") {
            return (msg.ucValue1 == 0xff) ? "No Data" : (msg.ucValue1 == 0xfe) ? "Out of range" : (msg.ucValue1 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue1);
        }
        else if (mnem == "Value2") {
            return (msg.ucValue2 == 0xff) ? "No Data" : (msg.ucValue2 == 0xfe) ? "Out of range" : (msg.ucValue2 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue2);
        }
        else if (mnem == "Value3") {
            return (msg.ucValue3 == 0xff) ? "No Data" : (msg.ucValue3 == 0xfe) ? "Out of range" : (msg.ucValue3 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue3);
        }
        else if (mnem == "Value4") {
            return (msg.ucValue4 == 0xff) ? "No Data" : (msg.ucValue4 == 0xfe) ? "Out of range" : (msg.ucValue4 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue4);
        }
        else if (mnem == "Value5") {
            return (msg.ucValue5 == 0xff) ? "No Data" : (msg.ucValue5 == 0xfe) ? "Out of range" : (msg.ucValue5 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue5);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmPpnReadRsp" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "ParamId      : " << fnGetValue("ParamId") << " (" << fnGetRawValue("ParamId") << ")" << endl;
        cout << "Value0      : " << fnGetValue("Value0") << " (" << fnGetRawValue("Value0") << ")" << endl;
        cout << "Value1      : " << fnGetValue("Value1") << " (" << fnGetRawValue("Value1") << ")" << endl;
        cout << "Value2      : " << fnGetValue("Value2") << " (" << fnGetRawValue("Value2") << ")" << endl;
        cout << "Value3      : " << fnGetValue("Value3") << " (" << fnGetRawValue("Value3") << ")" << endl;
        cout << "Value4      : " << fnGetValue("Value4") << " (" << fnGetRawValue("Value4") << ")" << endl;
        cout << "Value5      : " << fnGetValue("Value5") << " (" << fnGetRawValue("Value5") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "ParamId") {
            return static_cast<uint32_t>(msg.teParamId);
        }
        else if (mnem == "Value0") {
            return static_cast<uint32_t>(msg.ucValue0);
        }
        else if (mnem == "Value1") {
            return static_cast<uint32_t>(msg.ucValue1);
        }
        else if (mnem == "Value2") {
            return static_cast<uint32_t>(msg.ucValue2);
        }
        else if (mnem == "Value3") {
            return static_cast<uint32_t>(msg.ucValue3);
        }
        else if (mnem == "Value4") {
            return static_cast<uint32_t>(msg.ucValue4);
        }
        else if (mnem == "Value5") {
            return static_cast<uint32_t>(msg.ucValue5);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ParamId") {
     int enumValue = findEnumValue(ENUMLOOKUP[-2087867454], value);
     if (enumValue != -1) msg.teParamId = static_cast<decltype(msg.teParamId)>(enumValue);
     else msg.teParamId = static_cast<decltype(msg.teParamId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Value0") {
     msg.ucValue0 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value1") {
     msg.ucValue1 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value2") {
     msg.ucValue2 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value3") {
     msg.ucValue3 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value4") {
     msg.ucValue4 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value5") {
     msg.ucValue5 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "ParamId") {
            return 1.0 * (long double)(msg.teParamId + 0.0);
        }
        else if (mnem == "Value0") {
            return 1.0 * (long double)(msg.ucValue0 + 0.0);
        }
        else if (mnem == "Value1") {
            return 1.0 * (long double)(msg.ucValue1 + 0.0);
        }
        else if (mnem == "Value2") {
            return 1.0 * (long double)(msg.ucValue2 + 0.0);
        }
        else if (mnem == "Value3") {
            return 1.0 * (long double)(msg.ucValue3 + 0.0);
        }
        else if (mnem == "Value4") {
            return 1.0 * (long double)(msg.ucValue4 + 0.0);
        }
        else if (mnem == "Value5") {
            return 1.0 * (long double)(msg.ucValue5 + 0.0);
        }
        return 0.0;
    }
} PmPpnReadRsp;

// Auto-generated class definition for RVC_tzPGN_PM_PPN_WRITE_CMD
typedef struct PmPpnWriteCmd : public MessageBase {
RVC_tzPGN_PM_PPN_WRITE_CMD msg;
PmPpnWriteCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
PmPpnWriteCmd (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PPN_WRITE_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "ParamId") {
            if (ENUMLOOKUP[-2087867454].find(msg.teParamId) == ENUMLOOKUP[-2087867454].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teParamId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-2087867454][msg.teParamId];
              }
        }
        else if (mnem == "Value0") {
            return (msg.ucValue0 == 0xff) ? "No Data" : (msg.ucValue0 == 0xfe) ? "Out of range" : (msg.ucValue0 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue0);
        }
        else if (mnem == "Value1") {
            return (msg.ucValue1 == 0xff) ? "No Data" : (msg.ucValue1 == 0xfe) ? "Out of range" : (msg.ucValue1 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue1);
        }
        else if (mnem == "Value2") {
            return (msg.ucValue2 == 0xff) ? "No Data" : (msg.ucValue2 == 0xfe) ? "Out of range" : (msg.ucValue2 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue2);
        }
        else if (mnem == "Value3") {
            return (msg.ucValue3 == 0xff) ? "No Data" : (msg.ucValue3 == 0xfe) ? "Out of range" : (msg.ucValue3 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue3);
        }
        else if (mnem == "Value4") {
            return (msg.ucValue4 == 0xff) ? "No Data" : (msg.ucValue4 == 0xfe) ? "Out of range" : (msg.ucValue4 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue4);
        }
        else if (mnem == "Value5") {
            return (msg.ucValue5 == 0xff) ? "No Data" : (msg.ucValue5 == 0xfe) ? "Out of range" : (msg.ucValue5 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue5);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmPpnWriteCmd" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "ParamId      : " << fnGetValue("ParamId") << " (" << fnGetRawValue("ParamId") << ")" << endl;
        cout << "Value0      : " << fnGetValue("Value0") << " (" << fnGetRawValue("Value0") << ")" << endl;
        cout << "Value1      : " << fnGetValue("Value1") << " (" << fnGetRawValue("Value1") << ")" << endl;
        cout << "Value2      : " << fnGetValue("Value2") << " (" << fnGetRawValue("Value2") << ")" << endl;
        cout << "Value3      : " << fnGetValue("Value3") << " (" << fnGetRawValue("Value3") << ")" << endl;
        cout << "Value4      : " << fnGetValue("Value4") << " (" << fnGetRawValue("Value4") << ")" << endl;
        cout << "Value5      : " << fnGetValue("Value5") << " (" << fnGetRawValue("Value5") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "ParamId") {
            return static_cast<uint32_t>(msg.teParamId);
        }
        else if (mnem == "Value0") {
            return static_cast<uint32_t>(msg.ucValue0);
        }
        else if (mnem == "Value1") {
            return static_cast<uint32_t>(msg.ucValue1);
        }
        else if (mnem == "Value2") {
            return static_cast<uint32_t>(msg.ucValue2);
        }
        else if (mnem == "Value3") {
            return static_cast<uint32_t>(msg.ucValue3);
        }
        else if (mnem == "Value4") {
            return static_cast<uint32_t>(msg.ucValue4);
        }
        else if (mnem == "Value5") {
            return static_cast<uint32_t>(msg.ucValue5);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ParamId") {
     int enumValue = findEnumValue(ENUMLOOKUP[-2087867454], value);
     if (enumValue != -1) msg.teParamId = static_cast<decltype(msg.teParamId)>(enumValue);
     else msg.teParamId = static_cast<decltype(msg.teParamId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Value0") {
     msg.ucValue0 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value1") {
     msg.ucValue1 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value2") {
     msg.ucValue2 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value3") {
     msg.ucValue3 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value4") {
     msg.ucValue4 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value5") {
     msg.ucValue5 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "ParamId") {
            return 1.0 * (long double)(msg.teParamId + 0.0);
        }
        else if (mnem == "Value0") {
            return 1.0 * (long double)(msg.ucValue0 + 0.0);
        }
        else if (mnem == "Value1") {
            return 1.0 * (long double)(msg.ucValue1 + 0.0);
        }
        else if (mnem == "Value2") {
            return 1.0 * (long double)(msg.ucValue2 + 0.0);
        }
        else if (mnem == "Value3") {
            return 1.0 * (long double)(msg.ucValue3 + 0.0);
        }
        else if (mnem == "Value4") {
            return 1.0 * (long double)(msg.ucValue4 + 0.0);
        }
        else if (mnem == "Value5") {
            return 1.0 * (long double)(msg.ucValue5 + 0.0);
        }
        return 0.0;
    }
} PmPpnWriteCmd;

// Auto-generated class definition for RVC_tzPGN_PM_PPN_WRITE_RSP
typedef struct PmPpnWriteRsp : public MessageBase {
RVC_tzPGN_PM_PPN_WRITE_RSP msg;
PmPpnWriteRsp () {  memset(&msg, 0xFF, sizeof(msg));  };
PmPpnWriteRsp (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PPN_WRITE_RSP *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "ParamId") {
            if (ENUMLOOKUP[-2087867454].find(msg.teParamId) == ENUMLOOKUP[-2087867454].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teParamId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-2087867454][msg.teParamId];
              }
        }
        else if (mnem == "Value0") {
            return (msg.ucValue0 == 0xff) ? "No Data" : (msg.ucValue0 == 0xfe) ? "Out of range" : (msg.ucValue0 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue0);
        }
        else if (mnem == "Value1") {
            return (msg.ucValue1 == 0xff) ? "No Data" : (msg.ucValue1 == 0xfe) ? "Out of range" : (msg.ucValue1 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue1);
        }
        else if (mnem == "Value2") {
            return (msg.ucValue2 == 0xff) ? "No Data" : (msg.ucValue2 == 0xfe) ? "Out of range" : (msg.ucValue2 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue2);
        }
        else if (mnem == "Value3") {
            return (msg.ucValue3 == 0xff) ? "No Data" : (msg.ucValue3 == 0xfe) ? "Out of range" : (msg.ucValue3 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue3);
        }
        else if (mnem == "Value4") {
            return (msg.ucValue4 == 0xff) ? "No Data" : (msg.ucValue4 == 0xfe) ? "Out of range" : (msg.ucValue4 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue4);
        }
        else if (mnem == "Value5") {
            return (msg.ucValue5 == 0xff) ? "No Data" : (msg.ucValue5 == 0xfe) ? "Out of range" : (msg.ucValue5 == 0xfd) ? "Reserved" : std::to_string(msg.ucValue5);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmPpnWriteRsp" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "ParamId      : " << fnGetValue("ParamId") << " (" << fnGetRawValue("ParamId") << ")" << endl;
        cout << "Value0      : " << fnGetValue("Value0") << " (" << fnGetRawValue("Value0") << ")" << endl;
        cout << "Value1      : " << fnGetValue("Value1") << " (" << fnGetRawValue("Value1") << ")" << endl;
        cout << "Value2      : " << fnGetValue("Value2") << " (" << fnGetRawValue("Value2") << ")" << endl;
        cout << "Value3      : " << fnGetValue("Value3") << " (" << fnGetRawValue("Value3") << ")" << endl;
        cout << "Value4      : " << fnGetValue("Value4") << " (" << fnGetRawValue("Value4") << ")" << endl;
        cout << "Value5      : " << fnGetValue("Value5") << " (" << fnGetRawValue("Value5") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "ParamId") {
            return static_cast<uint32_t>(msg.teParamId);
        }
        else if (mnem == "Value0") {
            return static_cast<uint32_t>(msg.ucValue0);
        }
        else if (mnem == "Value1") {
            return static_cast<uint32_t>(msg.ucValue1);
        }
        else if (mnem == "Value2") {
            return static_cast<uint32_t>(msg.ucValue2);
        }
        else if (mnem == "Value3") {
            return static_cast<uint32_t>(msg.ucValue3);
        }
        else if (mnem == "Value4") {
            return static_cast<uint32_t>(msg.ucValue4);
        }
        else if (mnem == "Value5") {
            return static_cast<uint32_t>(msg.ucValue5);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ParamId") {
     int enumValue = findEnumValue(ENUMLOOKUP[-2087867454], value);
     if (enumValue != -1) msg.teParamId = static_cast<decltype(msg.teParamId)>(enumValue);
     else msg.teParamId = static_cast<decltype(msg.teParamId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Value0") {
     msg.ucValue0 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value1") {
     msg.ucValue1 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value2") {
     msg.ucValue2 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value3") {
     msg.ucValue3 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value4") {
     msg.ucValue4 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Value5") {
     msg.ucValue5 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "ParamId") {
            return 1.0 * (long double)(msg.teParamId + 0.0);
        }
        else if (mnem == "Value0") {
            return 1.0 * (long double)(msg.ucValue0 + 0.0);
        }
        else if (mnem == "Value1") {
            return 1.0 * (long double)(msg.ucValue1 + 0.0);
        }
        else if (mnem == "Value2") {
            return 1.0 * (long double)(msg.ucValue2 + 0.0);
        }
        else if (mnem == "Value3") {
            return 1.0 * (long double)(msg.ucValue3 + 0.0);
        }
        else if (mnem == "Value4") {
            return 1.0 * (long double)(msg.ucValue4 + 0.0);
        }
        else if (mnem == "Value5") {
            return 1.0 * (long double)(msg.ucValue5 + 0.0);
        }
        return 0.0;
    }
} PmPpnWriteRsp;

// Auto-generated class definition for RVC_tzPGN_PM_PPN_NAK_RSP
typedef struct PmPpnNakRsp : public MessageBase {
RVC_tzPGN_PM_PPN_NAK_RSP msg;
PmPpnNakRsp () {  memset(&msg, 0xFF, sizeof(msg));  };
PmPpnNakRsp (void * pvStruct) {  msg = *(RVC_tzPGN_PM_PPN_NAK_RSP *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "ParamId") {
            if (ENUMLOOKUP[-2087867454].find(msg.teParamId) == ENUMLOOKUP[-2087867454].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teParamId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-2087867454][msg.teParamId];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmPpnNakRsp" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "ParamId      : " << fnGetValue("ParamId") << " (" << fnGetRawValue("ParamId") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "ParamId") {
            return static_cast<uint32_t>(msg.teParamId);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ParamId") {
     int enumValue = findEnumValue(ENUMLOOKUP[-2087867454], value);
     if (enumValue != -1) msg.teParamId = static_cast<decltype(msg.teParamId)>(enumValue);
     else msg.teParamId = static_cast<decltype(msg.teParamId)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "ParamId") {
            return 1.0 * (long double)(msg.teParamId + 0.0);
        }
        return 0.0;
    }
} PmPpnNakRsp;

// Auto-generated class definition for RVC_tzPGN_PM_LITHIONICS_CMD
typedef struct PmLithionicsCmd : public MessageBase {
RVC_tzPGN_PM_LITHIONICS_CMD msg;
PmLithionicsCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
PmLithionicsCmd (void * pvStruct) {  msg = *(RVC_tzPGN_PM_LITHIONICS_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "Inst") {
            if (ENUMLOOKUP[421711928].find(msg.teInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teInst];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmLithionicsCmd" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.teInst);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Inst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teInst = static_cast<decltype(msg.teInst)>(enumValue);
     else msg.teInst = static_cast<decltype(msg.teInst)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "Inst") {
            return 1.0 * (long double)(msg.teInst + 0.0);
        }
        return 0.0;
    }
} PmLithionicsCmd;

// Auto-generated class definition for RVC_tzPGN_PM_LITHIONICS_STS
typedef struct PmLithionicsSts : public MessageBase {
RVC_tzPGN_PM_LITHIONICS_STS msg;
PmLithionicsSts () {  memset(&msg, 0xFF, sizeof(msg));  };
PmLithionicsSts (void * pvStruct) {  msg = *(RVC_tzPGN_PM_LITHIONICS_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            if (ENUMLOOKUP[1546979661].find(msg.teMsgId) == ENUMLOOKUP[1546979661].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teMsgId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1546979661][msg.teMsgId];
              }
        }
        else if (mnem == "Inst") {
            if (ENUMLOOKUP[421711928].find(msg.teInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teInst];
              }
        }
        else if (mnem == "MaxRecTemp") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucMaxRecTemp + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucMaxRecTemp == 0xff) ? "No Data" : (msg.ucMaxRecTemp == 0xfe) ? "Out of range" : (msg.ucMaxRecTemp == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "MinRecTemp") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucMinRecTemp + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucMinRecTemp == 0xff) ? "No Data" : (msg.ucMinRecTemp == 0xfe) ? "Out of range" : (msg.ucMinRecTemp == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "HighVoltageState") {
            if (ENUMLOOKUP[1608161778].find(msg.teHighVoltageState) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHighVoltageState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teHighVoltageState];
              }
        }
        else if (mnem == "ChgSrcDet") {
            if (ENUMLOOKUP[1608161778].find(msg.teChgSrcDet) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgSrcDet);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teChgSrcDet];
              }
        }
        else if (mnem == "NeverDieResState") {
            if (ENUMLOOKUP[1608161778].find(msg.teNeverDieResState) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teNeverDieResState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teNeverDieResState];
              }
        }
        else if (mnem == "OptoLoopOpen") {
            if (ENUMLOOKUP[1608161778].find(msg.teOptoLoopOpen) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOptoLoopOpen);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teOptoLoopOpen];
              }
        }
        else if (mnem == "ResVoltageRange") {
            if (ENUMLOOKUP[1608161778].find(msg.teResVoltageRange) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teResVoltageRange);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teResVoltageRange];
              }
        }
        else if (mnem == "LowVoltageState") {
            if (ENUMLOOKUP[1608161778].find(msg.teLowVoltageState) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowVoltageState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teLowVoltageState];
              }
        }
        else if (mnem == "BattProtState") {
            if (ENUMLOOKUP[1608161778].find(msg.teBattProtState) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattProtState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teBattProtState];
              }
        }
        else if (mnem == "PwrOffState") {
            if (ENUMLOOKUP[1608161778].find(msg.tePwrOffState) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.tePwrOffState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.tePwrOffState];
              }
        }
        else if (mnem == "AuxCntctState") {
            if (ENUMLOOKUP[1608161778].find(msg.teAuxCntctState) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAuxCntctState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teAuxCntctState];
              }
        }
        else if (mnem == "AuxCntctErr") {
            if (ENUMLOOKUP[1608161778].find(msg.teAuxCntctErr) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAuxCntctErr);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teAuxCntctErr];
              }
        }
        else if (mnem == "PreChgErr") {
            if (ENUMLOOKUP[1608161778].find(msg.tePreChgErr) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.tePreChgErr);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.tePreChgErr];
              }
        }
        else if (mnem == "CntctFlutter") {
            if (ENUMLOOKUP[1608161778].find(msg.teCntctFlutter) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCntctFlutter);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teCntctFlutter];
              }
        }
        else if (mnem == "AcPwrPres") {
            if (ENUMLOOKUP[1608161778].find(msg.teAcPwrPres) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAcPwrPres);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teAcPwrPres];
              }
        }
        else if (mnem == "TsmChgPres") {
            if (ENUMLOOKUP[1608161778].find(msg.teTsmChgPres) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teTsmChgPres);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teTsmChgPres];
              }
        }
        else if (mnem == "TsmChgErr") {
            if (ENUMLOOKUP[1608161778].find(msg.teTsmChgErr) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teTsmChgErr);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teTsmChgErr];
              }
        }
        else if (mnem == "TempInterSensErr") {
            if (ENUMLOOKUP[1608161778].find(msg.teTempInterSensErr) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teTempInterSensErr);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teTempInterSensErr];
              }
        }
        else if (mnem == "AgsrState") {
            if (ENUMLOOKUP[1608161778].find(msg.teAgsrState) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAgsrState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teAgsrState];
              }
        }
        else if (mnem == "HotTempState") {
            if (ENUMLOOKUP[1608161778].find(msg.teHotTempState) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHotTempState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teHotTempState];
              }
        }
        else if (mnem == "ColdTempState") {
            if (ENUMLOOKUP[1608161778].find(msg.teColdTempState) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teColdTempState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teColdTempState];
              }
        }
        else if (mnem == "AuxIn1State") {
            if (ENUMLOOKUP[1608161778].find(msg.teAuxIn1State) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAuxIn1State);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teAuxIn1State];
              }
        }
        else if (mnem == "ChgDisState") {
            if (ENUMLOOKUP[1608161778].find(msg.teChgDisState) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgDisState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teChgDisState];
              }
        }
        else if (mnem == "OverCurrState") {
            if (ENUMLOOKUP[1608161778].find(msg.teOverCurrState) == ENUMLOOKUP[1608161778].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOverCurrState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1608161778][msg.teOverCurrState];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: PmLithionicsSts" << std::endl;
        cout << "MsgId      : " << fnGetValue("MsgId") << " (" << fnGetRawValue("MsgId") << ")" << endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "MaxRecTemp      : " << fnGetValue("MaxRecTemp") << " (" << fnGetRawValue("MaxRecTemp") << ")" << endl;
        cout << "MinRecTemp      : " << fnGetValue("MinRecTemp") << " (" << fnGetRawValue("MinRecTemp") << ")" << endl;
        cout << "HighVoltageState      : " << fnGetValue("HighVoltageState") << " (" << fnGetRawValue("HighVoltageState") << ")" << endl;
        cout << "ChgSrcDet      : " << fnGetValue("ChgSrcDet") << " (" << fnGetRawValue("ChgSrcDet") << ")" << endl;
        cout << "NeverDieResState      : " << fnGetValue("NeverDieResState") << " (" << fnGetRawValue("NeverDieResState") << ")" << endl;
        cout << "OptoLoopOpen      : " << fnGetValue("OptoLoopOpen") << " (" << fnGetRawValue("OptoLoopOpen") << ")" << endl;
        cout << "ResVoltageRange      : " << fnGetValue("ResVoltageRange") << " (" << fnGetRawValue("ResVoltageRange") << ")" << endl;
        cout << "LowVoltageState      : " << fnGetValue("LowVoltageState") << " (" << fnGetRawValue("LowVoltageState") << ")" << endl;
        cout << "BattProtState      : " << fnGetValue("BattProtState") << " (" << fnGetRawValue("BattProtState") << ")" << endl;
        cout << "PwrOffState      : " << fnGetValue("PwrOffState") << " (" << fnGetRawValue("PwrOffState") << ")" << endl;
        cout << "AuxCntctState      : " << fnGetValue("AuxCntctState") << " (" << fnGetRawValue("AuxCntctState") << ")" << endl;
        cout << "AuxCntctErr      : " << fnGetValue("AuxCntctErr") << " (" << fnGetRawValue("AuxCntctErr") << ")" << endl;
        cout << "PreChgErr      : " << fnGetValue("PreChgErr") << " (" << fnGetRawValue("PreChgErr") << ")" << endl;
        cout << "CntctFlutter      : " << fnGetValue("CntctFlutter") << " (" << fnGetRawValue("CntctFlutter") << ")" << endl;
        cout << "AcPwrPres      : " << fnGetValue("AcPwrPres") << " (" << fnGetRawValue("AcPwrPres") << ")" << endl;
        cout << "TsmChgPres      : " << fnGetValue("TsmChgPres") << " (" << fnGetRawValue("TsmChgPres") << ")" << endl;
        cout << "TsmChgErr      : " << fnGetValue("TsmChgErr") << " (" << fnGetRawValue("TsmChgErr") << ")" << endl;
        cout << "TempInterSensErr      : " << fnGetValue("TempInterSensErr") << " (" << fnGetRawValue("TempInterSensErr") << ")" << endl;
        cout << "AgsrState      : " << fnGetValue("AgsrState") << " (" << fnGetRawValue("AgsrState") << ")" << endl;
        cout << "HotTempState      : " << fnGetValue("HotTempState") << " (" << fnGetRawValue("HotTempState") << ")" << endl;
        cout << "ColdTempState      : " << fnGetValue("ColdTempState") << " (" << fnGetRawValue("ColdTempState") << ")" << endl;
        cout << "AuxIn1State      : " << fnGetValue("AuxIn1State") << " (" << fnGetRawValue("AuxIn1State") << ")" << endl;
        cout << "ChgDisState      : " << fnGetValue("ChgDisState") << " (" << fnGetRawValue("ChgDisState") << ")" << endl;
        cout << "OverCurrState      : " << fnGetValue("OverCurrState") << " (" << fnGetRawValue("OverCurrState") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return static_cast<uint32_t>(msg.teMsgId);
        }
        else if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.teInst);
        }
        else if (mnem == "MaxRecTemp") {
            return static_cast<uint32_t>(msg.ucMaxRecTemp);
        }
        else if (mnem == "MinRecTemp") {
            return static_cast<uint32_t>(msg.ucMinRecTemp);
        }
        else if (mnem == "HighVoltageState") {
            return static_cast<uint32_t>(msg.teHighVoltageState);
        }
        else if (mnem == "ChgSrcDet") {
            return static_cast<uint32_t>(msg.teChgSrcDet);
        }
        else if (mnem == "NeverDieResState") {
            return static_cast<uint32_t>(msg.teNeverDieResState);
        }
        else if (mnem == "OptoLoopOpen") {
            return static_cast<uint32_t>(msg.teOptoLoopOpen);
        }
        else if (mnem == "ResVoltageRange") {
            return static_cast<uint32_t>(msg.teResVoltageRange);
        }
        else if (mnem == "LowVoltageState") {
            return static_cast<uint32_t>(msg.teLowVoltageState);
        }
        else if (mnem == "BattProtState") {
            return static_cast<uint32_t>(msg.teBattProtState);
        }
        else if (mnem == "PwrOffState") {
            return static_cast<uint32_t>(msg.tePwrOffState);
        }
        else if (mnem == "AuxCntctState") {
            return static_cast<uint32_t>(msg.teAuxCntctState);
        }
        else if (mnem == "AuxCntctErr") {
            return static_cast<uint32_t>(msg.teAuxCntctErr);
        }
        else if (mnem == "PreChgErr") {
            return static_cast<uint32_t>(msg.tePreChgErr);
        }
        else if (mnem == "CntctFlutter") {
            return static_cast<uint32_t>(msg.teCntctFlutter);
        }
        else if (mnem == "AcPwrPres") {
            return static_cast<uint32_t>(msg.teAcPwrPres);
        }
        else if (mnem == "TsmChgPres") {
            return static_cast<uint32_t>(msg.teTsmChgPres);
        }
        else if (mnem == "TsmChgErr") {
            return static_cast<uint32_t>(msg.teTsmChgErr);
        }
        else if (mnem == "TempInterSensErr") {
            return static_cast<uint32_t>(msg.teTempInterSensErr);
        }
        else if (mnem == "AgsrState") {
            return static_cast<uint32_t>(msg.teAgsrState);
        }
        else if (mnem == "HotTempState") {
            return static_cast<uint32_t>(msg.teHotTempState);
        }
        else if (mnem == "ColdTempState") {
            return static_cast<uint32_t>(msg.teColdTempState);
        }
        else if (mnem == "AuxIn1State") {
            return static_cast<uint32_t>(msg.teAuxIn1State);
        }
        else if (mnem == "ChgDisState") {
            return static_cast<uint32_t>(msg.teChgDisState);
        }
        else if (mnem == "OverCurrState") {
            return static_cast<uint32_t>(msg.teOverCurrState);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1546979661], value);
     if (enumValue != -1) msg.teMsgId = static_cast<decltype(msg.teMsgId)>(enumValue);
     else msg.teMsgId = static_cast<decltype(msg.teMsgId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Inst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teInst = static_cast<decltype(msg.teInst)>(enumValue);
     else msg.teInst = static_cast<decltype(msg.teInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "MaxRecTemp") {
     msg.ucMaxRecTemp = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
        else if (mnem == "MinRecTemp") {
     msg.ucMinRecTemp = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
        else if (mnem == "HighVoltageState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teHighVoltageState = static_cast<decltype(msg.teHighVoltageState)>(enumValue);
     else msg.teHighVoltageState = static_cast<decltype(msg.teHighVoltageState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgSrcDet") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teChgSrcDet = static_cast<decltype(msg.teChgSrcDet)>(enumValue);
     else msg.teChgSrcDet = static_cast<decltype(msg.teChgSrcDet)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "NeverDieResState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teNeverDieResState = static_cast<decltype(msg.teNeverDieResState)>(enumValue);
     else msg.teNeverDieResState = static_cast<decltype(msg.teNeverDieResState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OptoLoopOpen") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teOptoLoopOpen = static_cast<decltype(msg.teOptoLoopOpen)>(enumValue);
     else msg.teOptoLoopOpen = static_cast<decltype(msg.teOptoLoopOpen)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ResVoltageRange") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teResVoltageRange = static_cast<decltype(msg.teResVoltageRange)>(enumValue);
     else msg.teResVoltageRange = static_cast<decltype(msg.teResVoltageRange)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowVoltageState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teLowVoltageState = static_cast<decltype(msg.teLowVoltageState)>(enumValue);
     else msg.teLowVoltageState = static_cast<decltype(msg.teLowVoltageState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattProtState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teBattProtState = static_cast<decltype(msg.teBattProtState)>(enumValue);
     else msg.teBattProtState = static_cast<decltype(msg.teBattProtState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PwrOffState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.tePwrOffState = static_cast<decltype(msg.tePwrOffState)>(enumValue);
     else msg.tePwrOffState = static_cast<decltype(msg.tePwrOffState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AuxCntctState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teAuxCntctState = static_cast<decltype(msg.teAuxCntctState)>(enumValue);
     else msg.teAuxCntctState = static_cast<decltype(msg.teAuxCntctState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AuxCntctErr") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teAuxCntctErr = static_cast<decltype(msg.teAuxCntctErr)>(enumValue);
     else msg.teAuxCntctErr = static_cast<decltype(msg.teAuxCntctErr)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PreChgErr") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.tePreChgErr = static_cast<decltype(msg.tePreChgErr)>(enumValue);
     else msg.tePreChgErr = static_cast<decltype(msg.tePreChgErr)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CntctFlutter") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teCntctFlutter = static_cast<decltype(msg.teCntctFlutter)>(enumValue);
     else msg.teCntctFlutter = static_cast<decltype(msg.teCntctFlutter)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AcPwrPres") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teAcPwrPres = static_cast<decltype(msg.teAcPwrPres)>(enumValue);
     else msg.teAcPwrPres = static_cast<decltype(msg.teAcPwrPres)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "TsmChgPres") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teTsmChgPres = static_cast<decltype(msg.teTsmChgPres)>(enumValue);
     else msg.teTsmChgPres = static_cast<decltype(msg.teTsmChgPres)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "TsmChgErr") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teTsmChgErr = static_cast<decltype(msg.teTsmChgErr)>(enumValue);
     else msg.teTsmChgErr = static_cast<decltype(msg.teTsmChgErr)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "TempInterSensErr") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teTempInterSensErr = static_cast<decltype(msg.teTempInterSensErr)>(enumValue);
     else msg.teTempInterSensErr = static_cast<decltype(msg.teTempInterSensErr)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AgsrState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teAgsrState = static_cast<decltype(msg.teAgsrState)>(enumValue);
     else msg.teAgsrState = static_cast<decltype(msg.teAgsrState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HotTempState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teHotTempState = static_cast<decltype(msg.teHotTempState)>(enumValue);
     else msg.teHotTempState = static_cast<decltype(msg.teHotTempState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ColdTempState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teColdTempState = static_cast<decltype(msg.teColdTempState)>(enumValue);
     else msg.teColdTempState = static_cast<decltype(msg.teColdTempState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AuxIn1State") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teAuxIn1State = static_cast<decltype(msg.teAuxIn1State)>(enumValue);
     else msg.teAuxIn1State = static_cast<decltype(msg.teAuxIn1State)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgDisState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teChgDisState = static_cast<decltype(msg.teChgDisState)>(enumValue);
     else msg.teChgDisState = static_cast<decltype(msg.teChgDisState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OverCurrState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1608161778], value);
     if (enumValue != -1) msg.teOverCurrState = static_cast<decltype(msg.teOverCurrState)>(enumValue);
     else msg.teOverCurrState = static_cast<decltype(msg.teOverCurrState)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgId") {
            return 1.0 * (long double)(msg.teMsgId + 0.0);
        }
        else if (mnem == "Inst") {
            return 1.0 * (long double)(msg.teInst + 0.0);
        }
        else if (mnem == "MaxRecTemp") {
            return 1.0 * (long double)(msg.ucMaxRecTemp + -40.0);
        }
        else if (mnem == "MinRecTemp") {
            return 1.0 * (long double)(msg.ucMinRecTemp + -40.0);
        }
        else if (mnem == "HighVoltageState") {
            return 1.0 * (long double)(msg.teHighVoltageState + 0.0);
        }
        else if (mnem == "ChgSrcDet") {
            return 1.0 * (long double)(msg.teChgSrcDet + 0.0);
        }
        else if (mnem == "NeverDieResState") {
            return 1.0 * (long double)(msg.teNeverDieResState + 0.0);
        }
        else if (mnem == "OptoLoopOpen") {
            return 1.0 * (long double)(msg.teOptoLoopOpen + 0.0);
        }
        else if (mnem == "ResVoltageRange") {
            return 1.0 * (long double)(msg.teResVoltageRange + 0.0);
        }
        else if (mnem == "LowVoltageState") {
            return 1.0 * (long double)(msg.teLowVoltageState + 0.0);
        }
        else if (mnem == "BattProtState") {
            return 1.0 * (long double)(msg.teBattProtState + 0.0);
        }
        else if (mnem == "PwrOffState") {
            return 1.0 * (long double)(msg.tePwrOffState + 0.0);
        }
        else if (mnem == "AuxCntctState") {
            return 1.0 * (long double)(msg.teAuxCntctState + 0.0);
        }
        else if (mnem == "AuxCntctErr") {
            return 1.0 * (long double)(msg.teAuxCntctErr + 0.0);
        }
        else if (mnem == "PreChgErr") {
            return 1.0 * (long double)(msg.tePreChgErr + 0.0);
        }
        else if (mnem == "CntctFlutter") {
            return 1.0 * (long double)(msg.teCntctFlutter + 0.0);
        }
        else if (mnem == "AcPwrPres") {
            return 1.0 * (long double)(msg.teAcPwrPres + 0.0);
        }
        else if (mnem == "TsmChgPres") {
            return 1.0 * (long double)(msg.teTsmChgPres + 0.0);
        }
        else if (mnem == "TsmChgErr") {
            return 1.0 * (long double)(msg.teTsmChgErr + 0.0);
        }
        else if (mnem == "TempInterSensErr") {
            return 1.0 * (long double)(msg.teTempInterSensErr + 0.0);
        }
        else if (mnem == "AgsrState") {
            return 1.0 * (long double)(msg.teAgsrState + 0.0);
        }
        else if (mnem == "HotTempState") {
            return 1.0 * (long double)(msg.teHotTempState + 0.0);
        }
        else if (mnem == "ColdTempState") {
            return 1.0 * (long double)(msg.teColdTempState + 0.0);
        }
        else if (mnem == "AuxIn1State") {
            return 1.0 * (long double)(msg.teAuxIn1State + 0.0);
        }
        else if (mnem == "ChgDisState") {
            return 1.0 * (long double)(msg.teChgDisState + 0.0);
        }
        else if (mnem == "OverCurrState") {
            return 1.0 * (long double)(msg.teOverCurrState + 0.0);
        }
        return 0.0;
    }
} PmLithionicsSts;

// Auto-generated class definition for RVC_tzPGN_ISO_CMD_ADDR
typedef struct IsoCmdAddr : public MessageBase {
RVC_tzPGN_ISO_CMD_ADDR msg;
IsoCmdAddr () {  memset(&msg, 0xFF, sizeof(msg));  };
IsoCmdAddr (void * pvStruct) {  msg = *(RVC_tzPGN_ISO_CMD_ADDR *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "UniqueNumber") {
            return std::to_string(msg.ulUniqueNumber);
        }
        else if (mnem == "ManufacturerCode") {
            return std::to_string(msg.uiManufacturerCode);
        }
        else if (mnem == "DeviceInstanceLower") {
            return std::to_string(msg.ucDeviceInstanceLower);
        }
        else if (mnem == "DeviceInstanceUpper") {
            return std::to_string(msg.ucDeviceInstanceUpper);
        }
        else if (mnem == "DeviceFunction") {
            if (ENUMLOOKUP[9001].find(msg.teDeviceFunction) == ENUMLOOKUP[9001].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDeviceFunction);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9001][msg.teDeviceFunction];
              }
        }
        else if (mnem == "RsvBit") {
            return std::to_string(msg.ucRsvBit);
        }
        else if (mnem == "DeviceClass") {
            if (ENUMLOOKUP[9002].find(msg.teDeviceClass) == ENUMLOOKUP[9002].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDeviceClass);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9002][msg.teDeviceClass];
              }
        }
        else if (mnem == "SystemInstance") {
            return std::to_string(msg.ucSystemInstance);
        }
        else if (mnem == "IndustryGroup") {
            if (ENUMLOOKUP[8989].find(msg.teIndustryGroup) == ENUMLOOKUP[8989].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teIndustryGroup);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[8989][msg.teIndustryGroup];
              }
        }
        else if (mnem == "SelfCfgAddr") {
            return std::to_string(msg.ucSelfCfgAddr);
        }
        else if (mnem == "PrefSrcAddr") {
            if (ENUMLOOKUP[8982].find(msg.tePrefSrcAddr) == ENUMLOOKUP[8982].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.tePrefSrcAddr);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[8982][msg.tePrefSrcAddr];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: IsoCmdAddr" << std::endl;
        cout << "UniqueNumber      : " << fnGetValue("UniqueNumber") << " (" << fnGetRawValue("UniqueNumber") << ")" << endl;
        cout << "ManufacturerCode      : " << fnGetValue("ManufacturerCode") << " (" << fnGetRawValue("ManufacturerCode") << ")" << endl;
        cout << "DeviceInstanceLower      : " << fnGetValue("DeviceInstanceLower") << " (" << fnGetRawValue("DeviceInstanceLower") << ")" << endl;
        cout << "DeviceInstanceUpper      : " << fnGetValue("DeviceInstanceUpper") << " (" << fnGetRawValue("DeviceInstanceUpper") << ")" << endl;
        cout << "DeviceFunction      : " << fnGetValue("DeviceFunction") << " (" << fnGetRawValue("DeviceFunction") << ")" << endl;
        cout << "RsvBit      : " << fnGetValue("RsvBit") << " (" << fnGetRawValue("RsvBit") << ")" << endl;
        cout << "DeviceClass      : " << fnGetValue("DeviceClass") << " (" << fnGetRawValue("DeviceClass") << ")" << endl;
        cout << "SystemInstance      : " << fnGetValue("SystemInstance") << " (" << fnGetRawValue("SystemInstance") << ")" << endl;
        cout << "IndustryGroup      : " << fnGetValue("IndustryGroup") << " (" << fnGetRawValue("IndustryGroup") << ")" << endl;
        cout << "SelfCfgAddr      : " << fnGetValue("SelfCfgAddr") << " (" << fnGetRawValue("SelfCfgAddr") << ")" << endl;
        cout << "PrefSrcAddr      : " << fnGetValue("PrefSrcAddr") << " (" << fnGetRawValue("PrefSrcAddr") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "UniqueNumber") {
            return static_cast<uint32_t>(msg.ulUniqueNumber);
        }
        else if (mnem == "ManufacturerCode") {
            return static_cast<uint32_t>(msg.uiManufacturerCode);
        }
        else if (mnem == "DeviceInstanceLower") {
            return static_cast<uint32_t>(msg.ucDeviceInstanceLower);
        }
        else if (mnem == "DeviceInstanceUpper") {
            return static_cast<uint32_t>(msg.ucDeviceInstanceUpper);
        }
        else if (mnem == "DeviceFunction") {
            return static_cast<uint32_t>(msg.teDeviceFunction);
        }
        else if (mnem == "RsvBit") {
            return static_cast<uint32_t>(msg.ucRsvBit);
        }
        else if (mnem == "DeviceClass") {
            return static_cast<uint32_t>(msg.teDeviceClass);
        }
        else if (mnem == "SystemInstance") {
            return static_cast<uint32_t>(msg.ucSystemInstance);
        }
        else if (mnem == "IndustryGroup") {
            return static_cast<uint32_t>(msg.teIndustryGroup);
        }
        else if (mnem == "SelfCfgAddr") {
            return static_cast<uint32_t>(msg.ucSelfCfgAddr);
        }
        else if (mnem == "PrefSrcAddr") {
            return static_cast<uint32_t>(msg.tePrefSrcAddr);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "UniqueNumber") {
     msg.ulUniqueNumber = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ManufacturerCode") {
     msg.uiManufacturerCode = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DeviceInstanceLower") {
     msg.ucDeviceInstanceLower = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DeviceInstanceUpper") {
     msg.ucDeviceInstanceUpper = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DeviceFunction") {
     int enumValue = findEnumValue(ENUMLOOKUP[9001], value);
     if (enumValue != -1) msg.teDeviceFunction = static_cast<decltype(msg.teDeviceFunction)>(enumValue);
     else msg.teDeviceFunction = static_cast<decltype(msg.teDeviceFunction)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RsvBit") {
     msg.ucRsvBit = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DeviceClass") {
     int enumValue = findEnumValue(ENUMLOOKUP[9002], value);
     if (enumValue != -1) msg.teDeviceClass = static_cast<decltype(msg.teDeviceClass)>(enumValue);
     else msg.teDeviceClass = static_cast<decltype(msg.teDeviceClass)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SystemInstance") {
     msg.ucSystemInstance = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "IndustryGroup") {
     int enumValue = findEnumValue(ENUMLOOKUP[8989], value);
     if (enumValue != -1) msg.teIndustryGroup = static_cast<decltype(msg.teIndustryGroup)>(enumValue);
     else msg.teIndustryGroup = static_cast<decltype(msg.teIndustryGroup)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SelfCfgAddr") {
     msg.ucSelfCfgAddr = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "PrefSrcAddr") {
     int enumValue = findEnumValue(ENUMLOOKUP[8982], value);
     if (enumValue != -1) msg.tePrefSrcAddr = static_cast<decltype(msg.tePrefSrcAddr)>(enumValue);
     else msg.tePrefSrcAddr = static_cast<decltype(msg.tePrefSrcAddr)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "UniqueNumber") {
            return 1.0 * (long double)(msg.ulUniqueNumber + 0.0);
        }
        else if (mnem == "ManufacturerCode") {
            return 1.0 * (long double)(msg.uiManufacturerCode + 0.0);
        }
        else if (mnem == "DeviceInstanceLower") {
            return 1.0 * (long double)(msg.ucDeviceInstanceLower + 0.0);
        }
        else if (mnem == "DeviceInstanceUpper") {
            return 1.0 * (long double)(msg.ucDeviceInstanceUpper + 0.0);
        }
        else if (mnem == "DeviceFunction") {
            return 1.0 * (long double)(msg.teDeviceFunction + 0.0);
        }
        else if (mnem == "RsvBit") {
            return 1.0 * (long double)(msg.ucRsvBit + 0.0);
        }
        else if (mnem == "DeviceClass") {
            return 1.0 * (long double)(msg.teDeviceClass + 0.0);
        }
        else if (mnem == "SystemInstance") {
            return 1.0 * (long double)(msg.ucSystemInstance + 0.0);
        }
        else if (mnem == "IndustryGroup") {
            return 1.0 * (long double)(msg.teIndustryGroup + 0.0);
        }
        else if (mnem == "SelfCfgAddr") {
            return 1.0 * (long double)(msg.ucSelfCfgAddr + 0.0);
        }
        else if (mnem == "PrefSrcAddr") {
            return 1.0 * (long double)(msg.tePrefSrcAddr + 0.0);
        }
        return 0.0;
    }
} IsoCmdAddr;

// Auto-generated class definition for RVC_tzPGN_XB_RESET_CMD
typedef struct XbResetCmd : public MessageBase {
RVC_tzPGN_XB_RESET_CMD msg;
XbResetCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
XbResetCmd (void * pvStruct) {  msg = *(RVC_tzPGN_XB_RESET_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "ProcessorInst") {
            return std::to_string(msg.ucProcessorInst);
        }
        else if (mnem == "Cmd") {
            if (ENUMLOOKUP[2027188828].find(msg.teCmd) == ENUMLOOKUP[2027188828].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCmd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2027188828][msg.teCmd];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: XbResetCmd" << std::endl;
        cout << "ProcessorInst      : " << fnGetValue("ProcessorInst") << " (" << fnGetRawValue("ProcessorInst") << ")" << endl;
        cout << "Cmd      : " << fnGetValue("Cmd") << " (" << fnGetRawValue("Cmd") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "ProcessorInst") {
            return static_cast<uint32_t>(msg.ucProcessorInst);
        }
        else if (mnem == "Cmd") {
            return static_cast<uint32_t>(msg.teCmd);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "ProcessorInst") {
     msg.ucProcessorInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Cmd") {
     int enumValue = findEnumValue(ENUMLOOKUP[2027188828], value);
     if (enumValue != -1) msg.teCmd = static_cast<decltype(msg.teCmd)>(enumValue);
     else msg.teCmd = static_cast<decltype(msg.teCmd)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "ProcessorInst") {
            return 1.0 * (long double)(msg.ucProcessorInst + 0.0);
        }
        else if (mnem == "Cmd") {
            return 1.0 * (long double)(msg.teCmd + 0.0);
        }
        return 0.0;
    }
} XbResetCmd;

// Auto-generated class definition for RVC_tzPGN_FILE_DNLD_INF
typedef struct FileDnldInf : public MessageBase {
RVC_tzPGN_FILE_DNLD_INF msg;
FileDnldInf () {  memset(&msg, 0xFF, sizeof(msg));  };
FileDnldInf (void * pvStruct) {  msg = *(RVC_tzPGN_FILE_DNLD_INF *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "DeviceFunction") {
            if (ENUMLOOKUP[9001].find(msg.teDeviceFunction) == ENUMLOOKUP[9001].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDeviceFunction);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9001][msg.teDeviceFunction];
              }
        }
        else if (mnem == "ProcessorInst") {
            return std::to_string(msg.ucProcessorInst);
        }
        else if (mnem == "SwModId") {
            if (ENUMLOOKUP[535997516].find(msg.teSwModId) == ENUMLOOKUP[535997516].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teSwModId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[535997516][msg.teSwModId];
              }
        }
        else if (mnem == "SwVer") {
            return (msg.ulSwVer == 0xffffffff) ? "No Data" : (msg.ulSwVer == 0xfffffffe) ? "Out of range" : (msg.ulSwVer == 0xfffffffd) ? "Reserved" : std::to_string(msg.ulSwVer);
        }
        else if (mnem == "FileSz") {
            return (msg.ulFileSz == 0xffffffff) ? "No Data" : (msg.ulFileSz == 0xfffffffe) ? "Out of range" : (msg.ulFileSz == 0xfffffffd) ? "Reserved" : std::to_string(msg.ulFileSz);
        }
        else if (mnem == "Crc") {
            return (msg.uiCrc == 0xffff) ? "No Data" : (msg.uiCrc == 0xfffe) ? "Out of range" : (msg.uiCrc == 0xfffd) ? "Reserved" : std::to_string(msg.uiCrc);
        }
        else if (mnem == "ExpectNumBlks") {
            return (msg.uiExpectNumBlks == 0xffff) ? "No Data" : (msg.uiExpectNumBlks == 0xfffe) ? "Out of range" : (msg.uiExpectNumBlks == 0xfffd) ? "Reserved" : std::to_string(msg.uiExpectNumBlks);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: FileDnldInf" << std::endl;
        cout << "DeviceFunction      : " << fnGetValue("DeviceFunction") << " (" << fnGetRawValue("DeviceFunction") << ")" << endl;
        cout << "ProcessorInst      : " << fnGetValue("ProcessorInst") << " (" << fnGetRawValue("ProcessorInst") << ")" << endl;
        cout << "SwModId      : " << fnGetValue("SwModId") << " (" << fnGetRawValue("SwModId") << ")" << endl;
        cout << "SwVer      : " << fnGetValue("SwVer") << " (" << fnGetRawValue("SwVer") << ")" << endl;
        cout << "FileSz      : " << fnGetValue("FileSz") << " (" << fnGetRawValue("FileSz") << ")" << endl;
        cout << "Crc      : " << fnGetValue("Crc") << " (" << fnGetRawValue("Crc") << ")" << endl;
        cout << "ExpectNumBlks      : " << fnGetValue("ExpectNumBlks") << " (" << fnGetRawValue("ExpectNumBlks") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "DeviceFunction") {
            return static_cast<uint32_t>(msg.teDeviceFunction);
        }
        else if (mnem == "ProcessorInst") {
            return static_cast<uint32_t>(msg.ucProcessorInst);
        }
        else if (mnem == "SwModId") {
            return static_cast<uint32_t>(msg.teSwModId);
        }
        else if (mnem == "SwVer") {
            return static_cast<uint32_t>(msg.ulSwVer);
        }
        else if (mnem == "FileSz") {
            return static_cast<uint32_t>(msg.ulFileSz);
        }
        else if (mnem == "Crc") {
            return static_cast<uint32_t>(msg.uiCrc);
        }
        else if (mnem == "ExpectNumBlks") {
            return static_cast<uint32_t>(msg.uiExpectNumBlks);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "DeviceFunction") {
     int enumValue = findEnumValue(ENUMLOOKUP[9001], value);
     if (enumValue != -1) msg.teDeviceFunction = static_cast<decltype(msg.teDeviceFunction)>(enumValue);
     else msg.teDeviceFunction = static_cast<decltype(msg.teDeviceFunction)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ProcessorInst") {
     msg.ucProcessorInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "SwModId") {
     int enumValue = findEnumValue(ENUMLOOKUP[535997516], value);
     if (enumValue != -1) msg.teSwModId = static_cast<decltype(msg.teSwModId)>(enumValue);
     else msg.teSwModId = static_cast<decltype(msg.teSwModId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SwVer") {
     msg.ulSwVer = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd);
        }
        else if (mnem == "FileSz") {
     msg.ulFileSz = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd);
        }
        else if (mnem == "Crc") {
     msg.uiCrc = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "ExpectNumBlks") {
     msg.uiExpectNumBlks = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "DeviceFunction") {
            return 1.0 * (long double)(msg.teDeviceFunction + 0.0);
        }
        else if (mnem == "ProcessorInst") {
            return 1.0 * (long double)(msg.ucProcessorInst + 0.0);
        }
        else if (mnem == "SwModId") {
            return 1.0 * (long double)(msg.teSwModId + 0.0);
        }
        else if (mnem == "SwVer") {
            return 1.0 * (long double)(msg.ulSwVer + 0.0);
        }
        else if (mnem == "FileSz") {
            return 1.0 * (long double)(msg.ulFileSz + 0.0);
        }
        else if (mnem == "Crc") {
            return 1.0 * (long double)(msg.uiCrc + 0.0);
        }
        else if (mnem == "ExpectNumBlks") {
            return 1.0 * (long double)(msg.uiExpectNumBlks + 0.0);
        }
        return 0.0;
    }
} FileDnldInf;

// Auto-generated class definition for RVC_tzPGN_SIMPLE_CALIB_CFG
typedef struct SimpleCalibCfg : public MessageBase {
RVC_tzPGN_SIMPLE_CALIB_CFG msg;
SimpleCalibCfg () {  memset(&msg, 0xFF, sizeof(msg));  };
SimpleCalibCfg (void * pvStruct) {  msg = *(RVC_tzPGN_SIMPLE_CALIB_CFG *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "RsvBits") {
            return std::to_string(msg.ucRsvBits);
        }
        else if (mnem == "MsgCount") {
            return std::to_string(msg.ucMsgCount);
        }
        else if (mnem == "StsPgn") {
            return std::to_string(msg.ulStsPgn);
        }
        else if (mnem == "DataPtId") {
            if (ENUMLOOKUP[1558143328].find(msg.teDataPtId) == ENUMLOOKUP[1558143328].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDataPtId);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1558143328][msg.teDataPtId];
              }
        }
        else if (mnem == "Scale") {
            return (msg.uiScale == 0xffff) ? "No Data" : (msg.uiScale == 0xfffe) ? "Out of range" : (msg.uiScale == 0xfffd) ? "Reserved" : std::to_string(msg.uiScale);
        }
        else if (mnem == "Offset") {
            return (msg.uiOffset == 0xffff) ? "No Data" : (msg.uiOffset == 0xfffe) ? "Out of range" : (msg.uiOffset == 0xfffd) ? "Reserved" : std::to_string(msg.uiOffset);
        }
        else if (mnem == "Value") {
            return (msg.ulValue == 0xffffffff) ? "No Data" : (msg.ulValue == 0xfffffffe) ? "Out of range" : (msg.ulValue == 0xfffffffd) ? "Reserved" : std::to_string(msg.ulValue);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SimpleCalibCfg" << std::endl;
        cout << "RsvBits      : " << fnGetValue("RsvBits") << " (" << fnGetRawValue("RsvBits") << ")" << endl;
        cout << "MsgCount      : " << fnGetValue("MsgCount") << " (" << fnGetRawValue("MsgCount") << ")" << endl;
        cout << "StsPgn      : " << fnGetValue("StsPgn") << " (" << fnGetRawValue("StsPgn") << ")" << endl;
        cout << "DataPtId      : " << fnGetValue("DataPtId") << " (" << fnGetRawValue("DataPtId") << ")" << endl;
        cout << "Scale      : " << fnGetValue("Scale") << " (" << fnGetRawValue("Scale") << ")" << endl;
        cout << "Offset      : " << fnGetValue("Offset") << " (" << fnGetRawValue("Offset") << ")" << endl;
        cout << "Value      : " << fnGetValue("Value") << " (" << fnGetRawValue("Value") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "RsvBits") {
            return static_cast<uint32_t>(msg.ucRsvBits);
        }
        else if (mnem == "MsgCount") {
            return static_cast<uint32_t>(msg.ucMsgCount);
        }
        else if (mnem == "StsPgn") {
            return static_cast<uint32_t>(msg.ulStsPgn);
        }
        else if (mnem == "DataPtId") {
            return static_cast<uint32_t>(msg.teDataPtId);
        }
        else if (mnem == "Scale") {
            return static_cast<uint32_t>(msg.uiScale);
        }
        else if (mnem == "Offset") {
            return static_cast<uint32_t>(msg.uiOffset);
        }
        else if (mnem == "Value") {
            return static_cast<uint32_t>(msg.ulValue);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "RsvBits") {
     msg.ucRsvBits = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "MsgCount") {
     msg.ucMsgCount = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "StsPgn") {
     msg.ulStsPgn = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DataPtId") {
     int enumValue = findEnumValue(ENUMLOOKUP[1558143328], value);
     if (enumValue != -1) msg.teDataPtId = static_cast<decltype(msg.teDataPtId)>(enumValue);
     else msg.teDataPtId = static_cast<decltype(msg.teDataPtId)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Scale") {
     msg.uiScale = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "Offset") {
     msg.uiOffset = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "Value") {
     msg.ulValue = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "RsvBits") {
            return 1.0 * (long double)(msg.ucRsvBits + 0.0);
        }
        else if (mnem == "MsgCount") {
            return 1.0 * (long double)(msg.ucMsgCount + 0.0);
        }
        else if (mnem == "StsPgn") {
            return 1.0 * (long double)(msg.ulStsPgn + 0.0);
        }
        else if (mnem == "DataPtId") {
            return 1.0 * (long double)(msg.teDataPtId + 0.0);
        }
        else if (mnem == "Scale") {
            return 1.0 * (long double)(msg.uiScale + 0.0);
        }
        else if (mnem == "Offset") {
            return 1.0 * (long double)(msg.uiOffset + 0.0);
        }
        else if (mnem == "Value") {
            return 1.0 * (long double)(msg.ulValue + 0.0);
        }
        return 0.0;
    }
} SimpleCalibCfg;

// Auto-generated class definition for RVC_tzPGN_FILE_DNLD_STS
typedef struct FileDnldSts : public MessageBase {
RVC_tzPGN_FILE_DNLD_STS msg;
FileDnldSts () {  memset(&msg, 0xFF, sizeof(msg));  };
FileDnldSts (void * pvStruct) {  msg = *(RVC_tzPGN_FILE_DNLD_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "OpState") {
            if (ENUMLOOKUP[101476251].find(msg.teOpState) == ENUMLOOKUP[101476251].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOpState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[101476251][msg.teOpState];
              }
        }
        else if (mnem == "ResultCode") {
            if (ENUMLOOKUP[1426290752].find(msg.teResultCode) == ENUMLOOKUP[1426290752].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teResultCode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1426290752][msg.teResultCode];
              }
        }
        else if (mnem == "ProcessorInst") {
            return std::to_string(msg.ucProcessorInst);
        }
        else if (mnem == "ModelNum") {
            return (msg.uiModelNum == 0xffff) ? "No Data" : (msg.uiModelNum == 0xfffe) ? "Out of range" : (msg.uiModelNum == 0xfffd) ? "Reserved" : std::to_string(msg.uiModelNum);
        }
        else if (mnem == "HwModRev") {
            return (msg.uiHwModRev == 0xffff) ? "No Data" : (msg.uiHwModRev == 0xfffe) ? "Out of range" : (msg.uiHwModRev == 0xfffd) ? "Reserved" : std::to_string(msg.uiHwModRev);
        }
        else if (mnem == "BlkNum") {
            return (msg.uiBlkNum == 0xffff) ? "No Data" : (msg.uiBlkNum == 0xfffe) ? "Out of range" : (msg.uiBlkNum == 0xfffd) ? "Reserved" : std::to_string(msg.uiBlkNum);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: FileDnldSts" << std::endl;
        cout << "OpState      : " << fnGetValue("OpState") << " (" << fnGetRawValue("OpState") << ")" << endl;
        cout << "ResultCode      : " << fnGetValue("ResultCode") << " (" << fnGetRawValue("ResultCode") << ")" << endl;
        cout << "ProcessorInst      : " << fnGetValue("ProcessorInst") << " (" << fnGetRawValue("ProcessorInst") << ")" << endl;
        cout << "ModelNum      : " << fnGetValue("ModelNum") << " (" << fnGetRawValue("ModelNum") << ")" << endl;
        cout << "HwModRev      : " << fnGetValue("HwModRev") << " (" << fnGetRawValue("HwModRev") << ")" << endl;
        cout << "BlkNum      : " << fnGetValue("BlkNum") << " (" << fnGetRawValue("BlkNum") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "OpState") {
            return static_cast<uint32_t>(msg.teOpState);
        }
        else if (mnem == "ResultCode") {
            return static_cast<uint32_t>(msg.teResultCode);
        }
        else if (mnem == "ProcessorInst") {
            return static_cast<uint32_t>(msg.ucProcessorInst);
        }
        else if (mnem == "ModelNum") {
            return static_cast<uint32_t>(msg.uiModelNum);
        }
        else if (mnem == "HwModRev") {
            return static_cast<uint32_t>(msg.uiHwModRev);
        }
        else if (mnem == "BlkNum") {
            return static_cast<uint32_t>(msg.uiBlkNum);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "OpState") {
     int enumValue = findEnumValue(ENUMLOOKUP[101476251], value);
     if (enumValue != -1) msg.teOpState = static_cast<decltype(msg.teOpState)>(enumValue);
     else msg.teOpState = static_cast<decltype(msg.teOpState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ResultCode") {
     int enumValue = findEnumValue(ENUMLOOKUP[1426290752], value);
     if (enumValue != -1) msg.teResultCode = static_cast<decltype(msg.teResultCode)>(enumValue);
     else msg.teResultCode = static_cast<decltype(msg.teResultCode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ProcessorInst") {
     msg.ucProcessorInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ModelNum") {
     msg.uiModelNum = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "HwModRev") {
     msg.uiHwModRev = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "BlkNum") {
     msg.uiBlkNum = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "OpState") {
            return 1.0 * (long double)(msg.teOpState + 0.0);
        }
        else if (mnem == "ResultCode") {
            return 1.0 * (long double)(msg.teResultCode + 0.0);
        }
        else if (mnem == "ProcessorInst") {
            return 1.0 * (long double)(msg.ucProcessorInst + 0.0);
        }
        else if (mnem == "ModelNum") {
            return 1.0 * (long double)(msg.uiModelNum + 0.0);
        }
        else if (mnem == "HwModRev") {
            return 1.0 * (long double)(msg.uiHwModRev + 0.0);
        }
        else if (mnem == "BlkNum") {
            return 1.0 * (long double)(msg.uiBlkNum + 0.0);
        }
        return 0.0;
    }
} FileDnldSts;

// Auto-generated class definition for RVC_tzPGN_INST_STS
typedef struct InstSts : public MessageBase {
RVC_tzPGN_INST_STS msg;
InstSts () {  memset(&msg, 0xFF, sizeof(msg));  };
InstSts (void * pvStruct) {  msg = *(RVC_tzPGN_INST_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "DevType") {
            if (ENUMLOOKUP[8982].find(msg.teDevType) == ENUMLOOKUP[8982].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDevType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[8982][msg.teDevType];
              }
        }
        else if (mnem == "BaseInst") {
            return (msg.ucBaseInst == 0xff) ? "No Data" : (msg.ucBaseInst == 0xfe) ? "Out of range" : (msg.ucBaseInst == 0xfd) ? "Reserved" : std::to_string(msg.ucBaseInst);
        }
        else if (mnem == "MaxInst") {
            return (msg.ucMaxInst == 0xff) ? "No Data" : (msg.ucMaxInst == 0xfe) ? "Out of range" : (msg.ucMaxInst == 0xfd) ? "Reserved" : std::to_string(msg.ucMaxInst);
        }
        else if (mnem == "BaseIntAddr") {
            return (msg.uiBaseIntAddr == 0xffff) ? "No Data" : (msg.uiBaseIntAddr == 0xfffe) ? "Out of range" : (msg.uiBaseIntAddr == 0xfffd) ? "Reserved" : std::to_string(msg.uiBaseIntAddr);
        }
        else if (mnem == "MaxIntAddr") {
            return (msg.uiMaxIntAddr == 0xffff) ? "No Data" : (msg.uiMaxIntAddr == 0xfffe) ? "Out of range" : (msg.uiMaxIntAddr == 0xfffd) ? "Reserved" : std::to_string(msg.uiMaxIntAddr);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InstSts" << std::endl;
        cout << "DevType      : " << fnGetValue("DevType") << " (" << fnGetRawValue("DevType") << ")" << endl;
        cout << "BaseInst      : " << fnGetValue("BaseInst") << " (" << fnGetRawValue("BaseInst") << ")" << endl;
        cout << "MaxInst      : " << fnGetValue("MaxInst") << " (" << fnGetRawValue("MaxInst") << ")" << endl;
        cout << "BaseIntAddr      : " << fnGetValue("BaseIntAddr") << " (" << fnGetRawValue("BaseIntAddr") << ")" << endl;
        cout << "MaxIntAddr      : " << fnGetValue("MaxIntAddr") << " (" << fnGetRawValue("MaxIntAddr") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "DevType") {
            return static_cast<uint32_t>(msg.teDevType);
        }
        else if (mnem == "BaseInst") {
            return static_cast<uint32_t>(msg.ucBaseInst);
        }
        else if (mnem == "MaxInst") {
            return static_cast<uint32_t>(msg.ucMaxInst);
        }
        else if (mnem == "BaseIntAddr") {
            return static_cast<uint32_t>(msg.uiBaseIntAddr);
        }
        else if (mnem == "MaxIntAddr") {
            return static_cast<uint32_t>(msg.uiMaxIntAddr);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "DevType") {
     int enumValue = findEnumValue(ENUMLOOKUP[8982], value);
     if (enumValue != -1) msg.teDevType = static_cast<decltype(msg.teDevType)>(enumValue);
     else msg.teDevType = static_cast<decltype(msg.teDevType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BaseInst") {
     msg.ucBaseInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "MaxInst") {
     msg.ucMaxInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "BaseIntAddr") {
     msg.uiBaseIntAddr = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "MaxIntAddr") {
     msg.uiMaxIntAddr = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "DevType") {
            return 1.0 * (long double)(msg.teDevType + 0.0);
        }
        else if (mnem == "BaseInst") {
            return 1.0 * (long double)(msg.ucBaseInst + 0.0);
        }
        else if (mnem == "MaxInst") {
            return 1.0 * (long double)(msg.ucMaxInst + 0.0);
        }
        else if (mnem == "BaseIntAddr") {
            return 1.0 * (long double)(msg.uiBaseIntAddr + 0.0);
        }
        else if (mnem == "MaxIntAddr") {
            return 1.0 * (long double)(msg.uiMaxIntAddr + 0.0);
        }
        return 0.0;
    }
} InstSts;

// Auto-generated class definition for RVC_tzPGN_INST_ASSIGN
typedef struct InstAssign : public MessageBase {
RVC_tzPGN_INST_ASSIGN msg;
InstAssign () {  memset(&msg, 0xFF, sizeof(msg));  };
InstAssign (void * pvStruct) {  msg = *(RVC_tzPGN_INST_ASSIGN *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "DevType") {
            if (ENUMLOOKUP[8982].find(msg.teDevType) == ENUMLOOKUP[8982].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDevType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[8982][msg.teDevType];
              }
        }
        else if (mnem == "BaseInst") {
            return (msg.ucBaseInst == 0xff) ? "No Data" : (msg.ucBaseInst == 0xfe) ? "Out of range" : (msg.ucBaseInst == 0xfd) ? "Reserved" : std::to_string(msg.ucBaseInst);
        }
        else if (mnem == "MaxInst") {
            return (msg.ucMaxInst == 0xff) ? "No Data" : (msg.ucMaxInst == 0xfe) ? "Out of range" : (msg.ucMaxInst == 0xfd) ? "Reserved" : std::to_string(msg.ucMaxInst);
        }
        else if (mnem == "BaseIntAddr") {
            return (msg.uiBaseIntAddr == 0xffff) ? "No Data" : (msg.uiBaseIntAddr == 0xfffe) ? "Out of range" : (msg.uiBaseIntAddr == 0xfffd) ? "Reserved" : std::to_string(msg.uiBaseIntAddr);
        }
        else if (mnem == "MaxIntAddr") {
            return (msg.uiMaxIntAddr == 0xffff) ? "No Data" : (msg.uiMaxIntAddr == 0xfffe) ? "Out of range" : (msg.uiMaxIntAddr == 0xfffd) ? "Reserved" : std::to_string(msg.uiMaxIntAddr);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InstAssign" << std::endl;
        cout << "DevType      : " << fnGetValue("DevType") << " (" << fnGetRawValue("DevType") << ")" << endl;
        cout << "BaseInst      : " << fnGetValue("BaseInst") << " (" << fnGetRawValue("BaseInst") << ")" << endl;
        cout << "MaxInst      : " << fnGetValue("MaxInst") << " (" << fnGetRawValue("MaxInst") << ")" << endl;
        cout << "BaseIntAddr      : " << fnGetValue("BaseIntAddr") << " (" << fnGetRawValue("BaseIntAddr") << ")" << endl;
        cout << "MaxIntAddr      : " << fnGetValue("MaxIntAddr") << " (" << fnGetRawValue("MaxIntAddr") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "DevType") {
            return static_cast<uint32_t>(msg.teDevType);
        }
        else if (mnem == "BaseInst") {
            return static_cast<uint32_t>(msg.ucBaseInst);
        }
        else if (mnem == "MaxInst") {
            return static_cast<uint32_t>(msg.ucMaxInst);
        }
        else if (mnem == "BaseIntAddr") {
            return static_cast<uint32_t>(msg.uiBaseIntAddr);
        }
        else if (mnem == "MaxIntAddr") {
            return static_cast<uint32_t>(msg.uiMaxIntAddr);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "DevType") {
     int enumValue = findEnumValue(ENUMLOOKUP[8982], value);
     if (enumValue != -1) msg.teDevType = static_cast<decltype(msg.teDevType)>(enumValue);
     else msg.teDevType = static_cast<decltype(msg.teDevType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BaseInst") {
     msg.ucBaseInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "MaxInst") {
     msg.ucMaxInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "BaseIntAddr") {
     msg.uiBaseIntAddr = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "MaxIntAddr") {
     msg.uiMaxIntAddr = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "DevType") {
            return 1.0 * (long double)(msg.teDevType + 0.0);
        }
        else if (mnem == "BaseInst") {
            return 1.0 * (long double)(msg.ucBaseInst + 0.0);
        }
        else if (mnem == "MaxInst") {
            return 1.0 * (long double)(msg.ucMaxInst + 0.0);
        }
        else if (mnem == "BaseIntAddr") {
            return 1.0 * (long double)(msg.uiBaseIntAddr + 0.0);
        }
        else if (mnem == "MaxIntAddr") {
            return 1.0 * (long double)(msg.uiMaxIntAddr + 0.0);
        }
        return 0.0;
    }
} InstAssign;

// Auto-generated class definition for RVC_tzPGN_VIRTUAL_TERMINAL
typedef struct VirtualTerminal : public MessageBase {
RVC_tzPGN_VIRTUAL_TERMINAL msg;
VirtualTerminal () {  memset(&msg, 0xFF, sizeof(msg));  };
VirtualTerminal (void * pvStruct) {  msg = *(RVC_tzPGN_VIRTUAL_TERMINAL *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "AsciiChar1") {
            return (msg.ucAsciiChar1 == 0xff) ? "No Data" : (msg.ucAsciiChar1 == 0xfe) ? "Out of range" : (msg.ucAsciiChar1 == 0xfd) ? "Reserved" : std::to_string(msg.ucAsciiChar1);
        }
        else if (mnem == "AsciiChar2") {
            return (msg.ucAsciiChar2 == 0xff) ? "No Data" : (msg.ucAsciiChar2 == 0xfe) ? "Out of range" : (msg.ucAsciiChar2 == 0xfd) ? "Reserved" : std::to_string(msg.ucAsciiChar2);
        }
        else if (mnem == "AsciiChar3") {
            return (msg.ucAsciiChar3 == 0xff) ? "No Data" : (msg.ucAsciiChar3 == 0xfe) ? "Out of range" : (msg.ucAsciiChar3 == 0xfd) ? "Reserved" : std::to_string(msg.ucAsciiChar3);
        }
        else if (mnem == "AsciiChar4") {
            return (msg.ucAsciiChar4 == 0xff) ? "No Data" : (msg.ucAsciiChar4 == 0xfe) ? "Out of range" : (msg.ucAsciiChar4 == 0xfd) ? "Reserved" : std::to_string(msg.ucAsciiChar4);
        }
        else if (mnem == "AsciiChar5") {
            return (msg.ucAsciiChar5 == 0xff) ? "No Data" : (msg.ucAsciiChar5 == 0xfe) ? "Out of range" : (msg.ucAsciiChar5 == 0xfd) ? "Reserved" : std::to_string(msg.ucAsciiChar5);
        }
        else if (mnem == "AsciiChar6") {
            return (msg.ucAsciiChar6 == 0xff) ? "No Data" : (msg.ucAsciiChar6 == 0xfe) ? "Out of range" : (msg.ucAsciiChar6 == 0xfd) ? "Reserved" : std::to_string(msg.ucAsciiChar6);
        }
        else if (mnem == "AsciiChar7") {
            return (msg.ucAsciiChar7 == 0xff) ? "No Data" : (msg.ucAsciiChar7 == 0xfe) ? "Out of range" : (msg.ucAsciiChar7 == 0xfd) ? "Reserved" : std::to_string(msg.ucAsciiChar7);
        }
        else if (mnem == "AsciiChar8") {
            return (msg.ucAsciiChar8 == 0xff) ? "No Data" : (msg.ucAsciiChar8 == 0xfe) ? "Out of range" : (msg.ucAsciiChar8 == 0xfd) ? "Reserved" : std::to_string(msg.ucAsciiChar8);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: VirtualTerminal" << std::endl;
        cout << "AsciiChar1      : " << fnGetValue("AsciiChar1") << " (" << fnGetRawValue("AsciiChar1") << ")" << endl;
        cout << "AsciiChar2      : " << fnGetValue("AsciiChar2") << " (" << fnGetRawValue("AsciiChar2") << ")" << endl;
        cout << "AsciiChar3      : " << fnGetValue("AsciiChar3") << " (" << fnGetRawValue("AsciiChar3") << ")" << endl;
        cout << "AsciiChar4      : " << fnGetValue("AsciiChar4") << " (" << fnGetRawValue("AsciiChar4") << ")" << endl;
        cout << "AsciiChar5      : " << fnGetValue("AsciiChar5") << " (" << fnGetRawValue("AsciiChar5") << ")" << endl;
        cout << "AsciiChar6      : " << fnGetValue("AsciiChar6") << " (" << fnGetRawValue("AsciiChar6") << ")" << endl;
        cout << "AsciiChar7      : " << fnGetValue("AsciiChar7") << " (" << fnGetRawValue("AsciiChar7") << ")" << endl;
        cout << "AsciiChar8      : " << fnGetValue("AsciiChar8") << " (" << fnGetRawValue("AsciiChar8") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "AsciiChar1") {
            return static_cast<uint32_t>(msg.ucAsciiChar1);
        }
        else if (mnem == "AsciiChar2") {
            return static_cast<uint32_t>(msg.ucAsciiChar2);
        }
        else if (mnem == "AsciiChar3") {
            return static_cast<uint32_t>(msg.ucAsciiChar3);
        }
        else if (mnem == "AsciiChar4") {
            return static_cast<uint32_t>(msg.ucAsciiChar4);
        }
        else if (mnem == "AsciiChar5") {
            return static_cast<uint32_t>(msg.ucAsciiChar5);
        }
        else if (mnem == "AsciiChar6") {
            return static_cast<uint32_t>(msg.ucAsciiChar6);
        }
        else if (mnem == "AsciiChar7") {
            return static_cast<uint32_t>(msg.ucAsciiChar7);
        }
        else if (mnem == "AsciiChar8") {
            return static_cast<uint32_t>(msg.ucAsciiChar8);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "AsciiChar1") {
     msg.ucAsciiChar1 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "AsciiChar2") {
     msg.ucAsciiChar2 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "AsciiChar3") {
     msg.ucAsciiChar3 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "AsciiChar4") {
     msg.ucAsciiChar4 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "AsciiChar5") {
     msg.ucAsciiChar5 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "AsciiChar6") {
     msg.ucAsciiChar6 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "AsciiChar7") {
     msg.ucAsciiChar7 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "AsciiChar8") {
     msg.ucAsciiChar8 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "AsciiChar1") {
            return 1.0 * (long double)(msg.ucAsciiChar1 + 0.0);
        }
        else if (mnem == "AsciiChar2") {
            return 1.0 * (long double)(msg.ucAsciiChar2 + 0.0);
        }
        else if (mnem == "AsciiChar3") {
            return 1.0 * (long double)(msg.ucAsciiChar3 + 0.0);
        }
        else if (mnem == "AsciiChar4") {
            return 1.0 * (long double)(msg.ucAsciiChar4 + 0.0);
        }
        else if (mnem == "AsciiChar5") {
            return 1.0 * (long double)(msg.ucAsciiChar5 + 0.0);
        }
        else if (mnem == "AsciiChar6") {
            return 1.0 * (long double)(msg.ucAsciiChar6 + 0.0);
        }
        else if (mnem == "AsciiChar7") {
            return 1.0 * (long double)(msg.ucAsciiChar7 + 0.0);
        }
        else if (mnem == "AsciiChar8") {
            return 1.0 * (long double)(msg.ucAsciiChar8 + 0.0);
        }
        return 0.0;
    }
} VirtualTerminal;

// Auto-generated class definition for RVC_tzPGN_GEN_RST
typedef struct GenRst : public MessageBase {
RVC_tzPGN_GEN_RST msg;
GenRst () {  memset(&msg, 0xFF, sizeof(msg));  };
GenRst (void * pvStruct) {  msg = *(RVC_tzPGN_GEN_RST *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Reboot") {
            if (ENUMLOOKUP[9066].find(msg.teReboot) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teReboot);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teReboot];
              }
        }
        else if (mnem == "ClrFlts") {
            if (ENUMLOOKUP[9066].find(msg.teClrFlts) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teClrFlts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teClrFlts];
              }
        }
        else if (mnem == "RstDflt") {
            if (ENUMLOOKUP[9066].find(msg.teRstDflt) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teRstDflt);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teRstDflt];
              }
        }
        else if (mnem == "RstStats") {
            if (ENUMLOOKUP[9066].find(msg.teRstStats) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teRstStats);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teRstStats];
              }
        }
        else if (mnem == "TestMd") {
            if (ENUMLOOKUP[9066].find(msg.teTestMd) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teTestMd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teTestMd];
              }
        }
        else if (mnem == "RstOEM") {
            if (ENUMLOOKUP[9066].find(msg.teRstOEM) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teRstOEM);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teRstOEM];
              }
        }
        else if (mnem == "RstLdr") {
            if (ENUMLOOKUP[9066].find(msg.teRstLdr) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teRstLdr);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teRstLdr];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: GenRst" << std::endl;
        cout << "Reboot      : " << fnGetValue("Reboot") << " (" << fnGetRawValue("Reboot") << ")" << endl;
        cout << "ClrFlts      : " << fnGetValue("ClrFlts") << " (" << fnGetRawValue("ClrFlts") << ")" << endl;
        cout << "RstDflt      : " << fnGetValue("RstDflt") << " (" << fnGetRawValue("RstDflt") << ")" << endl;
        cout << "RstStats      : " << fnGetValue("RstStats") << " (" << fnGetRawValue("RstStats") << ")" << endl;
        cout << "TestMd      : " << fnGetValue("TestMd") << " (" << fnGetRawValue("TestMd") << ")" << endl;
        cout << "RstOEM      : " << fnGetValue("RstOEM") << " (" << fnGetRawValue("RstOEM") << ")" << endl;
        cout << "RstLdr      : " << fnGetValue("RstLdr") << " (" << fnGetRawValue("RstLdr") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Reboot") {
            return static_cast<uint32_t>(msg.teReboot);
        }
        else if (mnem == "ClrFlts") {
            return static_cast<uint32_t>(msg.teClrFlts);
        }
        else if (mnem == "RstDflt") {
            return static_cast<uint32_t>(msg.teRstDflt);
        }
        else if (mnem == "RstStats") {
            return static_cast<uint32_t>(msg.teRstStats);
        }
        else if (mnem == "TestMd") {
            return static_cast<uint32_t>(msg.teTestMd);
        }
        else if (mnem == "RstOEM") {
            return static_cast<uint32_t>(msg.teRstOEM);
        }
        else if (mnem == "RstLdr") {
            return static_cast<uint32_t>(msg.teRstLdr);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Reboot") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teReboot = static_cast<decltype(msg.teReboot)>(enumValue);
     else msg.teReboot = static_cast<decltype(msg.teReboot)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ClrFlts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teClrFlts = static_cast<decltype(msg.teClrFlts)>(enumValue);
     else msg.teClrFlts = static_cast<decltype(msg.teClrFlts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RstDflt") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teRstDflt = static_cast<decltype(msg.teRstDflt)>(enumValue);
     else msg.teRstDflt = static_cast<decltype(msg.teRstDflt)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RstStats") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teRstStats = static_cast<decltype(msg.teRstStats)>(enumValue);
     else msg.teRstStats = static_cast<decltype(msg.teRstStats)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "TestMd") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teTestMd = static_cast<decltype(msg.teTestMd)>(enumValue);
     else msg.teTestMd = static_cast<decltype(msg.teTestMd)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RstOEM") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teRstOEM = static_cast<decltype(msg.teRstOEM)>(enumValue);
     else msg.teRstOEM = static_cast<decltype(msg.teRstOEM)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RstLdr") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teRstLdr = static_cast<decltype(msg.teRstLdr)>(enumValue);
     else msg.teRstLdr = static_cast<decltype(msg.teRstLdr)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Reboot") {
            return 1.0 * (long double)(msg.teReboot + 0.0);
        }
        else if (mnem == "ClrFlts") {
            return 1.0 * (long double)(msg.teClrFlts + 0.0);
        }
        else if (mnem == "RstDflt") {
            return 1.0 * (long double)(msg.teRstDflt + 0.0);
        }
        else if (mnem == "RstStats") {
            return 1.0 * (long double)(msg.teRstStats + 0.0);
        }
        else if (mnem == "TestMd") {
            return 1.0 * (long double)(msg.teTestMd + 0.0);
        }
        else if (mnem == "RstOEM") {
            return 1.0 * (long double)(msg.teRstOEM + 0.0);
        }
        else if (mnem == "RstLdr") {
            return 1.0 * (long double)(msg.teRstLdr + 0.0);
        }
        return 0.0;
    }
} GenRst;

// Auto-generated class definition for RVC_tzPGN_PROD_INFO_STS
typedef struct ProdInfoSts : public MessageBase {
RVC_tzPGN_PROD_INFO_STS msg;
ProdInfoSts () {  memset(&msg, 0xFF, sizeof(msg));  };
ProdInfoSts (void * pvStruct) {  msg = *(RVC_tzPGN_PROD_INFO_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "MsgCount") {
            return std::to_string(msg.ucMsgCount);
        }
        else if (mnem == "ModelName") {
            return reinterpret_cast< char const* >(msg.aucModelName);
        }
        else if (mnem == "Fga") {
            return reinterpret_cast< char const* >(msg.aucFga);
        }
        else if (mnem == "PwrLvl") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ulPwrLvl + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "W");
            return (msg.ulPwrLvl == 0xffffffff) ? "No Data" : (msg.ulPwrLvl == 0xfffffffe) ? "Out of range" : (msg.ulPwrLvl == 0xfffffffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "NomDcLvl") {
            char buffer[50];
            auto engval = 0.0010000000474974513 * (long double) (msg.slNomDcLvl + 0.0);
            snprintf(buffer, sizeof(buffer), "%.3f %s", engval, "V");
            return (msg.slNomDcLvl == 0x7fffffff) ? "No Data" : (msg.slNomDcLvl == 0x7ffffffe) ? "Out of range" : (msg.slNomDcLvl == 0x7ffffffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "NomAcLvl") {
            char buffer[50];
            auto engval = 0.0010000000474974513 * (long double) (msg.ulNomAcLvl + 0.0);
            snprintf(buffer, sizeof(buffer), "%.3f %s", engval, "V");
            return (msg.ulNomAcLvl == 0xffffffff) ? "No Data" : (msg.ulNomAcLvl == 0xfffffffe) ? "Out of range" : (msg.ulNomAcLvl == 0xfffffffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "NomAcOutFreq") {
            char buffer[50];
            auto engval = 0.009999999776482582 * (long double) (msg.uiNomAcOutFreq + 0.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "Hz");
            return (msg.uiNomAcOutFreq == 0xffff) ? "No Data" : (msg.uiNomAcOutFreq == 0xfffe) ? "Out of range" : (msg.uiNomAcOutFreq == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ProdInfoSts" << std::endl;
        cout << "MsgCount      : " << fnGetValue("MsgCount") << " (" << fnGetRawValue("MsgCount") << ")" << endl;
        cout << "ModelName      : " << fnGetValue("ModelName") << " (" << fnGetRawValue("ModelName") << ")" << endl;
        cout << "Fga      : " << fnGetValue("Fga") << " (" << fnGetRawValue("Fga") << ")" << endl;
        cout << "PwrLvl      : " << fnGetValue("PwrLvl") << " (" << fnGetRawValue("PwrLvl") << ")" << endl;
        cout << "NomDcLvl      : " << fnGetValue("NomDcLvl") << " (" << fnGetRawValue("NomDcLvl") << ")" << endl;
        cout << "NomAcLvl      : " << fnGetValue("NomAcLvl") << " (" << fnGetRawValue("NomAcLvl") << ")" << endl;
        cout << "NomAcOutFreq      : " << fnGetValue("NomAcOutFreq") << " (" << fnGetRawValue("NomAcOutFreq") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "MsgCount") {
            return static_cast<uint32_t>(msg.ucMsgCount);
        }
        else if (mnem == "ModelName") {
            return UINT32_MAX;
        }
        else if (mnem == "Fga") {
            return UINT32_MAX;
        }
        else if (mnem == "PwrLvl") {
            return static_cast<uint32_t>(msg.ulPwrLvl);
        }
        else if (mnem == "NomDcLvl") {
            return static_cast<uint32_t>(msg.slNomDcLvl);
        }
        else if (mnem == "NomAcLvl") {
            return static_cast<uint32_t>(msg.ulNomAcLvl);
        }
        else if (mnem == "NomAcOutFreq") {
            return static_cast<uint32_t>(msg.uiNomAcOutFreq);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "MsgCount") {
     msg.ucMsgCount = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ModelName") {
        }
        else if (mnem == "Fga") {
        }
        else if (mnem == "PwrLvl") {
     msg.ulPwrLvl = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd, 1.0, 0.0);
        }
        else if (mnem == "NomDcLvl") {
     msg.slNomDcLvl = stringToInt(value, 0x7fffffff, 0x7ffffffe, 0x7ffffffd, 0.0010000000474974513, 0.0);
        }
        else if (mnem == "NomAcLvl") {
     msg.ulNomAcLvl = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd, 0.0010000000474974513, 0.0);
        }
        else if (mnem == "NomAcOutFreq") {
     msg.uiNomAcOutFreq = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.009999999776482582, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "MsgCount") {
            return 1.0 * (long double)(msg.ucMsgCount + 0.0);
        }
        else if (mnem == "ModelName") {
            return 0.0;
        }
        else if (mnem == "Fga") {
            return 0.0;
        }
        else if (mnem == "PwrLvl") {
            return 1.0 * (long double)(msg.ulPwrLvl + 0.0);
        }
        else if (mnem == "NomDcLvl") {
            return 0.0010000000474974513 * (long double)(msg.slNomDcLvl + 0.0);
        }
        else if (mnem == "NomAcLvl") {
            return 0.0010000000474974513 * (long double)(msg.ulNomAcLvl + 0.0);
        }
        else if (mnem == "NomAcOutFreq") {
            return 0.009999999776482582 * (long double)(msg.uiNomAcOutFreq + 0.0);
        }
        return 0.0;
    }
} ProdInfoSts;

// Auto-generated class definition for RVC_tzPGN_CHG_STS3
typedef struct ChgSts3 : public MessageBase {
RVC_tzPGN_CHG_STS3 msg;
ChgSts3 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgSts3 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_STS3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "ChgInst") {
            return (msg.ucChgInst == 0xff) ? "No Data" : (msg.ucChgInst == 0xfe) ? "Out of range" : (msg.ucChgInst == 0xfd) ? "Reserved" : std::to_string(msg.ucChgInst);
        }
        else if (mnem == "DerateSts") {
            if (ENUMLOOKUP[2041349348].find(msg.teDerateSts) == ENUMLOOKUP[2041349348].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDerateSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2041349348][msg.teDerateSts];
              }
        }
        else if (mnem == "DerateReason") {
            if (ENUMLOOKUP[666383381].find(msg.teDerateReason) == ENUMLOOKUP[666383381].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDerateReason);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[666383381][msg.teDerateReason];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgSts3" << std::endl;
        cout << "ChgInst      : " << fnGetValue("ChgInst") << " (" << fnGetRawValue("ChgInst") << ")" << endl;
        cout << "DerateSts      : " << fnGetValue("DerateSts") << " (" << fnGetRawValue("DerateSts") << ")" << endl;
        cout << "DerateReason      : " << fnGetValue("DerateReason") << " (" << fnGetRawValue("DerateReason") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "ChgInst") {
            return static_cast<uint32_t>(msg.ucChgInst);
        }
        else if (mnem == "DerateSts") {
            return static_cast<uint32_t>(msg.teDerateSts);
        }
        else if (mnem == "DerateReason") {
            return static_cast<uint32_t>(msg.teDerateReason);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "ChgInst") {
     msg.ucChgInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DerateSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[2041349348], value);
     if (enumValue != -1) msg.teDerateSts = static_cast<decltype(msg.teDerateSts)>(enumValue);
     else msg.teDerateSts = static_cast<decltype(msg.teDerateSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DerateReason") {
     int enumValue = findEnumValue(ENUMLOOKUP[666383381], value);
     if (enumValue != -1) msg.teDerateReason = static_cast<decltype(msg.teDerateReason)>(enumValue);
     else msg.teDerateReason = static_cast<decltype(msg.teDerateReason)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "ChgInst") {
            return 1.0 * (long double)(msg.ucChgInst + 0.0);
        }
        else if (mnem == "DerateSts") {
            return 1.0 * (long double)(msg.teDerateSts + 0.0);
        }
        else if (mnem == "DerateReason") {
            return 1.0 * (long double)(msg.teDerateReason + 0.0);
        }
        return 0.0;
    }
} ChgSts3;

// Auto-generated class definition for RVC_tzPGN_INV_TEMP_STS2
typedef struct InvTempSts2 : public MessageBase {
RVC_tzPGN_INV_TEMP_STS2 msg;
InvTempSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvTempSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_TEMP_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "CtrlBrdTemp") {
            char buffer[50];
            auto engval = 0.03125 * (long double) (msg.uiCtrlBrdTemp + -8736.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "deg C");
            return (msg.uiCtrlBrdTemp == 0xffff) ? "No Data" : (msg.uiCtrlBrdTemp == 0xfffe) ? "Out of range" : (msg.uiCtrlBrdTemp == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "CapTemp") {
            char buffer[50];
            auto engval = 0.03125 * (long double) (msg.uiCapTemp + -8736.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "deg C");
            return (msg.uiCapTemp == 0xffff) ? "No Data" : (msg.uiCapTemp == 0xfffe) ? "Out of range" : (msg.uiCapTemp == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "AmbTemp") {
            char buffer[50];
            auto engval = 0.03125 * (long double) (msg.uiAmbTemp + -8736.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "deg C");
            return (msg.uiAmbTemp == 0xffff) ? "No Data" : (msg.uiAmbTemp == 0xfffe) ? "Out of range" : (msg.uiAmbTemp == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvTempSts2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "CtrlBrdTemp      : " << fnGetValue("CtrlBrdTemp") << " (" << fnGetRawValue("CtrlBrdTemp") << ")" << endl;
        cout << "CapTemp      : " << fnGetValue("CapTemp") << " (" << fnGetRawValue("CapTemp") << ")" << endl;
        cout << "AmbTemp      : " << fnGetValue("AmbTemp") << " (" << fnGetRawValue("AmbTemp") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "CtrlBrdTemp") {
            return static_cast<uint32_t>(msg.uiCtrlBrdTemp);
        }
        else if (mnem == "CapTemp") {
            return static_cast<uint32_t>(msg.uiCapTemp);
        }
        else if (mnem == "AmbTemp") {
            return static_cast<uint32_t>(msg.uiAmbTemp);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "CtrlBrdTemp") {
     msg.uiCtrlBrdTemp = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.03125, -8736.0);
        }
        else if (mnem == "CapTemp") {
     msg.uiCapTemp = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.03125, -8736.0);
        }
        else if (mnem == "AmbTemp") {
     msg.uiAmbTemp = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.03125, -8736.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "CtrlBrdTemp") {
            return 0.03125 * (long double)(msg.uiCtrlBrdTemp + -8736.0);
        }
        else if (mnem == "CapTemp") {
            return 0.03125 * (long double)(msg.uiCapTemp + -8736.0);
        }
        else if (mnem == "AmbTemp") {
            return 0.03125 * (long double)(msg.uiAmbTemp + -8736.0);
        }
        return 0.0;
    }
} InvTempSts2;

// Auto-generated class definition for RVC_tzPGN_SCC_CFG_CMD5
typedef struct SccCfgCmd5 : public MessageBase {
RVC_tzPGN_SCC_CFG_CMD5 msg;
SccCfgCmd5 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccCfgCmd5 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_CFG_CMD5 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "ChgPrio") {
            return std::to_string(msg.ucChgPrio);
        }
        else if (mnem == "ExtTempOtSdThresh") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtTempOtSdThresh + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucExtTempOtSdThresh == 0xff) ? "No Data" : (msg.ucExtTempOtSdThresh == 0xfe) ? "Out of range" : (msg.ucExtTempOtSdThresh == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ExtTempUtSdThresh") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtTempUtSdThresh + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucExtTempUtSdThresh == 0xff) ? "No Data" : (msg.ucExtTempUtSdThresh == 0xfe) ? "Out of range" : (msg.ucExtTempUtSdThresh == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccCfgCmd5" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "ChgPrio      : " << fnGetValue("ChgPrio") << " (" << fnGetRawValue("ChgPrio") << ")" << endl;
        cout << "ExtTempOtSdThresh      : " << fnGetValue("ExtTempOtSdThresh") << " (" << fnGetRawValue("ExtTempOtSdThresh") << ")" << endl;
        cout << "ExtTempUtSdThresh      : " << fnGetValue("ExtTempUtSdThresh") << " (" << fnGetRawValue("ExtTempUtSdThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "ChgPrio") {
            return static_cast<uint32_t>(msg.ucChgPrio);
        }
        else if (mnem == "ExtTempOtSdThresh") {
            return static_cast<uint32_t>(msg.ucExtTempOtSdThresh);
        }
        else if (mnem == "ExtTempUtSdThresh") {
            return static_cast<uint32_t>(msg.ucExtTempUtSdThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ChgPrio") {
     msg.ucChgPrio = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ExtTempOtSdThresh") {
     msg.ucExtTempOtSdThresh = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
        else if (mnem == "ExtTempUtSdThresh") {
     msg.ucExtTempUtSdThresh = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "ChgPrio") {
            return 1.0 * (long double)(msg.ucChgPrio + 0.0);
        }
        else if (mnem == "ExtTempOtSdThresh") {
            return 1.0 * (long double)(msg.ucExtTempOtSdThresh + -40.0);
        }
        else if (mnem == "ExtTempUtSdThresh") {
            return 1.0 * (long double)(msg.ucExtTempUtSdThresh + -40.0);
        }
        return 0.0;
    }
} SccCfgCmd5;

// Auto-generated class definition for RVC_tzPGN_SCC_CFG_STS5
typedef struct SccCfgSts5 : public MessageBase {
RVC_tzPGN_SCC_CFG_STS5 msg;
SccCfgSts5 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccCfgSts5 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_CFG_STS5 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "ChgPrio") {
            return std::to_string(msg.ucChgPrio);
        }
        else if (mnem == "ExtTempOtSdThresh") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtTempOtSdThresh + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucExtTempOtSdThresh == 0xff) ? "No Data" : (msg.ucExtTempOtSdThresh == 0xfe) ? "Out of range" : (msg.ucExtTempOtSdThresh == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ExtTempUtSdThresh") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtTempUtSdThresh + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucExtTempUtSdThresh == 0xff) ? "No Data" : (msg.ucExtTempUtSdThresh == 0xfe) ? "Out of range" : (msg.ucExtTempUtSdThresh == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccCfgSts5" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "ChgPrio      : " << fnGetValue("ChgPrio") << " (" << fnGetRawValue("ChgPrio") << ")" << endl;
        cout << "ExtTempOtSdThresh      : " << fnGetValue("ExtTempOtSdThresh") << " (" << fnGetRawValue("ExtTempOtSdThresh") << ")" << endl;
        cout << "ExtTempUtSdThresh      : " << fnGetValue("ExtTempUtSdThresh") << " (" << fnGetRawValue("ExtTempUtSdThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "ChgPrio") {
            return static_cast<uint32_t>(msg.ucChgPrio);
        }
        else if (mnem == "ExtTempOtSdThresh") {
            return static_cast<uint32_t>(msg.ucExtTempOtSdThresh);
        }
        else if (mnem == "ExtTempUtSdThresh") {
            return static_cast<uint32_t>(msg.ucExtTempUtSdThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ChgPrio") {
     msg.ucChgPrio = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ExtTempOtSdThresh") {
     msg.ucExtTempOtSdThresh = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
        else if (mnem == "ExtTempUtSdThresh") {
     msg.ucExtTempUtSdThresh = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "ChgPrio") {
            return 1.0 * (long double)(msg.ucChgPrio + 0.0);
        }
        else if (mnem == "ExtTempOtSdThresh") {
            return 1.0 * (long double)(msg.ucExtTempOtSdThresh + -40.0);
        }
        else if (mnem == "ExtTempUtSdThresh") {
            return 1.0 * (long double)(msg.ucExtTempUtSdThresh + -40.0);
        }
        return 0.0;
    }
} SccCfgSts5;

// Auto-generated class definition for RVC_tzPGN_DC_SRC_CONN_STS
typedef struct DcSrcConnSts : public MessageBase {
RVC_tzPGN_DC_SRC_CONN_STS msg;
DcSrcConnSts () {  memset(&msg, 0xFF, sizeof(msg));  };
DcSrcConnSts (void * pvStruct) {  msg = *(RVC_tzPGN_DC_SRC_CONN_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "DevInst") {
            return (msg.ucDevInst == 0xff) ? "No Data" : (msg.ucDevInst == 0xfe) ? "Out of range" : (msg.ucDevInst == 0xfd) ? "Reserved" : std::to_string(msg.ucDevInst);
        }
        else if (mnem == "DevDSA") {
            return (msg.ucDevDSA == 0xff) ? "No Data" : (msg.ucDevDSA == 0xfe) ? "Out of range" : (msg.ucDevDSA == 0xfd) ? "Reserved" : std::to_string(msg.ucDevDSA);
        }
        else if (mnem == "Function") {
            if (ENUMLOOKUP[1671234938].find(msg.teFunction) == ENUMLOOKUP[1671234938].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFunction);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1671234938][msg.teFunction];
              }
        }
        else if (mnem == "PrimaryDcInst") {
            return (msg.ucPrimaryDcInst == 0xff) ? "No Data" : (msg.ucPrimaryDcInst == 0xfe) ? "Out of range" : (msg.ucPrimaryDcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucPrimaryDcInst);
        }
        else if (mnem == "SecondDcInst") {
            return (msg.ucSecondDcInst == 0xff) ? "No Data" : (msg.ucSecondDcInst == 0xfe) ? "Out of range" : (msg.ucSecondDcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucSecondDcInst);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: DcSrcConnSts" << std::endl;
        cout << "DevInst      : " << fnGetValue("DevInst") << " (" << fnGetRawValue("DevInst") << ")" << endl;
        cout << "DevDSA      : " << fnGetValue("DevDSA") << " (" << fnGetRawValue("DevDSA") << ")" << endl;
        cout << "Function      : " << fnGetValue("Function") << " (" << fnGetRawValue("Function") << ")" << endl;
        cout << "PrimaryDcInst      : " << fnGetValue("PrimaryDcInst") << " (" << fnGetRawValue("PrimaryDcInst") << ")" << endl;
        cout << "SecondDcInst      : " << fnGetValue("SecondDcInst") << " (" << fnGetRawValue("SecondDcInst") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "DevInst") {
            return static_cast<uint32_t>(msg.ucDevInst);
        }
        else if (mnem == "DevDSA") {
            return static_cast<uint32_t>(msg.ucDevDSA);
        }
        else if (mnem == "Function") {
            return static_cast<uint32_t>(msg.teFunction);
        }
        else if (mnem == "PrimaryDcInst") {
            return static_cast<uint32_t>(msg.ucPrimaryDcInst);
        }
        else if (mnem == "SecondDcInst") {
            return static_cast<uint32_t>(msg.ucSecondDcInst);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "DevInst") {
     msg.ucDevInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DevDSA") {
     msg.ucDevDSA = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Function") {
     int enumValue = findEnumValue(ENUMLOOKUP[1671234938], value);
     if (enumValue != -1) msg.teFunction = static_cast<decltype(msg.teFunction)>(enumValue);
     else msg.teFunction = static_cast<decltype(msg.teFunction)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PrimaryDcInst") {
     msg.ucPrimaryDcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "SecondDcInst") {
     msg.ucSecondDcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "DevInst") {
            return 1.0 * (long double)(msg.ucDevInst + 0.0);
        }
        else if (mnem == "DevDSA") {
            return 1.0 * (long double)(msg.ucDevDSA + 0.0);
        }
        else if (mnem == "Function") {
            return 1.0 * (long double)(msg.teFunction + 0.0);
        }
        else if (mnem == "PrimaryDcInst") {
            return 1.0 * (long double)(msg.ucPrimaryDcInst + 0.0);
        }
        else if (mnem == "SecondDcInst") {
            return 1.0 * (long double)(msg.ucSecondDcInst + 0.0);
        }
        return 0.0;
    }
} DcSrcConnSts;

// Auto-generated class definition for RVC_tzPGN_DEVICE_STATE_SYNC
typedef struct DeviceStateSync : public MessageBase {
RVC_tzPGN_DEVICE_STATE_SYNC msg;
DeviceStateSync () {  memset(&msg, 0xFF, sizeof(msg));  };
DeviceStateSync (void * pvStruct) {  msg = *(RVC_tzPGN_DEVICE_STATE_SYNC *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "ManufacturerCode") {
            return std::to_string(msg.uiManufacturerCode);
        }
        else if (mnem == "PayloadID") {
            return (msg.ucPayloadID == 0xff) ? "No Data" : (msg.ucPayloadID == 0xfe) ? "Out of range" : (msg.ucPayloadID == 0xfd) ? "Reserved" : std::to_string(msg.ucPayloadID);
        }
        else if (mnem == "Payload1") {
            return (msg.ucPayload1 == 0xff) ? "No Data" : (msg.ucPayload1 == 0xfe) ? "Out of range" : (msg.ucPayload1 == 0xfd) ? "Reserved" : std::to_string(msg.ucPayload1);
        }
        else if (mnem == "Payload2") {
            return (msg.ucPayload2 == 0xff) ? "No Data" : (msg.ucPayload2 == 0xfe) ? "Out of range" : (msg.ucPayload2 == 0xfd) ? "Reserved" : std::to_string(msg.ucPayload2);
        }
        else if (mnem == "Payload3") {
            return (msg.ucPayload3 == 0xff) ? "No Data" : (msg.ucPayload3 == 0xfe) ? "Out of range" : (msg.ucPayload3 == 0xfd) ? "Reserved" : std::to_string(msg.ucPayload3);
        }
        else if (mnem == "Payload4") {
            return (msg.ucPayload4 == 0xff) ? "No Data" : (msg.ucPayload4 == 0xfe) ? "Out of range" : (msg.ucPayload4 == 0xfd) ? "Reserved" : std::to_string(msg.ucPayload4);
        }
        else if (mnem == "Payload5") {
            return (msg.ucPayload5 == 0xff) ? "No Data" : (msg.ucPayload5 == 0xfe) ? "Out of range" : (msg.ucPayload5 == 0xfd) ? "Reserved" : std::to_string(msg.ucPayload5);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: DeviceStateSync" << std::endl;
        cout << "ManufacturerCode      : " << fnGetValue("ManufacturerCode") << " (" << fnGetRawValue("ManufacturerCode") << ")" << endl;
        cout << "PayloadID      : " << fnGetValue("PayloadID") << " (" << fnGetRawValue("PayloadID") << ")" << endl;
        cout << "Payload1      : " << fnGetValue("Payload1") << " (" << fnGetRawValue("Payload1") << ")" << endl;
        cout << "Payload2      : " << fnGetValue("Payload2") << " (" << fnGetRawValue("Payload2") << ")" << endl;
        cout << "Payload3      : " << fnGetValue("Payload3") << " (" << fnGetRawValue("Payload3") << ")" << endl;
        cout << "Payload4      : " << fnGetValue("Payload4") << " (" << fnGetRawValue("Payload4") << ")" << endl;
        cout << "Payload5      : " << fnGetValue("Payload5") << " (" << fnGetRawValue("Payload5") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "ManufacturerCode") {
            return static_cast<uint32_t>(msg.uiManufacturerCode);
        }
        else if (mnem == "PayloadID") {
            return static_cast<uint32_t>(msg.ucPayloadID);
        }
        else if (mnem == "Payload1") {
            return static_cast<uint32_t>(msg.ucPayload1);
        }
        else if (mnem == "Payload2") {
            return static_cast<uint32_t>(msg.ucPayload2);
        }
        else if (mnem == "Payload3") {
            return static_cast<uint32_t>(msg.ucPayload3);
        }
        else if (mnem == "Payload4") {
            return static_cast<uint32_t>(msg.ucPayload4);
        }
        else if (mnem == "Payload5") {
            return static_cast<uint32_t>(msg.ucPayload5);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "ManufacturerCode") {
     msg.uiManufacturerCode = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "PayloadID") {
     msg.ucPayloadID = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Payload1") {
     msg.ucPayload1 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Payload2") {
     msg.ucPayload2 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Payload3") {
     msg.ucPayload3 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Payload4") {
     msg.ucPayload4 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Payload5") {
     msg.ucPayload5 = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "ManufacturerCode") {
            return 1.0 * (long double)(msg.uiManufacturerCode + 0.0);
        }
        else if (mnem == "PayloadID") {
            return 1.0 * (long double)(msg.ucPayloadID + 0.0);
        }
        else if (mnem == "Payload1") {
            return 1.0 * (long double)(msg.ucPayload1 + 0.0);
        }
        else if (mnem == "Payload2") {
            return 1.0 * (long double)(msg.ucPayload2 + 0.0);
        }
        else if (mnem == "Payload3") {
            return 1.0 * (long double)(msg.ucPayload3 + 0.0);
        }
        else if (mnem == "Payload4") {
            return 1.0 * (long double)(msg.ucPayload4 + 0.0);
        }
        else if (mnem == "Payload5") {
            return 1.0 * (long double)(msg.ucPayload5 + 0.0);
        }
        return 0.0;
    }
} DeviceStateSync;

// Auto-generated class definition for RVC_tzPGN_DC_SRC_CFG_CMD3
typedef struct DcSrcCfgCmd3 : public MessageBase {
RVC_tzPGN_DC_SRC_CFG_CMD3 msg;
DcSrcCfgCmd3 () {  memset(&msg, 0xFF, sizeof(msg));  };
DcSrcCfgCmd3 (void * pvStruct) {  msg = *(RVC_tzPGN_DC_SRC_CFG_CMD3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "DevInst") {
            return (msg.ucDevInst == 0xff) ? "No Data" : (msg.ucDevInst == 0xfe) ? "Out of range" : (msg.ucDevInst == 0xfd) ? "Reserved" : std::to_string(msg.ucDevInst);
        }
        else if (mnem == "DevDSA") {
            return (msg.ucDevDSA == 0xff) ? "No Data" : (msg.ucDevDSA == 0xfe) ? "Out of range" : (msg.ucDevDSA == 0xfd) ? "Reserved" : std::to_string(msg.ucDevDSA);
        }
        else if (mnem == "Function") {
            if (ENUMLOOKUP[1671234938].find(msg.teFunction) == ENUMLOOKUP[1671234938].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFunction);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1671234938][msg.teFunction];
              }
        }
        else if (mnem == "PrimaryDcInst") {
            return (msg.ucPrimaryDcInst == 0xff) ? "No Data" : (msg.ucPrimaryDcInst == 0xfe) ? "Out of range" : (msg.ucPrimaryDcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucPrimaryDcInst);
        }
        else if (mnem == "SecondDcInst") {
            return (msg.ucSecondDcInst == 0xff) ? "No Data" : (msg.ucSecondDcInst == 0xfe) ? "Out of range" : (msg.ucSecondDcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucSecondDcInst);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: DcSrcCfgCmd3" << std::endl;
        cout << "DevInst      : " << fnGetValue("DevInst") << " (" << fnGetRawValue("DevInst") << ")" << endl;
        cout << "DevDSA      : " << fnGetValue("DevDSA") << " (" << fnGetRawValue("DevDSA") << ")" << endl;
        cout << "Function      : " << fnGetValue("Function") << " (" << fnGetRawValue("Function") << ")" << endl;
        cout << "PrimaryDcInst      : " << fnGetValue("PrimaryDcInst") << " (" << fnGetRawValue("PrimaryDcInst") << ")" << endl;
        cout << "SecondDcInst      : " << fnGetValue("SecondDcInst") << " (" << fnGetRawValue("SecondDcInst") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "DevInst") {
            return static_cast<uint32_t>(msg.ucDevInst);
        }
        else if (mnem == "DevDSA") {
            return static_cast<uint32_t>(msg.ucDevDSA);
        }
        else if (mnem == "Function") {
            return static_cast<uint32_t>(msg.teFunction);
        }
        else if (mnem == "PrimaryDcInst") {
            return static_cast<uint32_t>(msg.ucPrimaryDcInst);
        }
        else if (mnem == "SecondDcInst") {
            return static_cast<uint32_t>(msg.ucSecondDcInst);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "DevInst") {
     msg.ucDevInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DevDSA") {
     msg.ucDevDSA = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Function") {
     int enumValue = findEnumValue(ENUMLOOKUP[1671234938], value);
     if (enumValue != -1) msg.teFunction = static_cast<decltype(msg.teFunction)>(enumValue);
     else msg.teFunction = static_cast<decltype(msg.teFunction)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PrimaryDcInst") {
     msg.ucPrimaryDcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "SecondDcInst") {
     msg.ucSecondDcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "DevInst") {
            return 1.0 * (long double)(msg.ucDevInst + 0.0);
        }
        else if (mnem == "DevDSA") {
            return 1.0 * (long double)(msg.ucDevDSA + 0.0);
        }
        else if (mnem == "Function") {
            return 1.0 * (long double)(msg.teFunction + 0.0);
        }
        else if (mnem == "PrimaryDcInst") {
            return 1.0 * (long double)(msg.ucPrimaryDcInst + 0.0);
        }
        else if (mnem == "SecondDcInst") {
            return 1.0 * (long double)(msg.ucSecondDcInst + 0.0);
        }
        return 0.0;
    }
} DcSrcCfgCmd3;

// Auto-generated class definition for RVC_tzPGN_BATT_SUMM
typedef struct BattSumm : public MessageBase {
RVC_tzPGN_BATT_SUMM msg;
BattSumm () {  memset(&msg, 0xFF, sizeof(msg));  };
BattSumm (void * pvStruct) {  msg = *(RVC_tzPGN_BATT_SUMM *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            if (ENUMLOOKUP[421711928].find(msg.teBattInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teBattInst];
              }
        }
        else if (mnem == "DcInst") {
            if (ENUMLOOKUP[421711928].find(msg.teDcInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDcInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teDcInst];
              }
        }
        else if (mnem == "SeriesString") {
            return (msg.ucSeriesString == 0xff) ? "No Data" : (msg.ucSeriesString == 0xfe) ? "Out of range" : (msg.ucSeriesString == 0xfd) ? "Reserved" : std::to_string(msg.ucSeriesString);
        }
        else if (mnem == "ModuleCnt") {
            if (ENUMLOOKUP[1653075463].find(msg.teModuleCnt) == ENUMLOOKUP[1653075463].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teModuleCnt);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1653075463][msg.teModuleCnt];
              }
        }
        else if (mnem == "CellsPerModule") {
            return (msg.ucCellsPerModule == 0xff) ? "No Data" : (msg.ucCellsPerModule == 0xfe) ? "Out of range" : (msg.ucCellsPerModule == 0xfd) ? "Reserved" : std::to_string(msg.ucCellsPerModule);
        }
        else if (mnem == "VoltSts") {
            if (ENUMLOOKUP[-1891506457].find(msg.teVoltSts) == ENUMLOOKUP[-1891506457].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teVoltSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-1891506457][msg.teVoltSts];
              }
        }
        else if (mnem == "TempSts") {
            if (ENUMLOOKUP[-624353124].find(msg.teTempSts) == ENUMLOOKUP[-624353124].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teTempSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-624353124][msg.teTempSts];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: BattSumm" << std::endl;
        cout << "BattInst      : " << fnGetValue("BattInst") << " (" << fnGetRawValue("BattInst") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "SeriesString      : " << fnGetValue("SeriesString") << " (" << fnGetRawValue("SeriesString") << ")" << endl;
        cout << "ModuleCnt      : " << fnGetValue("ModuleCnt") << " (" << fnGetRawValue("ModuleCnt") << ")" << endl;
        cout << "CellsPerModule      : " << fnGetValue("CellsPerModule") << " (" << fnGetRawValue("CellsPerModule") << ")" << endl;
        cout << "VoltSts      : " << fnGetValue("VoltSts") << " (" << fnGetRawValue("VoltSts") << ")" << endl;
        cout << "TempSts      : " << fnGetValue("TempSts") << " (" << fnGetRawValue("TempSts") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return static_cast<uint32_t>(msg.teBattInst);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.teDcInst);
        }
        else if (mnem == "SeriesString") {
            return static_cast<uint32_t>(msg.ucSeriesString);
        }
        else if (mnem == "ModuleCnt") {
            return static_cast<uint32_t>(msg.teModuleCnt);
        }
        else if (mnem == "CellsPerModule") {
            return static_cast<uint32_t>(msg.ucCellsPerModule);
        }
        else if (mnem == "VoltSts") {
            return static_cast<uint32_t>(msg.teVoltSts);
        }
        else if (mnem == "TempSts") {
            return static_cast<uint32_t>(msg.teTempSts);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "BattInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teBattInst = static_cast<decltype(msg.teBattInst)>(enumValue);
     else msg.teBattInst = static_cast<decltype(msg.teBattInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teDcInst = static_cast<decltype(msg.teDcInst)>(enumValue);
     else msg.teDcInst = static_cast<decltype(msg.teDcInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SeriesString") {
     msg.ucSeriesString = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "ModuleCnt") {
     int enumValue = findEnumValue(ENUMLOOKUP[1653075463], value);
     if (enumValue != -1) msg.teModuleCnt = static_cast<decltype(msg.teModuleCnt)>(enumValue);
     else msg.teModuleCnt = static_cast<decltype(msg.teModuleCnt)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CellsPerModule") {
     msg.ucCellsPerModule = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "VoltSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[-1891506457], value);
     if (enumValue != -1) msg.teVoltSts = static_cast<decltype(msg.teVoltSts)>(enumValue);
     else msg.teVoltSts = static_cast<decltype(msg.teVoltSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "TempSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[-624353124], value);
     if (enumValue != -1) msg.teTempSts = static_cast<decltype(msg.teTempSts)>(enumValue);
     else msg.teTempSts = static_cast<decltype(msg.teTempSts)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return 1.0 * (long double)(msg.teBattInst + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.teDcInst + 0.0);
        }
        else if (mnem == "SeriesString") {
            return 1.0 * (long double)(msg.ucSeriesString + 0.0);
        }
        else if (mnem == "ModuleCnt") {
            return 1.0 * (long double)(msg.teModuleCnt + 0.0);
        }
        else if (mnem == "CellsPerModule") {
            return 1.0 * (long double)(msg.ucCellsPerModule + 0.0);
        }
        else if (mnem == "VoltSts") {
            return 1.0 * (long double)(msg.teVoltSts + 0.0);
        }
        else if (mnem == "TempSts") {
            return 1.0 * (long double)(msg.teTempSts + 0.0);
        }
        return 0.0;
    }
} BattSumm;

// Auto-generated class definition for RVC_tzPGN_SCC_CFG_CMD4
typedef struct SccCfgCmd4 : public MessageBase {
RVC_tzPGN_SCC_CFG_CMD4 msg;
SccCfgCmd4 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccCfgCmd4 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_CFG_CMD4 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "BattOvRetV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBattOvRetV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBattOvRetV == 0xffff) ? "No Data" : (msg.uiBattOvRetV == 0xfffe) ? "Out of range" : (msg.uiBattOvRetV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BattUvRetV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBattUvRetV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBattUvRetV == 0xffff) ? "No Data" : (msg.uiBattUvRetV == 0xfffe) ? "Out of range" : (msg.uiBattUvRetV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BattUvDly") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucBattUvDly + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucBattUvDly == 0xff) ? "No Data" : (msg.ucBattUvDly == 0xfe) ? "Out of range" : (msg.ucBattUvDly == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "AbsorpTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucAbsorpTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "minutes");
            return (msg.ucAbsorpTime == 0xff) ? "No Data" : (msg.ucAbsorpTime == 0xfe) ? "Out of range" : (msg.ucAbsorpTime == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TempCompConst") {
            return std::to_string(msg.ucTempCompConst);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccCfgCmd4" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "BattOvRetV      : " << fnGetValue("BattOvRetV") << " (" << fnGetRawValue("BattOvRetV") << ")" << endl;
        cout << "BattUvRetV      : " << fnGetValue("BattUvRetV") << " (" << fnGetRawValue("BattUvRetV") << ")" << endl;
        cout << "BattUvDly      : " << fnGetValue("BattUvDly") << " (" << fnGetRawValue("BattUvDly") << ")" << endl;
        cout << "AbsorpTime      : " << fnGetValue("AbsorpTime") << " (" << fnGetRawValue("AbsorpTime") << ")" << endl;
        cout << "TempCompConst      : " << fnGetValue("TempCompConst") << " (" << fnGetRawValue("TempCompConst") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "BattOvRetV") {
            return static_cast<uint32_t>(msg.uiBattOvRetV);
        }
        else if (mnem == "BattUvRetV") {
            return static_cast<uint32_t>(msg.uiBattUvRetV);
        }
        else if (mnem == "BattUvDly") {
            return static_cast<uint32_t>(msg.ucBattUvDly);
        }
        else if (mnem == "AbsorpTime") {
            return static_cast<uint32_t>(msg.ucAbsorpTime);
        }
        else if (mnem == "TempCompConst") {
            return static_cast<uint32_t>(msg.ucTempCompConst);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "BattOvRetV") {
     msg.uiBattOvRetV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "BattUvRetV") {
     msg.uiBattUvRetV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "BattUvDly") {
     msg.ucBattUvDly = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "AbsorpTime") {
     msg.ucAbsorpTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "TempCompConst") {
     msg.ucTempCompConst = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnTempComp2Cmd") return fnTempComp2Cmd(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "BattOvRetV") {
            return 0.05000000074505806 * (long double)(msg.uiBattOvRetV + 0.0);
        }
        else if (mnem == "BattUvRetV") {
            return 0.05000000074505806 * (long double)(msg.uiBattUvRetV + 0.0);
        }
        else if (mnem == "BattUvDly") {
            return 1.0 * (long double)(msg.ucBattUvDly + 0.0);
        }
        else if (mnem == "AbsorpTime") {
            return 1.0 * (long double)(msg.ucAbsorpTime + 0.0);
        }
        else if (mnem == "TempCompConst") {
            return 1.0 * (long double)(msg.ucTempCompConst + 0.0);
        }
        return 0.0;
    }
} SccCfgCmd4;

// Auto-generated class definition for RVC_tzPGN_SCC_CFG_STS4
typedef struct SccCfgSts4 : public MessageBase {
RVC_tzPGN_SCC_CFG_STS4 msg;
SccCfgSts4 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccCfgSts4 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_CFG_STS4 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "BattOvRetV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBattOvRetV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBattOvRetV == 0xffff) ? "No Data" : (msg.uiBattOvRetV == 0xfffe) ? "Out of range" : (msg.uiBattOvRetV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BattUvRetV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBattUvRetV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBattUvRetV == 0xffff) ? "No Data" : (msg.uiBattUvRetV == 0xfffe) ? "Out of range" : (msg.uiBattUvRetV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BattUvDly") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucBattUvDly + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucBattUvDly == 0xff) ? "No Data" : (msg.ucBattUvDly == 0xfe) ? "Out of range" : (msg.ucBattUvDly == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "AbsorpTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucAbsorpTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "minutes");
            return (msg.ucAbsorpTime == 0xff) ? "No Data" : (msg.ucAbsorpTime == 0xfe) ? "Out of range" : (msg.ucAbsorpTime == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TempCompConst") {
            return std::to_string(msg.ucTempCompConst);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccCfgSts4" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "BattOvRetV      : " << fnGetValue("BattOvRetV") << " (" << fnGetRawValue("BattOvRetV") << ")" << endl;
        cout << "BattUvRetV      : " << fnGetValue("BattUvRetV") << " (" << fnGetRawValue("BattUvRetV") << ")" << endl;
        cout << "BattUvDly      : " << fnGetValue("BattUvDly") << " (" << fnGetRawValue("BattUvDly") << ")" << endl;
        cout << "AbsorpTime      : " << fnGetValue("AbsorpTime") << " (" << fnGetRawValue("AbsorpTime") << ")" << endl;
        cout << "TempCompConst      : " << fnGetValue("TempCompConst") << " (" << fnGetRawValue("TempCompConst") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "BattOvRetV") {
            return static_cast<uint32_t>(msg.uiBattOvRetV);
        }
        else if (mnem == "BattUvRetV") {
            return static_cast<uint32_t>(msg.uiBattUvRetV);
        }
        else if (mnem == "BattUvDly") {
            return static_cast<uint32_t>(msg.ucBattUvDly);
        }
        else if (mnem == "AbsorpTime") {
            return static_cast<uint32_t>(msg.ucAbsorpTime);
        }
        else if (mnem == "TempCompConst") {
            return static_cast<uint32_t>(msg.ucTempCompConst);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "BattOvRetV") {
     msg.uiBattOvRetV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "BattUvRetV") {
     msg.uiBattUvRetV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "BattUvDly") {
     msg.ucBattUvDly = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "AbsorpTime") {
     msg.ucAbsorpTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "TempCompConst") {
     msg.ucTempCompConst = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnSts2TempComp") return fnSts2TempComp(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "BattOvRetV") {
            return 0.05000000074505806 * (long double)(msg.uiBattOvRetV + 0.0);
        }
        else if (mnem == "BattUvRetV") {
            return 0.05000000074505806 * (long double)(msg.uiBattUvRetV + 0.0);
        }
        else if (mnem == "BattUvDly") {
            return 1.0 * (long double)(msg.ucBattUvDly + 0.0);
        }
        else if (mnem == "AbsorpTime") {
            return 1.0 * (long double)(msg.ucAbsorpTime + 0.0);
        }
        else if (mnem == "TempCompConst") {
            return 1.0 * (long double)(msg.ucTempCompConst + 0.0);
        }
        return 0.0;
    }
} SccCfgSts4;

// Auto-generated class definition for RVC_tzPGN_SCC_CFG_CMD3
typedef struct SccCfgCmd3 : public MessageBase {
RVC_tzPGN_SCC_CFG_CMD3 msg;
SccCfgCmd3 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccCfgCmd3 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_CFG_CMD3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "BattUvWarnThresh") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBattUvWarnThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBattUvWarnThresh == 0xffff) ? "No Data" : (msg.uiBattUvWarnThresh == 0xfffe) ? "Out of range" : (msg.uiBattUvWarnThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BattOvSdThresh") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBattOvSdThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBattOvSdThresh == 0xffff) ? "No Data" : (msg.uiBattOvSdThresh == 0xfffe) ? "Out of range" : (msg.uiBattOvSdThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BattUvSdThresh") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBattUvSdThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBattUvSdThresh == 0xffff) ? "No Data" : (msg.uiBattUvSdThresh == 0xfffe) ? "Out of range" : (msg.uiBattUvSdThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccCfgCmd3" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "BattUvWarnThresh      : " << fnGetValue("BattUvWarnThresh") << " (" << fnGetRawValue("BattUvWarnThresh") << ")" << endl;
        cout << "BattOvSdThresh      : " << fnGetValue("BattOvSdThresh") << " (" << fnGetRawValue("BattOvSdThresh") << ")" << endl;
        cout << "BattUvSdThresh      : " << fnGetValue("BattUvSdThresh") << " (" << fnGetRawValue("BattUvSdThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "BattUvWarnThresh") {
            return static_cast<uint32_t>(msg.uiBattUvWarnThresh);
        }
        else if (mnem == "BattOvSdThresh") {
            return static_cast<uint32_t>(msg.uiBattOvSdThresh);
        }
        else if (mnem == "BattUvSdThresh") {
            return static_cast<uint32_t>(msg.uiBattUvSdThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "BattUvWarnThresh") {
     msg.uiBattUvWarnThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "BattOvSdThresh") {
     msg.uiBattOvSdThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "BattUvSdThresh") {
     msg.uiBattUvSdThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "BattUvWarnThresh") {
            return 0.05000000074505806 * (long double)(msg.uiBattUvWarnThresh + 0.0);
        }
        else if (mnem == "BattOvSdThresh") {
            return 0.05000000074505806 * (long double)(msg.uiBattOvSdThresh + 0.0);
        }
        else if (mnem == "BattUvSdThresh") {
            return 0.05000000074505806 * (long double)(msg.uiBattUvSdThresh + 0.0);
        }
        return 0.0;
    }
} SccCfgCmd3;

// Auto-generated class definition for RVC_tzPGN_SCC_CFG_STS3
typedef struct SccCfgSts3 : public MessageBase {
RVC_tzPGN_SCC_CFG_STS3 msg;
SccCfgSts3 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccCfgSts3 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_CFG_STS3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "BattUvWarnThresh") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBattUvWarnThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBattUvWarnThresh == 0xffff) ? "No Data" : (msg.uiBattUvWarnThresh == 0xfffe) ? "Out of range" : (msg.uiBattUvWarnThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BattOvSdThresh") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBattOvSdThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBattOvSdThresh == 0xffff) ? "No Data" : (msg.uiBattOvSdThresh == 0xfffe) ? "Out of range" : (msg.uiBattOvSdThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BattUvSdThresh") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBattUvSdThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBattUvSdThresh == 0xffff) ? "No Data" : (msg.uiBattUvSdThresh == 0xfffe) ? "Out of range" : (msg.uiBattUvSdThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccCfgSts3" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "BattUvWarnThresh      : " << fnGetValue("BattUvWarnThresh") << " (" << fnGetRawValue("BattUvWarnThresh") << ")" << endl;
        cout << "BattOvSdThresh      : " << fnGetValue("BattOvSdThresh") << " (" << fnGetRawValue("BattOvSdThresh") << ")" << endl;
        cout << "BattUvSdThresh      : " << fnGetValue("BattUvSdThresh") << " (" << fnGetRawValue("BattUvSdThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "BattUvWarnThresh") {
            return static_cast<uint32_t>(msg.uiBattUvWarnThresh);
        }
        else if (mnem == "BattOvSdThresh") {
            return static_cast<uint32_t>(msg.uiBattOvSdThresh);
        }
        else if (mnem == "BattUvSdThresh") {
            return static_cast<uint32_t>(msg.uiBattUvSdThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "BattUvWarnThresh") {
     msg.uiBattUvWarnThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "BattOvSdThresh") {
     msg.uiBattOvSdThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "BattUvSdThresh") {
     msg.uiBattUvSdThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "BattUvWarnThresh") {
            return 0.05000000074505806 * (long double)(msg.uiBattUvWarnThresh + 0.0);
        }
        else if (mnem == "BattOvSdThresh") {
            return 0.05000000074505806 * (long double)(msg.uiBattOvSdThresh + 0.0);
        }
        else if (mnem == "BattUvSdThresh") {
            return 0.05000000074505806 * (long double)(msg.uiBattUvSdThresh + 0.0);
        }
        return 0.0;
    }
} SccCfgSts3;

// Auto-generated class definition for RVC_tzPGN_SCC_CFG_CMD2
typedef struct SccCfgCmd2 : public MessageBase {
RVC_tzPGN_SCC_CFG_CMD2 msg;
SccCfgCmd2 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccCfgCmd2 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_CFG_CMD2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "BulkV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBulkV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBulkV == 0xffff) ? "No Data" : (msg.uiBulkV == 0xfffe) ? "Out of range" : (msg.uiBulkV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "FloatV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiFloatV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiFloatV == 0xffff) ? "No Data" : (msg.uiFloatV == 0xfffe) ? "Out of range" : (msg.uiFloatV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ChgRetV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiChgRetV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiChgRetV == 0xffff) ? "No Data" : (msg.uiChgRetV == 0xfffe) ? "Out of range" : (msg.uiChgRetV == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccCfgCmd2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "BulkV      : " << fnGetValue("BulkV") << " (" << fnGetRawValue("BulkV") << ")" << endl;
        cout << "FloatV      : " << fnGetValue("FloatV") << " (" << fnGetRawValue("FloatV") << ")" << endl;
        cout << "ChgRetV      : " << fnGetValue("ChgRetV") << " (" << fnGetRawValue("ChgRetV") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "BulkV") {
            return static_cast<uint32_t>(msg.uiBulkV);
        }
        else if (mnem == "FloatV") {
            return static_cast<uint32_t>(msg.uiFloatV);
        }
        else if (mnem == "ChgRetV") {
            return static_cast<uint32_t>(msg.uiChgRetV);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "BulkV") {
     msg.uiBulkV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "FloatV") {
     msg.uiFloatV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "ChgRetV") {
     msg.uiChgRetV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "BulkV") {
            return 0.05000000074505806 * (long double)(msg.uiBulkV + 0.0);
        }
        else if (mnem == "FloatV") {
            return 0.05000000074505806 * (long double)(msg.uiFloatV + 0.0);
        }
        else if (mnem == "ChgRetV") {
            return 0.05000000074505806 * (long double)(msg.uiChgRetV + 0.0);
        }
        return 0.0;
    }
} SccCfgCmd2;

// Auto-generated class definition for RVC_tzPGN_SCC_CFG_STS2
typedef struct SccCfgSts2 : public MessageBase {
RVC_tzPGN_SCC_CFG_STS2 msg;
SccCfgSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccCfgSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_CFG_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "BulkV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBulkV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBulkV == 0xffff) ? "No Data" : (msg.uiBulkV == 0xfffe) ? "Out of range" : (msg.uiBulkV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "FloatV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiFloatV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiFloatV == 0xffff) ? "No Data" : (msg.uiFloatV == 0xfffe) ? "Out of range" : (msg.uiFloatV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ChgRetV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiChgRetV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiChgRetV == 0xffff) ? "No Data" : (msg.uiChgRetV == 0xfffe) ? "Out of range" : (msg.uiChgRetV == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccCfgSts2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "BulkV      : " << fnGetValue("BulkV") << " (" << fnGetRawValue("BulkV") << ")" << endl;
        cout << "FloatV      : " << fnGetValue("FloatV") << " (" << fnGetRawValue("FloatV") << ")" << endl;
        cout << "ChgRetV      : " << fnGetValue("ChgRetV") << " (" << fnGetRawValue("ChgRetV") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "BulkV") {
            return static_cast<uint32_t>(msg.uiBulkV);
        }
        else if (mnem == "FloatV") {
            return static_cast<uint32_t>(msg.uiFloatV);
        }
        else if (mnem == "ChgRetV") {
            return static_cast<uint32_t>(msg.uiChgRetV);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "BulkV") {
     msg.uiBulkV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "FloatV") {
     msg.uiFloatV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "ChgRetV") {
     msg.uiChgRetV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "BulkV") {
            return 0.05000000074505806 * (long double)(msg.uiBulkV + 0.0);
        }
        else if (mnem == "FloatV") {
            return 0.05000000074505806 * (long double)(msg.uiFloatV + 0.0);
        }
        else if (mnem == "ChgRetV") {
            return 0.05000000074505806 * (long double)(msg.uiChgRetV + 0.0);
        }
        return 0.0;
    }
} SccCfgSts2;

// Auto-generated class definition for RVC_tzPGN_SCC_ARRAY_STS
typedef struct SccArraySts : public MessageBase {
RVC_tzPGN_SCC_ARRAY_STS msg;
SccArraySts () {  memset(&msg, 0xFF, sizeof(msg));  };
SccArraySts (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_ARRAY_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "ArrayV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiArrayV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiArrayV == 0xffff) ? "No Data" : (msg.uiArrayV == 0xfffe) ? "Out of range" : (msg.uiArrayV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ArrayI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiArrayI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiArrayI == 0xffff) ? "No Data" : (msg.uiArrayI == 0xfffe) ? "Out of range" : (msg.uiArrayI == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccArraySts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "ArrayV      : " << fnGetValue("ArrayV") << " (" << fnGetRawValue("ArrayV") << ")" << endl;
        cout << "ArrayI      : " << fnGetValue("ArrayI") << " (" << fnGetRawValue("ArrayI") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "ArrayV") {
            return static_cast<uint32_t>(msg.uiArrayV);
        }
        else if (mnem == "ArrayI") {
            return static_cast<uint32_t>(msg.uiArrayI);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ArrayV") {
     msg.uiArrayV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "ArrayI") {
     msg.uiArrayI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnPvArrayPower") return fnPvArrayPower(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "ArrayV") {
            return 0.05000000074505806 * (long double)(msg.uiArrayV + 0.0);
        }
        else if (mnem == "ArrayI") {
            return 0.05000000074505806 * (long double)(msg.uiArrayI + -32000.0);
        }
        return 0.0;
    }
} SccArraySts;

// Auto-generated class definition for RVC_tzPGN_SCC_BATT_STS
typedef struct SccBattSts : public MessageBase {
RVC_tzPGN_SCC_BATT_STS msg;
SccBattSts () {  memset(&msg, 0xFF, sizeof(msg));  };
SccBattSts (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_BATT_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "DcSrcInst") {
            return std::to_string(msg.ucDcSrcInst);
        }
        else if (mnem == "ChgPriority") {
            return std::to_string(msg.ucChgPriority);
        }
        else if (mnem == "BattVolts") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBattVolts + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBattVolts == 0xffff) ? "No Data" : (msg.uiBattVolts == 0xfffe) ? "Out of range" : (msg.uiBattVolts == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BattCurrent") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBattCurrent + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiBattCurrent == 0xffff) ? "No Data" : (msg.uiBattCurrent == 0xfffe) ? "Out of range" : (msg.uiBattCurrent == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BattTemp") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucBattTemp + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucBattTemp == 0xff) ? "No Data" : (msg.ucBattTemp == 0xfe) ? "Out of range" : (msg.ucBattTemp == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccBattSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DcSrcInst      : " << fnGetValue("DcSrcInst") << " (" << fnGetRawValue("DcSrcInst") << ")" << endl;
        cout << "ChgPriority      : " << fnGetValue("ChgPriority") << " (" << fnGetRawValue("ChgPriority") << ")" << endl;
        cout << "BattVolts      : " << fnGetValue("BattVolts") << " (" << fnGetRawValue("BattVolts") << ")" << endl;
        cout << "BattCurrent      : " << fnGetValue("BattCurrent") << " (" << fnGetRawValue("BattCurrent") << ")" << endl;
        cout << "BattTemp      : " << fnGetValue("BattTemp") << " (" << fnGetRawValue("BattTemp") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "DcSrcInst") {
            return static_cast<uint32_t>(msg.ucDcSrcInst);
        }
        else if (mnem == "ChgPriority") {
            return static_cast<uint32_t>(msg.ucChgPriority);
        }
        else if (mnem == "BattVolts") {
            return static_cast<uint32_t>(msg.uiBattVolts);
        }
        else if (mnem == "BattCurrent") {
            return static_cast<uint32_t>(msg.uiBattCurrent);
        }
        else if (mnem == "BattTemp") {
            return static_cast<uint32_t>(msg.ucBattTemp);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DcSrcInst") {
     msg.ucDcSrcInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ChgPriority") {
     msg.ucChgPriority = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "BattVolts") {
     msg.uiBattVolts = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "BattCurrent") {
     msg.uiBattCurrent = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "BattTemp") {
     msg.ucBattTemp = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "DcSrcInst") {
            return 1.0 * (long double)(msg.ucDcSrcInst + 0.0);
        }
        else if (mnem == "ChgPriority") {
            return 1.0 * (long double)(msg.ucChgPriority + 0.0);
        }
        else if (mnem == "BattVolts") {
            return 0.05000000074505806 * (long double)(msg.uiBattVolts + 0.0);
        }
        else if (mnem == "BattCurrent") {
            return 0.05000000074505806 * (long double)(msg.uiBattCurrent + -32000.0);
        }
        else if (mnem == "BattTemp") {
            return 1.0 * (long double)(msg.ucBattTemp + -40.0);
        }
        return 0.0;
    }
} SccBattSts;

// Auto-generated class definition for RVC_tzPGN_SCC_STS6
typedef struct SccSts6 : public MessageBase {
RVC_tzPGN_SCC_STS6 msg;
SccSts6 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccSts6 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_STS6 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "OperatingDays") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiOperatingDays + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "days");
            return (msg.uiOperatingDays == 0xffff) ? "No Data" : (msg.uiOperatingDays == 0xfffe) ? "Out of range" : (msg.uiOperatingDays == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "IntTemp") {
            char buffer[50];
            auto engval = 0.03125 * (long double) (msg.uiIntTemp + -8736.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "deg C");
            return (msg.uiIntTemp == 0xffff) ? "No Data" : (msg.uiIntTemp == 0xfffe) ? "Out of range" : (msg.uiIntTemp == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccSts6" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "OperatingDays      : " << fnGetValue("OperatingDays") << " (" << fnGetRawValue("OperatingDays") << ")" << endl;
        cout << "IntTemp      : " << fnGetValue("IntTemp") << " (" << fnGetRawValue("IntTemp") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "OperatingDays") {
            return static_cast<uint32_t>(msg.uiOperatingDays);
        }
        else if (mnem == "IntTemp") {
            return static_cast<uint32_t>(msg.uiIntTemp);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "OperatingDays") {
     msg.uiOperatingDays = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "IntTemp") {
     msg.uiIntTemp = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.03125, -8736.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "OperatingDays") {
            return 1.0 * (long double)(msg.uiOperatingDays + 0.0);
        }
        else if (mnem == "IntTemp") {
            return 0.03125 * (long double)(msg.uiIntTemp + -8736.0);
        }
        return 0.0;
    }
} SccSts6;

// Auto-generated class definition for RVC_tzPGN_SCC_STS5
typedef struct SccSts5 : public MessageBase {
RVC_tzPGN_SCC_STS5 msg;
SccSts5 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccSts5 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_STS5 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "WeekAh") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiWeekAh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "AH");
            return (msg.uiWeekAh == 0xffff) ? "No Data" : (msg.uiWeekAh == 0xfffe) ? "Out of range" : (msg.uiWeekAh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "CumPwrGen") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ulCumPwrGen + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "kWh");
            return (msg.ulCumPwrGen == 0xffffffff) ? "No Data" : (msg.ulCumPwrGen == 0xfffffffe) ? "Out of range" : (msg.ulCumPwrGen == 0xfffffffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccSts5" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "WeekAh      : " << fnGetValue("WeekAh") << " (" << fnGetRawValue("WeekAh") << ")" << endl;
        cout << "CumPwrGen      : " << fnGetValue("CumPwrGen") << " (" << fnGetRawValue("CumPwrGen") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "WeekAh") {
            return static_cast<uint32_t>(msg.uiWeekAh);
        }
        else if (mnem == "CumPwrGen") {
            return static_cast<uint32_t>(msg.ulCumPwrGen);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "WeekAh") {
     msg.uiWeekAh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "CumPwrGen") {
     msg.ulCumPwrGen = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "WeekAh") {
            return 1.0 * (long double)(msg.uiWeekAh + 0.0);
        }
        else if (mnem == "CumPwrGen") {
            return 1.0 * (long double)(msg.ulCumPwrGen + 0.0);
        }
        return 0.0;
    }
} SccSts5;

// Auto-generated class definition for RVC_tzPGN_SCC_STS4
typedef struct SccSts4 : public MessageBase {
RVC_tzPGN_SCC_STS4 msg;
SccSts4 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccSts4 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_STS4 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "TodayAh") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiTodayAh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "AH");
            return (msg.uiTodayAh == 0xffff) ? "No Data" : (msg.uiTodayAh == 0xfffe) ? "Out of range" : (msg.uiTodayAh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "YesterdayAh") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiYesterdayAh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "AH");
            return (msg.uiYesterdayAh == 0xffff) ? "No Data" : (msg.uiYesterdayAh == 0xfffe) ? "Out of range" : (msg.uiYesterdayAh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BeforeYesterdayAh") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiBeforeYesterdayAh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "AH");
            return (msg.uiBeforeYesterdayAh == 0xffff) ? "No Data" : (msg.uiBeforeYesterdayAh == 0xfffe) ? "Out of range" : (msg.uiBeforeYesterdayAh == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccSts4" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "TodayAh      : " << fnGetValue("TodayAh") << " (" << fnGetRawValue("TodayAh") << ")" << endl;
        cout << "YesterdayAh      : " << fnGetValue("YesterdayAh") << " (" << fnGetRawValue("YesterdayAh") << ")" << endl;
        cout << "BeforeYesterdayAh      : " << fnGetValue("BeforeYesterdayAh") << " (" << fnGetRawValue("BeforeYesterdayAh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "TodayAh") {
            return static_cast<uint32_t>(msg.uiTodayAh);
        }
        else if (mnem == "YesterdayAh") {
            return static_cast<uint32_t>(msg.uiYesterdayAh);
        }
        else if (mnem == "BeforeYesterdayAh") {
            return static_cast<uint32_t>(msg.uiBeforeYesterdayAh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "TodayAh") {
     msg.uiTodayAh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "YesterdayAh") {
     msg.uiYesterdayAh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "BeforeYesterdayAh") {
     msg.uiBeforeYesterdayAh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "TodayAh") {
            return 1.0 * (long double)(msg.uiTodayAh + 0.0);
        }
        else if (mnem == "YesterdayAh") {
            return 1.0 * (long double)(msg.uiYesterdayAh + 0.0);
        }
        else if (mnem == "BeforeYesterdayAh") {
            return 1.0 * (long double)(msg.uiBeforeYesterdayAh + 0.0);
        }
        return 0.0;
    }
} SccSts4;

// Auto-generated class definition for RVC_tzPGN_SCC_STS3
typedef struct SccSts3 : public MessageBase {
RVC_tzPGN_SCC_STS3 msg;
SccSts3 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccSts3 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_STS3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "RatedPvV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiRatedPvV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiRatedPvV == 0xffff) ? "No Data" : (msg.uiRatedPvV == 0xfffe) ? "Out of range" : (msg.uiRatedPvV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "RatedPvI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiRatedPvI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiRatedPvI == 0xffff) ? "No Data" : (msg.uiRatedPvI == 0xfffe) ? "Out of range" : (msg.uiRatedPvI == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "RatedPvOverPwr") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiRatedPvOverPwr + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "W");
            return (msg.uiRatedPvOverPwr == 0xffff) ? "No Data" : (msg.uiRatedPvOverPwr == 0xfffe) ? "Out of range" : (msg.uiRatedPvOverPwr == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccSts3" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "RatedPvV      : " << fnGetValue("RatedPvV") << " (" << fnGetRawValue("RatedPvV") << ")" << endl;
        cout << "RatedPvI      : " << fnGetValue("RatedPvI") << " (" << fnGetRawValue("RatedPvI") << ")" << endl;
        cout << "RatedPvOverPwr      : " << fnGetValue("RatedPvOverPwr") << " (" << fnGetRawValue("RatedPvOverPwr") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "RatedPvV") {
            return static_cast<uint32_t>(msg.uiRatedPvV);
        }
        else if (mnem == "RatedPvI") {
            return static_cast<uint32_t>(msg.uiRatedPvI);
        }
        else if (mnem == "RatedPvOverPwr") {
            return static_cast<uint32_t>(msg.uiRatedPvOverPwr);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "RatedPvV") {
     msg.uiRatedPvV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "RatedPvI") {
     msg.uiRatedPvI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "RatedPvOverPwr") {
     msg.uiRatedPvOverPwr = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "RatedPvV") {
            return 0.05000000074505806 * (long double)(msg.uiRatedPvV + 0.0);
        }
        else if (mnem == "RatedPvI") {
            return 0.05000000074505806 * (long double)(msg.uiRatedPvI + -32000.0);
        }
        else if (mnem == "RatedPvOverPwr") {
            return 1.0 * (long double)(msg.uiRatedPvOverPwr + 0.0);
        }
        return 0.0;
    }
} SccSts3;

// Auto-generated class definition for RVC_tzPGN_SCC_STS2
typedef struct SccSts2 : public MessageBase {
RVC_tzPGN_SCC_STS2 msg;
SccSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
SccSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "RatedBattV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiRatedBattV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiRatedBattV == 0xffff) ? "No Data" : (msg.uiRatedBattV == 0xfffe) ? "Out of range" : (msg.uiRatedBattV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "RatedBattI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiRatedBattI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiRatedBattI == 0xffff) ? "No Data" : (msg.uiRatedBattI == 0xfffe) ? "Out of range" : (msg.uiRatedBattI == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccSts2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "RatedBattV      : " << fnGetValue("RatedBattV") << " (" << fnGetRawValue("RatedBattV") << ")" << endl;
        cout << "RatedBattI      : " << fnGetValue("RatedBattI") << " (" << fnGetRawValue("RatedBattI") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "RatedBattV") {
            return static_cast<uint32_t>(msg.uiRatedBattV);
        }
        else if (mnem == "RatedBattI") {
            return static_cast<uint32_t>(msg.uiRatedBattI);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "RatedBattV") {
     msg.uiRatedBattV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "RatedBattI") {
     msg.uiRatedBattI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "RatedBattV") {
            return 0.05000000074505806 * (long double)(msg.uiRatedBattV + 0.0);
        }
        else if (mnem == "RatedBattI") {
            return 0.05000000074505806 * (long double)(msg.uiRatedBattI + -32000.0);
        }
        return 0.0;
    }
} SccSts2;

// Auto-generated class definition for RVC_tzPGN_BATT_CMD
typedef struct BattCmd : public MessageBase {
RVC_tzPGN_BATT_CMD msg;
BattCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
BattCmd (void * pvStruct) {  msg = *(RVC_tzPGN_BATT_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            if (ENUMLOOKUP[421711928].find(msg.teBattInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teBattInst];
              }
        }
        else if (mnem == "DesiredLoadOnOffSts") {
            if (ENUMLOOKUP[9075].find(msg.teDesiredLoadOnOffSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDesiredLoadOnOffSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teDesiredLoadOnOffSts];
              }
        }
        else if (mnem == "DesiredChgOnOffSts") {
            if (ENUMLOOKUP[9075].find(msg.teDesiredChgOnOffSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDesiredChgOnOffSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teDesiredChgOnOffSts];
              }
        }
        else if (mnem == "ClrHistory") {
            if (ENUMLOOKUP[9075].find(msg.teClrHistory) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teClrHistory);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teClrHistory];
              }
        }
        else if (mnem == "RtnModuleCellDetail") {
            return (msg.ucRtnModuleCellDetail == 0xff) ? "No Data" : (msg.ucRtnModuleCellDetail == 0xfe) ? "Out of range" : (msg.ucRtnModuleCellDetail == 0xfd) ? "Reserved" : std::to_string(msg.ucRtnModuleCellDetail);
        }
        else if (mnem == "DcInst") {
            if (ENUMLOOKUP[421711928].find(msg.teDcInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDcInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teDcInst];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: BattCmd" << std::endl;
        cout << "BattInst      : " << fnGetValue("BattInst") << " (" << fnGetRawValue("BattInst") << ")" << endl;
        cout << "DesiredLoadOnOffSts      : " << fnGetValue("DesiredLoadOnOffSts") << " (" << fnGetRawValue("DesiredLoadOnOffSts") << ")" << endl;
        cout << "DesiredChgOnOffSts      : " << fnGetValue("DesiredChgOnOffSts") << " (" << fnGetRawValue("DesiredChgOnOffSts") << ")" << endl;
        cout << "ClrHistory      : " << fnGetValue("ClrHistory") << " (" << fnGetRawValue("ClrHistory") << ")" << endl;
        cout << "RtnModuleCellDetail      : " << fnGetValue("RtnModuleCellDetail") << " (" << fnGetRawValue("RtnModuleCellDetail") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return static_cast<uint32_t>(msg.teBattInst);
        }
        else if (mnem == "DesiredLoadOnOffSts") {
            return static_cast<uint32_t>(msg.teDesiredLoadOnOffSts);
        }
        else if (mnem == "DesiredChgOnOffSts") {
            return static_cast<uint32_t>(msg.teDesiredChgOnOffSts);
        }
        else if (mnem == "ClrHistory") {
            return static_cast<uint32_t>(msg.teClrHistory);
        }
        else if (mnem == "RtnModuleCellDetail") {
            return static_cast<uint32_t>(msg.ucRtnModuleCellDetail);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.teDcInst);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "BattInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teBattInst = static_cast<decltype(msg.teBattInst)>(enumValue);
     else msg.teBattInst = static_cast<decltype(msg.teBattInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DesiredLoadOnOffSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teDesiredLoadOnOffSts = static_cast<decltype(msg.teDesiredLoadOnOffSts)>(enumValue);
     else msg.teDesiredLoadOnOffSts = static_cast<decltype(msg.teDesiredLoadOnOffSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DesiredChgOnOffSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teDesiredChgOnOffSts = static_cast<decltype(msg.teDesiredChgOnOffSts)>(enumValue);
     else msg.teDesiredChgOnOffSts = static_cast<decltype(msg.teDesiredChgOnOffSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ClrHistory") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teClrHistory = static_cast<decltype(msg.teClrHistory)>(enumValue);
     else msg.teClrHistory = static_cast<decltype(msg.teClrHistory)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RtnModuleCellDetail") {
     msg.ucRtnModuleCellDetail = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teDcInst = static_cast<decltype(msg.teDcInst)>(enumValue);
     else msg.teDcInst = static_cast<decltype(msg.teDcInst)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return 1.0 * (long double)(msg.teBattInst + 0.0);
        }
        else if (mnem == "DesiredLoadOnOffSts") {
            return 1.0 * (long double)(msg.teDesiredLoadOnOffSts + 0.0);
        }
        else if (mnem == "DesiredChgOnOffSts") {
            return 1.0 * (long double)(msg.teDesiredChgOnOffSts + 0.0);
        }
        else if (mnem == "ClrHistory") {
            return 1.0 * (long double)(msg.teClrHistory + 0.0);
        }
        else if (mnem == "RtnModuleCellDetail") {
            return 1.0 * (long double)(msg.ucRtnModuleCellDetail + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.teDcInst + 0.0);
        }
        return 0.0;
    }
} BattCmd;

// Auto-generated class definition for RVC_tzPGN_BATT_STS11
typedef struct BattSts11 : public MessageBase {
RVC_tzPGN_BATT_STS11 msg;
BattSts11 () {  memset(&msg, 0xFF, sizeof(msg));  };
BattSts11 (void * pvStruct) {  msg = *(RVC_tzPGN_BATT_STS11 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            if (ENUMLOOKUP[421711928].find(msg.teBattInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teBattInst];
              }
        }
        else if (mnem == "DcInst") {
            if (ENUMLOOKUP[421711928].find(msg.teDcInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDcInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teDcInst];
              }
        }
        else if (mnem == "DischgOnOffSts") {
            if (ENUMLOOKUP[9075].find(msg.teDischgOnOffSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDischgOnOffSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teDischgOnOffSts];
              }
        }
        else if (mnem == "ChgOnOffSts") {
            if (ENUMLOOKUP[9075].find(msg.teChgOnOffSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgOnOffSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teChgOnOffSts];
              }
        }
        else if (mnem == "ChgDetect") {
            if (ENUMLOOKUP[9075].find(msg.teChgDetect) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgDetect);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teChgDetect];
              }
        }
        else if (mnem == "ReservSts") {
            if (ENUMLOOKUP[9075].find(msg.teReservSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teReservSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teReservSts];
              }
        }
        else if (mnem == "NomFullCap") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiNomFullCap + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "AH");
            return (msg.uiNomFullCap == 0xffff) ? "No Data" : (msg.uiNomFullCap == 0xfffe) ? "Out of range" : (msg.uiNomFullCap == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DcPwr") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiDcPwr + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "W");
            return (msg.uiDcPwr == 0xffff) ? "No Data" : (msg.uiDcPwr == 0xfffe) ? "Out of range" : (msg.uiDcPwr == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: BattSts11" << std::endl;
        cout << "BattInst      : " << fnGetValue("BattInst") << " (" << fnGetRawValue("BattInst") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "DischgOnOffSts      : " << fnGetValue("DischgOnOffSts") << " (" << fnGetRawValue("DischgOnOffSts") << ")" << endl;
        cout << "ChgOnOffSts      : " << fnGetValue("ChgOnOffSts") << " (" << fnGetRawValue("ChgOnOffSts") << ")" << endl;
        cout << "ChgDetect      : " << fnGetValue("ChgDetect") << " (" << fnGetRawValue("ChgDetect") << ")" << endl;
        cout << "ReservSts      : " << fnGetValue("ReservSts") << " (" << fnGetRawValue("ReservSts") << ")" << endl;
        cout << "NomFullCap      : " << fnGetValue("NomFullCap") << " (" << fnGetRawValue("NomFullCap") << ")" << endl;
        cout << "DcPwr      : " << fnGetValue("DcPwr") << " (" << fnGetRawValue("DcPwr") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return static_cast<uint32_t>(msg.teBattInst);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.teDcInst);
        }
        else if (mnem == "DischgOnOffSts") {
            return static_cast<uint32_t>(msg.teDischgOnOffSts);
        }
        else if (mnem == "ChgOnOffSts") {
            return static_cast<uint32_t>(msg.teChgOnOffSts);
        }
        else if (mnem == "ChgDetect") {
            return static_cast<uint32_t>(msg.teChgDetect);
        }
        else if (mnem == "ReservSts") {
            return static_cast<uint32_t>(msg.teReservSts);
        }
        else if (mnem == "NomFullCap") {
            return static_cast<uint32_t>(msg.uiNomFullCap);
        }
        else if (mnem == "DcPwr") {
            return static_cast<uint32_t>(msg.uiDcPwr);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "BattInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teBattInst = static_cast<decltype(msg.teBattInst)>(enumValue);
     else msg.teBattInst = static_cast<decltype(msg.teBattInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teDcInst = static_cast<decltype(msg.teDcInst)>(enumValue);
     else msg.teDcInst = static_cast<decltype(msg.teDcInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DischgOnOffSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teDischgOnOffSts = static_cast<decltype(msg.teDischgOnOffSts)>(enumValue);
     else msg.teDischgOnOffSts = static_cast<decltype(msg.teDischgOnOffSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgOnOffSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teChgOnOffSts = static_cast<decltype(msg.teChgOnOffSts)>(enumValue);
     else msg.teChgOnOffSts = static_cast<decltype(msg.teChgOnOffSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgDetect") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teChgDetect = static_cast<decltype(msg.teChgDetect)>(enumValue);
     else msg.teChgDetect = static_cast<decltype(msg.teChgDetect)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ReservSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teReservSts = static_cast<decltype(msg.teReservSts)>(enumValue);
     else msg.teReservSts = static_cast<decltype(msg.teReservSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "NomFullCap") {
     msg.uiNomFullCap = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "DcPwr") {
     msg.uiDcPwr = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return 1.0 * (long double)(msg.teBattInst + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.teDcInst + 0.0);
        }
        else if (mnem == "DischgOnOffSts") {
            return 1.0 * (long double)(msg.teDischgOnOffSts + 0.0);
        }
        else if (mnem == "ChgOnOffSts") {
            return 1.0 * (long double)(msg.teChgOnOffSts + 0.0);
        }
        else if (mnem == "ChgDetect") {
            return 1.0 * (long double)(msg.teChgDetect + 0.0);
        }
        else if (mnem == "ReservSts") {
            return 1.0 * (long double)(msg.teReservSts + 0.0);
        }
        else if (mnem == "NomFullCap") {
            return 1.0 * (long double)(msg.uiNomFullCap + 0.0);
        }
        else if (mnem == "DcPwr") {
            return 1.0 * (long double)(msg.uiDcPwr + 0.0);
        }
        return 0.0;
    }
} BattSts11;

// Auto-generated class definition for RVC_tzPGN_BATT_STS6
typedef struct BattSts6 : public MessageBase {
RVC_tzPGN_BATT_STS6 msg;
BattSts6 () {  memset(&msg, 0xFF, sizeof(msg));  };
BattSts6 (void * pvStruct) {  msg = *(RVC_tzPGN_BATT_STS6 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            if (ENUMLOOKUP[421711928].find(msg.teBattInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teBattInst];
              }
        }
        else if (mnem == "DcInst") {
            if (ENUMLOOKUP[421711928].find(msg.teDcInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDcInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teDcInst];
              }
        }
        else if (mnem == "HiVoltLimitSts") {
            if (ENUMLOOKUP[9075].find(msg.teHiVoltLimitSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHiVoltLimitSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teHiVoltLimitSts];
              }
        }
        else if (mnem == "HiVoltDisconSts") {
            if (ENUMLOOKUP[276767036].find(msg.teHiVoltDisconSts) == ENUMLOOKUP[276767036].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHiVoltDisconSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[276767036][msg.teHiVoltDisconSts];
              }
        }
        else if (mnem == "LowVoltLimitSts") {
            if (ENUMLOOKUP[9075].find(msg.teLowVoltLimitSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowVoltLimitSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teLowVoltLimitSts];
              }
        }
        else if (mnem == "LowVoltDisconSts") {
            if (ENUMLOOKUP[276767036].find(msg.teLowVoltDisconSts) == ENUMLOOKUP[276767036].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowVoltDisconSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[276767036][msg.teLowVoltDisconSts];
              }
        }
        else if (mnem == "LowSocLimitSts") {
            if (ENUMLOOKUP[9075].find(msg.teLowSocLimitSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowSocLimitSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teLowSocLimitSts];
              }
        }
        else if (mnem == "LowSocDisconSts") {
            if (ENUMLOOKUP[276767036].find(msg.teLowSocDisconSts) == ENUMLOOKUP[276767036].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowSocDisconSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[276767036][msg.teLowSocDisconSts];
              }
        }
        else if (mnem == "LowDcSrcTempLimitSts") {
            if (ENUMLOOKUP[9075].find(msg.teLowDcSrcTempLimitSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowDcSrcTempLimitSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teLowDcSrcTempLimitSts];
              }
        }
        else if (mnem == "LowDcSrcTempDisconSts") {
            if (ENUMLOOKUP[276767036].find(msg.teLowDcSrcTempDisconSts) == ENUMLOOKUP[276767036].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowDcSrcTempDisconSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[276767036][msg.teLowDcSrcTempDisconSts];
              }
        }
        else if (mnem == "HiDcSrcTempLimitSts") {
            if (ENUMLOOKUP[9075].find(msg.teHiDcSrcTempLimitSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHiDcSrcTempLimitSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teHiDcSrcTempLimitSts];
              }
        }
        else if (mnem == "HiDcSrcTempDisconSts") {
            if (ENUMLOOKUP[276767036].find(msg.teHiDcSrcTempDisconSts) == ENUMLOOKUP[276767036].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHiDcSrcTempDisconSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[276767036][msg.teHiDcSrcTempDisconSts];
              }
        }
        else if (mnem == "HiAmpDcSrcLimitSts") {
            if (ENUMLOOKUP[9075].find(msg.teHiAmpDcSrcLimitSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHiAmpDcSrcLimitSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teHiAmpDcSrcLimitSts];
              }
        }
        else if (mnem == "HiAmpDcSrcDisconSts") {
            if (ENUMLOOKUP[276767036].find(msg.teHiAmpDcSrcDisconSts) == ENUMLOOKUP[276767036].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHiAmpDcSrcDisconSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[276767036][msg.teHiAmpDcSrcDisconSts];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: BattSts6" << std::endl;
        cout << "BattInst      : " << fnGetValue("BattInst") << " (" << fnGetRawValue("BattInst") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "HiVoltLimitSts      : " << fnGetValue("HiVoltLimitSts") << " (" << fnGetRawValue("HiVoltLimitSts") << ")" << endl;
        cout << "HiVoltDisconSts      : " << fnGetValue("HiVoltDisconSts") << " (" << fnGetRawValue("HiVoltDisconSts") << ")" << endl;
        cout << "LowVoltLimitSts      : " << fnGetValue("LowVoltLimitSts") << " (" << fnGetRawValue("LowVoltLimitSts") << ")" << endl;
        cout << "LowVoltDisconSts      : " << fnGetValue("LowVoltDisconSts") << " (" << fnGetRawValue("LowVoltDisconSts") << ")" << endl;
        cout << "LowSocLimitSts      : " << fnGetValue("LowSocLimitSts") << " (" << fnGetRawValue("LowSocLimitSts") << ")" << endl;
        cout << "LowSocDisconSts      : " << fnGetValue("LowSocDisconSts") << " (" << fnGetRawValue("LowSocDisconSts") << ")" << endl;
        cout << "LowDcSrcTempLimitSts      : " << fnGetValue("LowDcSrcTempLimitSts") << " (" << fnGetRawValue("LowDcSrcTempLimitSts") << ")" << endl;
        cout << "LowDcSrcTempDisconSts      : " << fnGetValue("LowDcSrcTempDisconSts") << " (" << fnGetRawValue("LowDcSrcTempDisconSts") << ")" << endl;
        cout << "HiDcSrcTempLimitSts      : " << fnGetValue("HiDcSrcTempLimitSts") << " (" << fnGetRawValue("HiDcSrcTempLimitSts") << ")" << endl;
        cout << "HiDcSrcTempDisconSts      : " << fnGetValue("HiDcSrcTempDisconSts") << " (" << fnGetRawValue("HiDcSrcTempDisconSts") << ")" << endl;
        cout << "HiAmpDcSrcLimitSts      : " << fnGetValue("HiAmpDcSrcLimitSts") << " (" << fnGetRawValue("HiAmpDcSrcLimitSts") << ")" << endl;
        cout << "HiAmpDcSrcDisconSts      : " << fnGetValue("HiAmpDcSrcDisconSts") << " (" << fnGetRawValue("HiAmpDcSrcDisconSts") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return static_cast<uint32_t>(msg.teBattInst);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.teDcInst);
        }
        else if (mnem == "HiVoltLimitSts") {
            return static_cast<uint32_t>(msg.teHiVoltLimitSts);
        }
        else if (mnem == "HiVoltDisconSts") {
            return static_cast<uint32_t>(msg.teHiVoltDisconSts);
        }
        else if (mnem == "LowVoltLimitSts") {
            return static_cast<uint32_t>(msg.teLowVoltLimitSts);
        }
        else if (mnem == "LowVoltDisconSts") {
            return static_cast<uint32_t>(msg.teLowVoltDisconSts);
        }
        else if (mnem == "LowSocLimitSts") {
            return static_cast<uint32_t>(msg.teLowSocLimitSts);
        }
        else if (mnem == "LowSocDisconSts") {
            return static_cast<uint32_t>(msg.teLowSocDisconSts);
        }
        else if (mnem == "LowDcSrcTempLimitSts") {
            return static_cast<uint32_t>(msg.teLowDcSrcTempLimitSts);
        }
        else if (mnem == "LowDcSrcTempDisconSts") {
            return static_cast<uint32_t>(msg.teLowDcSrcTempDisconSts);
        }
        else if (mnem == "HiDcSrcTempLimitSts") {
            return static_cast<uint32_t>(msg.teHiDcSrcTempLimitSts);
        }
        else if (mnem == "HiDcSrcTempDisconSts") {
            return static_cast<uint32_t>(msg.teHiDcSrcTempDisconSts);
        }
        else if (mnem == "HiAmpDcSrcLimitSts") {
            return static_cast<uint32_t>(msg.teHiAmpDcSrcLimitSts);
        }
        else if (mnem == "HiAmpDcSrcDisconSts") {
            return static_cast<uint32_t>(msg.teHiAmpDcSrcDisconSts);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "BattInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teBattInst = static_cast<decltype(msg.teBattInst)>(enumValue);
     else msg.teBattInst = static_cast<decltype(msg.teBattInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teDcInst = static_cast<decltype(msg.teDcInst)>(enumValue);
     else msg.teDcInst = static_cast<decltype(msg.teDcInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiVoltLimitSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teHiVoltLimitSts = static_cast<decltype(msg.teHiVoltLimitSts)>(enumValue);
     else msg.teHiVoltLimitSts = static_cast<decltype(msg.teHiVoltLimitSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiVoltDisconSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[276767036], value);
     if (enumValue != -1) msg.teHiVoltDisconSts = static_cast<decltype(msg.teHiVoltDisconSts)>(enumValue);
     else msg.teHiVoltDisconSts = static_cast<decltype(msg.teHiVoltDisconSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowVoltLimitSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teLowVoltLimitSts = static_cast<decltype(msg.teLowVoltLimitSts)>(enumValue);
     else msg.teLowVoltLimitSts = static_cast<decltype(msg.teLowVoltLimitSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowVoltDisconSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[276767036], value);
     if (enumValue != -1) msg.teLowVoltDisconSts = static_cast<decltype(msg.teLowVoltDisconSts)>(enumValue);
     else msg.teLowVoltDisconSts = static_cast<decltype(msg.teLowVoltDisconSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowSocLimitSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teLowSocLimitSts = static_cast<decltype(msg.teLowSocLimitSts)>(enumValue);
     else msg.teLowSocLimitSts = static_cast<decltype(msg.teLowSocLimitSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowSocDisconSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[276767036], value);
     if (enumValue != -1) msg.teLowSocDisconSts = static_cast<decltype(msg.teLowSocDisconSts)>(enumValue);
     else msg.teLowSocDisconSts = static_cast<decltype(msg.teLowSocDisconSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowDcSrcTempLimitSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teLowDcSrcTempLimitSts = static_cast<decltype(msg.teLowDcSrcTempLimitSts)>(enumValue);
     else msg.teLowDcSrcTempLimitSts = static_cast<decltype(msg.teLowDcSrcTempLimitSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowDcSrcTempDisconSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[276767036], value);
     if (enumValue != -1) msg.teLowDcSrcTempDisconSts = static_cast<decltype(msg.teLowDcSrcTempDisconSts)>(enumValue);
     else msg.teLowDcSrcTempDisconSts = static_cast<decltype(msg.teLowDcSrcTempDisconSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiDcSrcTempLimitSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teHiDcSrcTempLimitSts = static_cast<decltype(msg.teHiDcSrcTempLimitSts)>(enumValue);
     else msg.teHiDcSrcTempLimitSts = static_cast<decltype(msg.teHiDcSrcTempLimitSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiDcSrcTempDisconSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[276767036], value);
     if (enumValue != -1) msg.teHiDcSrcTempDisconSts = static_cast<decltype(msg.teHiDcSrcTempDisconSts)>(enumValue);
     else msg.teHiDcSrcTempDisconSts = static_cast<decltype(msg.teHiDcSrcTempDisconSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiAmpDcSrcLimitSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teHiAmpDcSrcLimitSts = static_cast<decltype(msg.teHiAmpDcSrcLimitSts)>(enumValue);
     else msg.teHiAmpDcSrcLimitSts = static_cast<decltype(msg.teHiAmpDcSrcLimitSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiAmpDcSrcDisconSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[276767036], value);
     if (enumValue != -1) msg.teHiAmpDcSrcDisconSts = static_cast<decltype(msg.teHiAmpDcSrcDisconSts)>(enumValue);
     else msg.teHiAmpDcSrcDisconSts = static_cast<decltype(msg.teHiAmpDcSrcDisconSts)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return 1.0 * (long double)(msg.teBattInst + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.teDcInst + 0.0);
        }
        else if (mnem == "HiVoltLimitSts") {
            return 1.0 * (long double)(msg.teHiVoltLimitSts + 0.0);
        }
        else if (mnem == "HiVoltDisconSts") {
            return 1.0 * (long double)(msg.teHiVoltDisconSts + 0.0);
        }
        else if (mnem == "LowVoltLimitSts") {
            return 1.0 * (long double)(msg.teLowVoltLimitSts + 0.0);
        }
        else if (mnem == "LowVoltDisconSts") {
            return 1.0 * (long double)(msg.teLowVoltDisconSts + 0.0);
        }
        else if (mnem == "LowSocLimitSts") {
            return 1.0 * (long double)(msg.teLowSocLimitSts + 0.0);
        }
        else if (mnem == "LowSocDisconSts") {
            return 1.0 * (long double)(msg.teLowSocDisconSts + 0.0);
        }
        else if (mnem == "LowDcSrcTempLimitSts") {
            return 1.0 * (long double)(msg.teLowDcSrcTempLimitSts + 0.0);
        }
        else if (mnem == "LowDcSrcTempDisconSts") {
            return 1.0 * (long double)(msg.teLowDcSrcTempDisconSts + 0.0);
        }
        else if (mnem == "HiDcSrcTempLimitSts") {
            return 1.0 * (long double)(msg.teHiDcSrcTempLimitSts + 0.0);
        }
        else if (mnem == "HiDcSrcTempDisconSts") {
            return 1.0 * (long double)(msg.teHiDcSrcTempDisconSts + 0.0);
        }
        else if (mnem == "HiAmpDcSrcLimitSts") {
            return 1.0 * (long double)(msg.teHiAmpDcSrcLimitSts + 0.0);
        }
        else if (mnem == "HiAmpDcSrcDisconSts") {
            return 1.0 * (long double)(msg.teHiAmpDcSrcDisconSts + 0.0);
        }
        return 0.0;
    }
} BattSts6;

// Auto-generated class definition for RVC_tzPGN_BATT_STS4
typedef struct BattSts4 : public MessageBase {
RVC_tzPGN_BATT_STS4 msg;
BattSts4 () {  memset(&msg, 0xFF, sizeof(msg));  };
BattSts4 (void * pvStruct) {  msg = *(RVC_tzPGN_BATT_STS4 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            if (ENUMLOOKUP[421711928].find(msg.teBattInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teBattInst];
              }
        }
        else if (mnem == "DcInst") {
            if (ENUMLOOKUP[421711928].find(msg.teDcInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDcInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teDcInst];
              }
        }
        else if (mnem == "DesChgState") {
            if (ENUMLOOKUP[1599683911].find(msg.teDesChgState) == ENUMLOOKUP[1599683911].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDesChgState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1599683911][msg.teDesChgState];
              }
        }
        else if (mnem == "DesDcV") {
            return (msg.uiDesDcV == 0xffff) ? "No Data" : (msg.uiDesDcV == 0xfffe) ? "Out of range" : (msg.uiDesDcV == 0xfffd) ? "Reserved" : std::to_string(msg.uiDesDcV);
        }
        else if (mnem == "DesDcI") {
            return (msg.uiDesDcI == 0xffff) ? "No Data" : (msg.uiDesDcI == 0xfffe) ? "Out of range" : (msg.uiDesDcI == 0xfffd) ? "Reserved" : std::to_string(msg.uiDesDcI);
        }
        else if (mnem == "BattType") {
            if (ENUMLOOKUP[9410].find(msg.teBattType) == ENUMLOOKUP[9410].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9410][msg.teBattType];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: BattSts4" << std::endl;
        cout << "BattInst      : " << fnGetValue("BattInst") << " (" << fnGetRawValue("BattInst") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "DesChgState      : " << fnGetValue("DesChgState") << " (" << fnGetRawValue("DesChgState") << ")" << endl;
        cout << "DesDcV      : " << fnGetValue("DesDcV") << " (" << fnGetRawValue("DesDcV") << ")" << endl;
        cout << "DesDcI      : " << fnGetValue("DesDcI") << " (" << fnGetRawValue("DesDcI") << ")" << endl;
        cout << "BattType      : " << fnGetValue("BattType") << " (" << fnGetRawValue("BattType") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return static_cast<uint32_t>(msg.teBattInst);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.teDcInst);
        }
        else if (mnem == "DesChgState") {
            return static_cast<uint32_t>(msg.teDesChgState);
        }
        else if (mnem == "DesDcV") {
            return static_cast<uint32_t>(msg.uiDesDcV);
        }
        else if (mnem == "DesDcI") {
            return static_cast<uint32_t>(msg.uiDesDcI);
        }
        else if (mnem == "BattType") {
            return static_cast<uint32_t>(msg.teBattType);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "BattInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teBattInst = static_cast<decltype(msg.teBattInst)>(enumValue);
     else msg.teBattInst = static_cast<decltype(msg.teBattInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teDcInst = static_cast<decltype(msg.teDcInst)>(enumValue);
     else msg.teDcInst = static_cast<decltype(msg.teDcInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DesChgState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1599683911], value);
     if (enumValue != -1) msg.teDesChgState = static_cast<decltype(msg.teDesChgState)>(enumValue);
     else msg.teDesChgState = static_cast<decltype(msg.teDesChgState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DesDcV") {
     msg.uiDesDcV = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "DesDcI") {
     msg.uiDesDcI = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "BattType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9410], value);
     if (enumValue != -1) msg.teBattType = static_cast<decltype(msg.teBattType)>(enumValue);
     else msg.teBattType = static_cast<decltype(msg.teBattType)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return 1.0 * (long double)(msg.teBattInst + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.teDcInst + 0.0);
        }
        else if (mnem == "DesChgState") {
            return 1.0 * (long double)(msg.teDesChgState + 0.0);
        }
        else if (mnem == "DesDcV") {
            return 1.0 * (long double)(msg.uiDesDcV + 0.0);
        }
        else if (mnem == "DesDcI") {
            return 1.0 * (long double)(msg.uiDesDcI + 0.0);
        }
        else if (mnem == "BattType") {
            return 1.0 * (long double)(msg.teBattType + 0.0);
        }
        return 0.0;
    }
} BattSts4;

// Auto-generated class definition for RVC_tzPGN_BATT_STS3
typedef struct BattSts3 : public MessageBase {
RVC_tzPGN_BATT_STS3 msg;
BattSts3 () {  memset(&msg, 0xFF, sizeof(msg));  };
BattSts3 (void * pvStruct) {  msg = *(RVC_tzPGN_BATT_STS3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            if (ENUMLOOKUP[421711928].find(msg.teBattInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teBattInst];
              }
        }
        else if (mnem == "DcInst") {
            if (ENUMLOOKUP[421711928].find(msg.teDcInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDcInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teDcInst];
              }
        }
        else if (mnem == "Soh") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucSoh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucSoh == 0xff) ? "No Data" : (msg.ucSoh == 0xfe) ? "Out of range" : (msg.ucSoh == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "CapRemain") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiCapRemain + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "AH");
            return (msg.uiCapRemain == 0xffff) ? "No Data" : (msg.uiCapRemain == 0xfffe) ? "Out of range" : (msg.uiCapRemain == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "RelCap") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucRelCap + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucRelCap == 0xff) ? "No Data" : (msg.ucRelCap == 0xfe) ? "Out of range" : (msg.ucRelCap == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "AcRmsRipple") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiAcRmsRipple + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "mV");
            return (msg.uiAcRmsRipple == 0xffff) ? "No Data" : (msg.uiAcRmsRipple == 0xfffe) ? "Out of range" : (msg.uiAcRmsRipple == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: BattSts3" << std::endl;
        cout << "BattInst      : " << fnGetValue("BattInst") << " (" << fnGetRawValue("BattInst") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "Soh      : " << fnGetValue("Soh") << " (" << fnGetRawValue("Soh") << ")" << endl;
        cout << "CapRemain      : " << fnGetValue("CapRemain") << " (" << fnGetRawValue("CapRemain") << ")" << endl;
        cout << "RelCap      : " << fnGetValue("RelCap") << " (" << fnGetRawValue("RelCap") << ")" << endl;
        cout << "AcRmsRipple      : " << fnGetValue("AcRmsRipple") << " (" << fnGetRawValue("AcRmsRipple") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return static_cast<uint32_t>(msg.teBattInst);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.teDcInst);
        }
        else if (mnem == "Soh") {
            return static_cast<uint32_t>(msg.ucSoh);
        }
        else if (mnem == "CapRemain") {
            return static_cast<uint32_t>(msg.uiCapRemain);
        }
        else if (mnem == "RelCap") {
            return static_cast<uint32_t>(msg.ucRelCap);
        }
        else if (mnem == "AcRmsRipple") {
            return static_cast<uint32_t>(msg.uiAcRmsRipple);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "BattInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teBattInst = static_cast<decltype(msg.teBattInst)>(enumValue);
     else msg.teBattInst = static_cast<decltype(msg.teBattInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teDcInst = static_cast<decltype(msg.teDcInst)>(enumValue);
     else msg.teDcInst = static_cast<decltype(msg.teDcInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Soh") {
     msg.ucSoh = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "CapRemain") {
     msg.uiCapRemain = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "RelCap") {
     msg.ucRelCap = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "AcRmsRipple") {
     msg.uiAcRmsRipple = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return 1.0 * (long double)(msg.teBattInst + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.teDcInst + 0.0);
        }
        else if (mnem == "Soh") {
            return 0.5 * (long double)(msg.ucSoh + 0.0);
        }
        else if (mnem == "CapRemain") {
            return 1.0 * (long double)(msg.uiCapRemain + 0.0);
        }
        else if (mnem == "RelCap") {
            return 0.5 * (long double)(msg.ucRelCap + 0.0);
        }
        else if (mnem == "AcRmsRipple") {
            return 1.0 * (long double)(msg.uiAcRmsRipple + 0.0);
        }
        return 0.0;
    }
} BattSts3;

// Auto-generated class definition for RVC_tzPGN_BATT_STS2
typedef struct BattSts2 : public MessageBase {
RVC_tzPGN_BATT_STS2 msg;
BattSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
BattSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_BATT_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            if (ENUMLOOKUP[421711928].find(msg.teBattInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teBattInst];
              }
        }
        else if (mnem == "DcInst") {
            if (ENUMLOOKUP[421711928].find(msg.teDcInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDcInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teDcInst];
              }
        }
        else if (mnem == "SrcTemp") {
            char buffer[50];
            auto engval = 0.03125 * (long double) (msg.uiSrcTemp + -8736.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "deg C");
            return (msg.uiSrcTemp == 0xffff) ? "No Data" : (msg.uiSrcTemp == 0xfffe) ? "Out of range" : (msg.uiSrcTemp == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Soc") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucSoc + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucSoc == 0xff) ? "No Data" : (msg.ucSoc == 0xfe) ? "Out of range" : (msg.ucSoc == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeRemain") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiTimeRemain + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiTimeRemain == 0xffff) ? "No Data" : (msg.uiTimeRemain == 0xfffe) ? "Out of range" : (msg.uiTimeRemain == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeRemainInterp") {
            if (ENUMLOOKUP[972277822].find(msg.teTimeRemainInterp) == ENUMLOOKUP[972277822].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teTimeRemainInterp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[972277822][msg.teTimeRemainInterp];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: BattSts2" << std::endl;
        cout << "BattInst      : " << fnGetValue("BattInst") << " (" << fnGetRawValue("BattInst") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "SrcTemp      : " << fnGetValue("SrcTemp") << " (" << fnGetRawValue("SrcTemp") << ")" << endl;
        cout << "Soc      : " << fnGetValue("Soc") << " (" << fnGetRawValue("Soc") << ")" << endl;
        cout << "TimeRemain      : " << fnGetValue("TimeRemain") << " (" << fnGetRawValue("TimeRemain") << ")" << endl;
        cout << "TimeRemainInterp      : " << fnGetValue("TimeRemainInterp") << " (" << fnGetRawValue("TimeRemainInterp") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return static_cast<uint32_t>(msg.teBattInst);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.teDcInst);
        }
        else if (mnem == "SrcTemp") {
            return static_cast<uint32_t>(msg.uiSrcTemp);
        }
        else if (mnem == "Soc") {
            return static_cast<uint32_t>(msg.ucSoc);
        }
        else if (mnem == "TimeRemain") {
            return static_cast<uint32_t>(msg.uiTimeRemain);
        }
        else if (mnem == "TimeRemainInterp") {
            return static_cast<uint32_t>(msg.teTimeRemainInterp);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "BattInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teBattInst = static_cast<decltype(msg.teBattInst)>(enumValue);
     else msg.teBattInst = static_cast<decltype(msg.teBattInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teDcInst = static_cast<decltype(msg.teDcInst)>(enumValue);
     else msg.teDcInst = static_cast<decltype(msg.teDcInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SrcTemp") {
     msg.uiSrcTemp = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.03125, -8736.0);
        }
        else if (mnem == "Soc") {
     msg.ucSoc = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "TimeRemain") {
     msg.uiTimeRemain = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "TimeRemainInterp") {
     int enumValue = findEnumValue(ENUMLOOKUP[972277822], value);
     if (enumValue != -1) msg.teTimeRemainInterp = static_cast<decltype(msg.teTimeRemainInterp)>(enumValue);
     else msg.teTimeRemainInterp = static_cast<decltype(msg.teTimeRemainInterp)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return 1.0 * (long double)(msg.teBattInst + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.teDcInst + 0.0);
        }
        else if (mnem == "SrcTemp") {
            return 0.03125 * (long double)(msg.uiSrcTemp + -8736.0);
        }
        else if (mnem == "Soc") {
            return 0.5 * (long double)(msg.ucSoc + 0.0);
        }
        else if (mnem == "TimeRemain") {
            return 1.0 * (long double)(msg.uiTimeRemain + 0.0);
        }
        else if (mnem == "TimeRemainInterp") {
            return 1.0 * (long double)(msg.teTimeRemainInterp + 0.0);
        }
        return 0.0;
    }
} BattSts2;

// Auto-generated class definition for RVC_tzPGN_BATT_STS1
typedef struct BattSts1 : public MessageBase {
RVC_tzPGN_BATT_STS1 msg;
BattSts1 () {  memset(&msg, 0xFF, sizeof(msg));  };
BattSts1 (void * pvStruct) {  msg = *(RVC_tzPGN_BATT_STS1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            if (ENUMLOOKUP[421711928].find(msg.teBattInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teBattInst];
              }
        }
        else if (mnem == "DcInst") {
            if (ENUMLOOKUP[421711928].find(msg.teDcInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDcInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teDcInst];
              }
        }
        else if (mnem == "DcV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcV == 0xffff) ? "No Data" : (msg.uiDcV == 0xfffe) ? "Out of range" : (msg.uiDcV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DcI") {
            char buffer[50];
            auto engval = 0.0010000000474974513 * (long double) (msg.ulDcI + -2000000000.0);
            snprintf(buffer, sizeof(buffer), "%.3f %s", engval, "A");
            return (msg.ulDcI == 0xffffffff) ? "No Data" : (msg.ulDcI == 0xfffffffe) ? "Out of range" : (msg.ulDcI == 0xfffffffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: BattSts1" << std::endl;
        cout << "BattInst      : " << fnGetValue("BattInst") << " (" << fnGetRawValue("BattInst") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "DcV      : " << fnGetValue("DcV") << " (" << fnGetRawValue("DcV") << ")" << endl;
        cout << "DcI      : " << fnGetValue("DcI") << " (" << fnGetRawValue("DcI") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return static_cast<uint32_t>(msg.teBattInst);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.teDcInst);
        }
        else if (mnem == "DcV") {
            return static_cast<uint32_t>(msg.uiDcV);
        }
        else if (mnem == "DcI") {
            return static_cast<uint32_t>(msg.ulDcI);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "BattInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teBattInst = static_cast<decltype(msg.teBattInst)>(enumValue);
     else msg.teBattInst = static_cast<decltype(msg.teBattInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teDcInst = static_cast<decltype(msg.teDcInst)>(enumValue);
     else msg.teDcInst = static_cast<decltype(msg.teDcInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcV") {
     msg.uiDcV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "DcI") {
     msg.ulDcI = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd, 0.0010000000474974513, -2000000000.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "BattInst") {
            return 1.0 * (long double)(msg.teBattInst + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.teDcInst + 0.0);
        }
        else if (mnem == "DcV") {
            return 0.05000000074505806 * (long double)(msg.uiDcV + 0.0);
        }
        else if (mnem == "DcI") {
            return 0.0010000000474974513 * (long double)(msg.ulDcI + -2000000000.0);
        }
        return 0.0;
    }
} BattSts1;

// Auto-generated class definition for RVC_tzPGN_INV_CFG_CMD4
typedef struct InvCfgCmd4 : public MessageBase {
RVC_tzPGN_INV_CFG_CMD4 msg;
InvCfgCmd4 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvCfgCmd4 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_CFG_CMD4 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "OutACVolt") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiOutACVolt + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiOutACVolt == 0xffff) ? "No Data" : (msg.uiOutACVolt == 0xfffe) ? "Out of range" : (msg.uiOutACVolt == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "OutFreq") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucOutFreq + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Hz");
            return (msg.ucOutFreq == 0xff) ? "No Data" : (msg.ucOutFreq == 0xfe) ? "Out of range" : (msg.ucOutFreq == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ACOutPwrLim") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiACOutPwrLim + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "W");
            return (msg.uiACOutPwrLim == 0xffff) ? "No Data" : (msg.uiACOutPwrLim == 0xfffe) ? "Out of range" : (msg.uiACOutPwrLim == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ACOutPwrTimeLim") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.uiACOutPwrTimeLim + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "s");
            return (msg.uiACOutPwrTimeLim == 0xffff) ? "No Data" : (msg.uiACOutPwrTimeLim == 0xfffe) ? "Out of range" : (msg.uiACOutPwrTimeLim == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvCfgCmd4" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "OutACVolt      : " << fnGetValue("OutACVolt") << " (" << fnGetRawValue("OutACVolt") << ")" << endl;
        cout << "OutFreq      : " << fnGetValue("OutFreq") << " (" << fnGetRawValue("OutFreq") << ")" << endl;
        cout << "ACOutPwrLim      : " << fnGetValue("ACOutPwrLim") << " (" << fnGetRawValue("ACOutPwrLim") << ")" << endl;
        cout << "ACOutPwrTimeLim      : " << fnGetValue("ACOutPwrTimeLim") << " (" << fnGetRawValue("ACOutPwrTimeLim") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "OutACVolt") {
            return static_cast<uint32_t>(msg.uiOutACVolt);
        }
        else if (mnem == "OutFreq") {
            return static_cast<uint32_t>(msg.ucOutFreq);
        }
        else if (mnem == "ACOutPwrLim") {
            return static_cast<uint32_t>(msg.uiACOutPwrLim);
        }
        else if (mnem == "ACOutPwrTimeLim") {
            return static_cast<uint32_t>(msg.uiACOutPwrTimeLim);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "OutACVolt") {
     msg.uiOutACVolt = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "OutFreq") {
     msg.ucOutFreq = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "ACOutPwrLim") {
     msg.uiACOutPwrLim = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "ACOutPwrTimeLim") {
     msg.uiACOutPwrTimeLim = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.5, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "OutACVolt") {
            return 0.05000000074505806 * (long double)(msg.uiOutACVolt + 0.0);
        }
        else if (mnem == "OutFreq") {
            return 1.0 * (long double)(msg.ucOutFreq + 0.0);
        }
        else if (mnem == "ACOutPwrLim") {
            return 1.0 * (long double)(msg.uiACOutPwrLim + 0.0);
        }
        else if (mnem == "ACOutPwrTimeLim") {
            return 0.5 * (long double)(msg.uiACOutPwrTimeLim + 0.0);
        }
        return 0.0;
    }
} InvCfgCmd4;

// Auto-generated class definition for RVC_tzPGN_INV_CFG_STS4
typedef struct InvCfgSts4 : public MessageBase {
RVC_tzPGN_INV_CFG_STS4 msg;
InvCfgSts4 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvCfgSts4 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_CFG_STS4 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "OutACVolt") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiOutACVolt + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiOutACVolt == 0xffff) ? "No Data" : (msg.uiOutACVolt == 0xfffe) ? "Out of range" : (msg.uiOutACVolt == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "OutFreq") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucOutFreq + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Hz");
            return (msg.ucOutFreq == 0xff) ? "No Data" : (msg.ucOutFreq == 0xfe) ? "Out of range" : (msg.ucOutFreq == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ACOutPwrLim") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiACOutPwrLim + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "W");
            return (msg.uiACOutPwrLim == 0xffff) ? "No Data" : (msg.uiACOutPwrLim == 0xfffe) ? "Out of range" : (msg.uiACOutPwrLim == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ACOutPwrTimeLim") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.uiACOutPwrTimeLim + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "s");
            return (msg.uiACOutPwrTimeLim == 0xffff) ? "No Data" : (msg.uiACOutPwrTimeLim == 0xfffe) ? "Out of range" : (msg.uiACOutPwrTimeLim == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvCfgSts4" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "OutACVolt      : " << fnGetValue("OutACVolt") << " (" << fnGetRawValue("OutACVolt") << ")" << endl;
        cout << "OutFreq      : " << fnGetValue("OutFreq") << " (" << fnGetRawValue("OutFreq") << ")" << endl;
        cout << "ACOutPwrLim      : " << fnGetValue("ACOutPwrLim") << " (" << fnGetRawValue("ACOutPwrLim") << ")" << endl;
        cout << "ACOutPwrTimeLim      : " << fnGetValue("ACOutPwrTimeLim") << " (" << fnGetRawValue("ACOutPwrTimeLim") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "OutACVolt") {
            return static_cast<uint32_t>(msg.uiOutACVolt);
        }
        else if (mnem == "OutFreq") {
            return static_cast<uint32_t>(msg.ucOutFreq);
        }
        else if (mnem == "ACOutPwrLim") {
            return static_cast<uint32_t>(msg.uiACOutPwrLim);
        }
        else if (mnem == "ACOutPwrTimeLim") {
            return static_cast<uint32_t>(msg.uiACOutPwrTimeLim);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "OutACVolt") {
     msg.uiOutACVolt = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "OutFreq") {
     msg.ucOutFreq = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "ACOutPwrLim") {
     msg.uiACOutPwrLim = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "ACOutPwrTimeLim") {
     msg.uiACOutPwrTimeLim = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.5, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnInvChgSts4OutACVolt2Enum") return fnInvChgSts4OutACVolt2Enum(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "OutACVolt") {
            return 0.05000000074505806 * (long double)(msg.uiOutACVolt + 0.0);
        }
        else if (mnem == "OutFreq") {
            return 1.0 * (long double)(msg.ucOutFreq + 0.0);
        }
        else if (mnem == "ACOutPwrLim") {
            return 1.0 * (long double)(msg.uiACOutPwrLim + 0.0);
        }
        else if (mnem == "ACOutPwrTimeLim") {
            return 0.5 * (long double)(msg.uiACOutPwrTimeLim + 0.0);
        }
        return 0.0;
    }
} InvCfgSts4;

// Auto-generated class definition for RVC_tzPGN_ALARM_CMD
typedef struct AlarmCmd : public MessageBase {
RVC_tzPGN_ALARM_CMD msg;
AlarmCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
AlarmCmd (void * pvStruct) {  msg = *(RVC_tzPGN_ALARM_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "DevType") {
            if (ENUMLOOKUP[8982].find(msg.teDevType) == ENUMLOOKUP[8982].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDevType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[8982][msg.teDevType];
              }
        }
        else if (mnem == "ReadyAlarm") {
            if (ENUMLOOKUP[9066].find(msg.teReadyAlarm) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teReadyAlarm);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teReadyAlarm];
              }
        }
        else if (mnem == "AckAlarm") {
            if (ENUMLOOKUP[9066].find(msg.teAckAlarm) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAckAlarm);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teAckAlarm];
              }
        }
        else if (mnem == "AutoRstEn") {
            if (ENUMLOOKUP[9066].find(msg.teAutoRstEn) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAutoRstEn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teAutoRstEn];
              }
        }
        else if (mnem == "DevInst") {
            return std::to_string(msg.ucDevInst);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AlarmCmd" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DevType      : " << fnGetValue("DevType") << " (" << fnGetRawValue("DevType") << ")" << endl;
        cout << "ReadyAlarm      : " << fnGetValue("ReadyAlarm") << " (" << fnGetRawValue("ReadyAlarm") << ")" << endl;
        cout << "AckAlarm      : " << fnGetValue("AckAlarm") << " (" << fnGetRawValue("AckAlarm") << ")" << endl;
        cout << "AutoRstEn      : " << fnGetValue("AutoRstEn") << " (" << fnGetRawValue("AutoRstEn") << ")" << endl;
        cout << "DevInst      : " << fnGetValue("DevInst") << " (" << fnGetRawValue("DevInst") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "DevType") {
            return static_cast<uint32_t>(msg.teDevType);
        }
        else if (mnem == "ReadyAlarm") {
            return static_cast<uint32_t>(msg.teReadyAlarm);
        }
        else if (mnem == "AckAlarm") {
            return static_cast<uint32_t>(msg.teAckAlarm);
        }
        else if (mnem == "AutoRstEn") {
            return static_cast<uint32_t>(msg.teAutoRstEn);
        }
        else if (mnem == "DevInst") {
            return static_cast<uint32_t>(msg.ucDevInst);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DevType") {
     int enumValue = findEnumValue(ENUMLOOKUP[8982], value);
     if (enumValue != -1) msg.teDevType = static_cast<decltype(msg.teDevType)>(enumValue);
     else msg.teDevType = static_cast<decltype(msg.teDevType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ReadyAlarm") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teReadyAlarm = static_cast<decltype(msg.teReadyAlarm)>(enumValue);
     else msg.teReadyAlarm = static_cast<decltype(msg.teReadyAlarm)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AckAlarm") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teAckAlarm = static_cast<decltype(msg.teAckAlarm)>(enumValue);
     else msg.teAckAlarm = static_cast<decltype(msg.teAckAlarm)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AutoRstEn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teAutoRstEn = static_cast<decltype(msg.teAutoRstEn)>(enumValue);
     else msg.teAutoRstEn = static_cast<decltype(msg.teAutoRstEn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DevInst") {
     msg.ucDevInst = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "DevType") {
            return 1.0 * (long double)(msg.teDevType + 0.0);
        }
        else if (mnem == "ReadyAlarm") {
            return 1.0 * (long double)(msg.teReadyAlarm + 0.0);
        }
        else if (mnem == "AckAlarm") {
            return 1.0 * (long double)(msg.teAckAlarm + 0.0);
        }
        else if (mnem == "AutoRstEn") {
            return 1.0 * (long double)(msg.teAutoRstEn + 0.0);
        }
        else if (mnem == "DevInst") {
            return 1.0 * (long double)(msg.ucDevInst + 0.0);
        }
        return 0.0;
    }
} AlarmCmd;

// Auto-generated class definition for RVC_tzPGN_ALARM_STS
typedef struct AlarmSts : public MessageBase {
RVC_tzPGN_ALARM_STS msg;
AlarmSts () {  memset(&msg, 0xFF, sizeof(msg));  };
AlarmSts (void * pvStruct) {  msg = *(RVC_tzPGN_ALARM_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "DevType") {
            if (ENUMLOOKUP[8982].find(msg.teDevType) == ENUMLOOKUP[8982].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDevType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[8982][msg.teDevType];
              }
        }
        else if (mnem == "AlarmTrig") {
            if (ENUMLOOKUP[9075].find(msg.teAlarmTrig) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAlarmTrig);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teAlarmTrig];
              }
        }
        else if (mnem == "AlarmRdy") {
            if (ENUMLOOKUP[9075].find(msg.teAlarmRdy) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAlarmRdy);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teAlarmRdy];
              }
        }
        else if (mnem == "AlarmAckd") {
            if (ENUMLOOKUP[9075].find(msg.teAlarmAckd) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAlarmAckd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teAlarmAckd];
              }
        }
        else if (mnem == "AlarmRstEn") {
            if (ENUMLOOKUP[9075].find(msg.teAlarmRstEn) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAlarmRstEn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teAlarmRstEn];
              }
        }
        else if (mnem == "ElapsedTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiElapsedTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiElapsedTime == 0xffff) ? "No Data" : (msg.uiElapsedTime == 0xfffe) ? "Out of range" : (msg.uiElapsedTime == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DevInst") {
            return std::to_string(msg.ucDevInst);
        }
        else if (mnem == "FtMonReq") {
            if (ENUMLOOKUP[9075].find(msg.teFtMonReq) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFtMonReq);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFtMonReq];
              }
        }
        else if (mnem == "AlarmForLog") {
            if (ENUMLOOKUP[9075].find(msg.teAlarmForLog) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAlarmForLog);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teAlarmForLog];
              }
        }
        else if (mnem == "AlarmForUser") {
            if (ENUMLOOKUP[9075].find(msg.teAlarmForUser) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAlarmForUser);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teAlarmForUser];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AlarmSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DevType      : " << fnGetValue("DevType") << " (" << fnGetRawValue("DevType") << ")" << endl;
        cout << "AlarmTrig      : " << fnGetValue("AlarmTrig") << " (" << fnGetRawValue("AlarmTrig") << ")" << endl;
        cout << "AlarmRdy      : " << fnGetValue("AlarmRdy") << " (" << fnGetRawValue("AlarmRdy") << ")" << endl;
        cout << "AlarmAckd      : " << fnGetValue("AlarmAckd") << " (" << fnGetRawValue("AlarmAckd") << ")" << endl;
        cout << "AlarmRstEn      : " << fnGetValue("AlarmRstEn") << " (" << fnGetRawValue("AlarmRstEn") << ")" << endl;
        cout << "ElapsedTime      : " << fnGetValue("ElapsedTime") << " (" << fnGetRawValue("ElapsedTime") << ")" << endl;
        cout << "DevInst      : " << fnGetValue("DevInst") << " (" << fnGetRawValue("DevInst") << ")" << endl;
        cout << "FtMonReq      : " << fnGetValue("FtMonReq") << " (" << fnGetRawValue("FtMonReq") << ")" << endl;
        cout << "AlarmForLog      : " << fnGetValue("AlarmForLog") << " (" << fnGetRawValue("AlarmForLog") << ")" << endl;
        cout << "AlarmForUser      : " << fnGetValue("AlarmForUser") << " (" << fnGetRawValue("AlarmForUser") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "DevType") {
            return static_cast<uint32_t>(msg.teDevType);
        }
        else if (mnem == "AlarmTrig") {
            return static_cast<uint32_t>(msg.teAlarmTrig);
        }
        else if (mnem == "AlarmRdy") {
            return static_cast<uint32_t>(msg.teAlarmRdy);
        }
        else if (mnem == "AlarmAckd") {
            return static_cast<uint32_t>(msg.teAlarmAckd);
        }
        else if (mnem == "AlarmRstEn") {
            return static_cast<uint32_t>(msg.teAlarmRstEn);
        }
        else if (mnem == "ElapsedTime") {
            return static_cast<uint32_t>(msg.uiElapsedTime);
        }
        else if (mnem == "DevInst") {
            return static_cast<uint32_t>(msg.ucDevInst);
        }
        else if (mnem == "FtMonReq") {
            return static_cast<uint32_t>(msg.teFtMonReq);
        }
        else if (mnem == "AlarmForLog") {
            return static_cast<uint32_t>(msg.teAlarmForLog);
        }
        else if (mnem == "AlarmForUser") {
            return static_cast<uint32_t>(msg.teAlarmForUser);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "DevType") {
     int enumValue = findEnumValue(ENUMLOOKUP[8982], value);
     if (enumValue != -1) msg.teDevType = static_cast<decltype(msg.teDevType)>(enumValue);
     else msg.teDevType = static_cast<decltype(msg.teDevType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AlarmTrig") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teAlarmTrig = static_cast<decltype(msg.teAlarmTrig)>(enumValue);
     else msg.teAlarmTrig = static_cast<decltype(msg.teAlarmTrig)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AlarmRdy") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teAlarmRdy = static_cast<decltype(msg.teAlarmRdy)>(enumValue);
     else msg.teAlarmRdy = static_cast<decltype(msg.teAlarmRdy)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AlarmAckd") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teAlarmAckd = static_cast<decltype(msg.teAlarmAckd)>(enumValue);
     else msg.teAlarmAckd = static_cast<decltype(msg.teAlarmAckd)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AlarmRstEn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teAlarmRstEn = static_cast<decltype(msg.teAlarmRstEn)>(enumValue);
     else msg.teAlarmRstEn = static_cast<decltype(msg.teAlarmRstEn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ElapsedTime") {
     msg.uiElapsedTime = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "DevInst") {
     msg.ucDevInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "FtMonReq") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFtMonReq = static_cast<decltype(msg.teFtMonReq)>(enumValue);
     else msg.teFtMonReq = static_cast<decltype(msg.teFtMonReq)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AlarmForLog") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teAlarmForLog = static_cast<decltype(msg.teAlarmForLog)>(enumValue);
     else msg.teAlarmForLog = static_cast<decltype(msg.teAlarmForLog)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AlarmForUser") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teAlarmForUser = static_cast<decltype(msg.teAlarmForUser)>(enumValue);
     else msg.teAlarmForUser = static_cast<decltype(msg.teAlarmForUser)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "DevType") {
            return 1.0 * (long double)(msg.teDevType + 0.0);
        }
        else if (mnem == "AlarmTrig") {
            return 1.0 * (long double)(msg.teAlarmTrig + 0.0);
        }
        else if (mnem == "AlarmRdy") {
            return 1.0 * (long double)(msg.teAlarmRdy + 0.0);
        }
        else if (mnem == "AlarmAckd") {
            return 1.0 * (long double)(msg.teAlarmAckd + 0.0);
        }
        else if (mnem == "AlarmRstEn") {
            return 1.0 * (long double)(msg.teAlarmRstEn + 0.0);
        }
        else if (mnem == "ElapsedTime") {
            return 1.0 * (long double)(msg.uiElapsedTime + 0.0);
        }
        else if (mnem == "DevInst") {
            return 1.0 * (long double)(msg.ucDevInst + 0.0);
        }
        else if (mnem == "FtMonReq") {
            return 1.0 * (long double)(msg.teFtMonReq + 0.0);
        }
        else if (mnem == "AlarmForLog") {
            return 1.0 * (long double)(msg.teAlarmForLog + 0.0);
        }
        else if (mnem == "AlarmForUser") {
            return 1.0 * (long double)(msg.teAlarmForUser + 0.0);
        }
        return 0.0;
    }
} AlarmSts;

// Auto-generated class definition for RVC_tzPGN_CHG_STS2
typedef struct ChgSts2 : public MessageBase {
RVC_tzPGN_CHG_STS2 msg;
ChgSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "ChgInst") {
            return (msg.ucChgInst == 0xff) ? "No Data" : (msg.ucChgInst == 0xfe) ? "Out of range" : (msg.ucChgInst == 0xfd) ? "Reserved" : std::to_string(msg.ucChgInst);
        }
        else if (mnem == "DcSrcInst") {
            return (msg.ucDcSrcInst == 0xff) ? "No Data" : (msg.ucDcSrcInst == 0xfe) ? "Out of range" : (msg.ucDcSrcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucDcSrcInst);
        }
        else if (mnem == "ChgPrio") {
            if (ENUMLOOKUP[1486082168].find(msg.teChgPrio) == ENUMLOOKUP[1486082168].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgPrio);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1486082168][msg.teChgPrio];
              }
        }
        else if (mnem == "ChgV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiChgV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiChgV == 0xffff) ? "No Data" : (msg.uiChgV == 0xfffe) ? "Out of range" : (msg.uiChgV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ChgI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiChgI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiChgI == 0xffff) ? "No Data" : (msg.uiChgI == 0xfffe) ? "Out of range" : (msg.uiChgI == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ChgTemp") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucChgTemp + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucChgTemp == 0xff) ? "No Data" : (msg.ucChgTemp == 0xfe) ? "Out of range" : (msg.ucChgTemp == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgSts2" << std::endl;
        cout << "ChgInst      : " << fnGetValue("ChgInst") << " (" << fnGetRawValue("ChgInst") << ")" << endl;
        cout << "DcSrcInst      : " << fnGetValue("DcSrcInst") << " (" << fnGetRawValue("DcSrcInst") << ")" << endl;
        cout << "ChgPrio      : " << fnGetValue("ChgPrio") << " (" << fnGetRawValue("ChgPrio") << ")" << endl;
        cout << "ChgV      : " << fnGetValue("ChgV") << " (" << fnGetRawValue("ChgV") << ")" << endl;
        cout << "ChgI      : " << fnGetValue("ChgI") << " (" << fnGetRawValue("ChgI") << ")" << endl;
        cout << "ChgTemp      : " << fnGetValue("ChgTemp") << " (" << fnGetRawValue("ChgTemp") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "ChgInst") {
            return static_cast<uint32_t>(msg.ucChgInst);
        }
        else if (mnem == "DcSrcInst") {
            return static_cast<uint32_t>(msg.ucDcSrcInst);
        }
        else if (mnem == "ChgPrio") {
            return static_cast<uint32_t>(msg.teChgPrio);
        }
        else if (mnem == "ChgV") {
            return static_cast<uint32_t>(msg.uiChgV);
        }
        else if (mnem == "ChgI") {
            return static_cast<uint32_t>(msg.uiChgI);
        }
        else if (mnem == "ChgTemp") {
            return static_cast<uint32_t>(msg.ucChgTemp);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "ChgInst") {
     msg.ucChgInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcSrcInst") {
     msg.ucDcSrcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "ChgPrio") {
     int enumValue = findEnumValue(ENUMLOOKUP[1486082168], value);
     if (enumValue != -1) msg.teChgPrio = static_cast<decltype(msg.teChgPrio)>(enumValue);
     else msg.teChgPrio = static_cast<decltype(msg.teChgPrio)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgV") {
     msg.uiChgV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "ChgI") {
     msg.uiChgI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "ChgTemp") {
     msg.ucChgTemp = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "ChgInst") {
            return 1.0 * (long double)(msg.ucChgInst + 0.0);
        }
        else if (mnem == "DcSrcInst") {
            return 1.0 * (long double)(msg.ucDcSrcInst + 0.0);
        }
        else if (mnem == "ChgPrio") {
            return 1.0 * (long double)(msg.teChgPrio + 0.0);
        }
        else if (mnem == "ChgV") {
            return 0.05000000074505806 * (long double)(msg.uiChgV + 0.0);
        }
        else if (mnem == "ChgI") {
            return 0.05000000074505806 * (long double)(msg.uiChgI + -32000.0);
        }
        else if (mnem == "ChgTemp") {
            return 1.0 * (long double)(msg.ucChgTemp + -40.0);
        }
        return 0.0;
    }
} ChgSts2;

// Auto-generated class definition for RVC_tzPGN_DC_SRC_CMD
typedef struct DcSrcCmd : public MessageBase {
RVC_tzPGN_DC_SRC_CMD msg;
DcSrcCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
DcSrcCmd (void * pvStruct) {  msg = *(RVC_tzPGN_DC_SRC_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            if (ENUMLOOKUP[421711928].find(msg.teInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teInst];
              }
        }
        else if (mnem == "DesPwrOnOffSts") {
            if (ENUMLOOKUP[9075].find(msg.teDesPwrOnOffSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDesPwrOnOffSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teDesPwrOnOffSts];
              }
        }
        else if (mnem == "DesChgOnOffSts") {
            if (ENUMLOOKUP[9075].find(msg.teDesChgOnOffSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDesChgOnOffSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teDesChgOnOffSts];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: DcSrcCmd" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DesPwrOnOffSts      : " << fnGetValue("DesPwrOnOffSts") << " (" << fnGetRawValue("DesPwrOnOffSts") << ")" << endl;
        cout << "DesChgOnOffSts      : " << fnGetValue("DesChgOnOffSts") << " (" << fnGetRawValue("DesChgOnOffSts") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.teInst);
        }
        else if (mnem == "DesPwrOnOffSts") {
            return static_cast<uint32_t>(msg.teDesPwrOnOffSts);
        }
        else if (mnem == "DesChgOnOffSts") {
            return static_cast<uint32_t>(msg.teDesChgOnOffSts);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teInst = static_cast<decltype(msg.teInst)>(enumValue);
     else msg.teInst = static_cast<decltype(msg.teInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DesPwrOnOffSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teDesPwrOnOffSts = static_cast<decltype(msg.teDesPwrOnOffSts)>(enumValue);
     else msg.teDesPwrOnOffSts = static_cast<decltype(msg.teDesPwrOnOffSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DesChgOnOffSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teDesChgOnOffSts = static_cast<decltype(msg.teDesChgOnOffSts)>(enumValue);
     else msg.teDesChgOnOffSts = static_cast<decltype(msg.teDesChgOnOffSts)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.teInst + 0.0);
        }
        else if (mnem == "DesPwrOnOffSts") {
            return 1.0 * (long double)(msg.teDesPwrOnOffSts + 0.0);
        }
        else if (mnem == "DesChgOnOffSts") {
            return 1.0 * (long double)(msg.teDesChgOnOffSts + 0.0);
        }
        return 0.0;
    }
} DcSrcCmd;

// Auto-generated class definition for RVC_tzPGN_DC_SRC_STS11
typedef struct DcSrcSts11 : public MessageBase {
RVC_tzPGN_DC_SRC_STS11 msg;
DcSrcSts11 () {  memset(&msg, 0xFF, sizeof(msg));  };
DcSrcSts11 (void * pvStruct) {  msg = *(RVC_tzPGN_DC_SRC_STS11 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            if (ENUMLOOKUP[421711928].find(msg.teInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teInst];
              }
        }
        else if (mnem == "DevPri") {
            if (ENUMLOOKUP[1486082168].find(msg.teDevPri) == ENUMLOOKUP[1486082168].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDevPri);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1486082168][msg.teDevPri];
              }
        }
        else if (mnem == "DischgOnOffSts") {
            if (ENUMLOOKUP[9075].find(msg.teDischgOnOffSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDischgOnOffSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teDischgOnOffSts];
              }
        }
        else if (mnem == "ChgOnOffSts") {
            if (ENUMLOOKUP[9075].find(msg.teChgOnOffSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgOnOffSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teChgOnOffSts];
              }
        }
        else if (mnem == "ChgDetect") {
            if (ENUMLOOKUP[9075].find(msg.teChgDetect) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgDetect);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teChgDetect];
              }
        }
        else if (mnem == "ReservSts") {
            if (ENUMLOOKUP[9075].find(msg.teReservSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teReservSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teReservSts];
              }
        }
        else if (mnem == "NomFullCap") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiNomFullCap + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "AH");
            return (msg.uiNomFullCap == 0xffff) ? "No Data" : (msg.uiNomFullCap == 0xfffe) ? "Out of range" : (msg.uiNomFullCap == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DcPwr") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiDcPwr + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "W");
            return (msg.uiDcPwr == 0xffff) ? "No Data" : (msg.uiDcPwr == 0xfffe) ? "Out of range" : (msg.uiDcPwr == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: DcSrcSts11" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DevPri      : " << fnGetValue("DevPri") << " (" << fnGetRawValue("DevPri") << ")" << endl;
        cout << "DischgOnOffSts      : " << fnGetValue("DischgOnOffSts") << " (" << fnGetRawValue("DischgOnOffSts") << ")" << endl;
        cout << "ChgOnOffSts      : " << fnGetValue("ChgOnOffSts") << " (" << fnGetRawValue("ChgOnOffSts") << ")" << endl;
        cout << "ChgDetect      : " << fnGetValue("ChgDetect") << " (" << fnGetRawValue("ChgDetect") << ")" << endl;
        cout << "ReservSts      : " << fnGetValue("ReservSts") << " (" << fnGetRawValue("ReservSts") << ")" << endl;
        cout << "NomFullCap      : " << fnGetValue("NomFullCap") << " (" << fnGetRawValue("NomFullCap") << ")" << endl;
        cout << "DcPwr      : " << fnGetValue("DcPwr") << " (" << fnGetRawValue("DcPwr") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.teInst);
        }
        else if (mnem == "DevPri") {
            return static_cast<uint32_t>(msg.teDevPri);
        }
        else if (mnem == "DischgOnOffSts") {
            return static_cast<uint32_t>(msg.teDischgOnOffSts);
        }
        else if (mnem == "ChgOnOffSts") {
            return static_cast<uint32_t>(msg.teChgOnOffSts);
        }
        else if (mnem == "ChgDetect") {
            return static_cast<uint32_t>(msg.teChgDetect);
        }
        else if (mnem == "ReservSts") {
            return static_cast<uint32_t>(msg.teReservSts);
        }
        else if (mnem == "NomFullCap") {
            return static_cast<uint32_t>(msg.uiNomFullCap);
        }
        else if (mnem == "DcPwr") {
            return static_cast<uint32_t>(msg.uiDcPwr);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teInst = static_cast<decltype(msg.teInst)>(enumValue);
     else msg.teInst = static_cast<decltype(msg.teInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DevPri") {
     int enumValue = findEnumValue(ENUMLOOKUP[1486082168], value);
     if (enumValue != -1) msg.teDevPri = static_cast<decltype(msg.teDevPri)>(enumValue);
     else msg.teDevPri = static_cast<decltype(msg.teDevPri)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DischgOnOffSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teDischgOnOffSts = static_cast<decltype(msg.teDischgOnOffSts)>(enumValue);
     else msg.teDischgOnOffSts = static_cast<decltype(msg.teDischgOnOffSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgOnOffSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teChgOnOffSts = static_cast<decltype(msg.teChgOnOffSts)>(enumValue);
     else msg.teChgOnOffSts = static_cast<decltype(msg.teChgOnOffSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgDetect") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teChgDetect = static_cast<decltype(msg.teChgDetect)>(enumValue);
     else msg.teChgDetect = static_cast<decltype(msg.teChgDetect)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ReservSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teReservSts = static_cast<decltype(msg.teReservSts)>(enumValue);
     else msg.teReservSts = static_cast<decltype(msg.teReservSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "NomFullCap") {
     msg.uiNomFullCap = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "DcPwr") {
     msg.uiDcPwr = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.teInst + 0.0);
        }
        else if (mnem == "DevPri") {
            return 1.0 * (long double)(msg.teDevPri + 0.0);
        }
        else if (mnem == "DischgOnOffSts") {
            return 1.0 * (long double)(msg.teDischgOnOffSts + 0.0);
        }
        else if (mnem == "ChgOnOffSts") {
            return 1.0 * (long double)(msg.teChgOnOffSts + 0.0);
        }
        else if (mnem == "ChgDetect") {
            return 1.0 * (long double)(msg.teChgDetect + 0.0);
        }
        else if (mnem == "ReservSts") {
            return 1.0 * (long double)(msg.teReservSts + 0.0);
        }
        else if (mnem == "NomFullCap") {
            return 1.0 * (long double)(msg.uiNomFullCap + 0.0);
        }
        else if (mnem == "DcPwr") {
            return 1.0 * (long double)(msg.uiDcPwr + 0.0);
        }
        return 0.0;
    }
} DcSrcSts11;

// Auto-generated class definition for RVC_tzPGN_SCC_EQLZ_CFG_CMD
typedef struct SccEqlzCfgCmd : public MessageBase {
RVC_tzPGN_SCC_EQLZ_CFG_CMD msg;
SccEqlzCfgCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
SccEqlzCfgCmd (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_EQLZ_CFG_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "EqlzV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiEqlzV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiEqlzV == 0xffff) ? "No Data" : (msg.uiEqlzV == 0xfffe) ? "Out of range" : (msg.uiEqlzV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "EqlzTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiEqlzTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiEqlzTime == 0xffff) ? "No Data" : (msg.uiEqlzTime == 0xfffe) ? "Out of range" : (msg.uiEqlzTime == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "EqlzIntvl") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucEqlzIntvl + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "days");
            return (msg.ucEqlzIntvl == 0xff) ? "No Data" : (msg.ucEqlzIntvl == 0xfe) ? "Out of range" : (msg.ucEqlzIntvl == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccEqlzCfgCmd" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "EqlzV      : " << fnGetValue("EqlzV") << " (" << fnGetRawValue("EqlzV") << ")" << endl;
        cout << "EqlzTime      : " << fnGetValue("EqlzTime") << " (" << fnGetRawValue("EqlzTime") << ")" << endl;
        cout << "EqlzIntvl      : " << fnGetValue("EqlzIntvl") << " (" << fnGetRawValue("EqlzIntvl") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "EqlzV") {
            return static_cast<uint32_t>(msg.uiEqlzV);
        }
        else if (mnem == "EqlzTime") {
            return static_cast<uint32_t>(msg.uiEqlzTime);
        }
        else if (mnem == "EqlzIntvl") {
            return static_cast<uint32_t>(msg.ucEqlzIntvl);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "EqlzV") {
     msg.uiEqlzV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "EqlzTime") {
     msg.uiEqlzTime = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "EqlzIntvl") {
     msg.ucEqlzIntvl = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "EqlzV") {
            return 0.05000000074505806 * (long double)(msg.uiEqlzV + 0.0);
        }
        else if (mnem == "EqlzTime") {
            return 1.0 * (long double)(msg.uiEqlzTime + 0.0);
        }
        else if (mnem == "EqlzIntvl") {
            return 1.0 * (long double)(msg.ucEqlzIntvl + 0.0);
        }
        return 0.0;
    }
} SccEqlzCfgCmd;

// Auto-generated class definition for RVC_tzPGN_SCC_EQLZ_CFG_STS
typedef struct SccEqlzCfgSts : public MessageBase {
RVC_tzPGN_SCC_EQLZ_CFG_STS msg;
SccEqlzCfgSts () {  memset(&msg, 0xFF, sizeof(msg));  };
SccEqlzCfgSts (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_EQLZ_CFG_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "EqlzV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiEqlzV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiEqlzV == 0xffff) ? "No Data" : (msg.uiEqlzV == 0xfffe) ? "Out of range" : (msg.uiEqlzV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "EqlzTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiEqlzTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiEqlzTime == 0xffff) ? "No Data" : (msg.uiEqlzTime == 0xfffe) ? "Out of range" : (msg.uiEqlzTime == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "EqlzIntvl") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucEqlzIntvl + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "days");
            return (msg.ucEqlzIntvl == 0xff) ? "No Data" : (msg.ucEqlzIntvl == 0xfe) ? "Out of range" : (msg.ucEqlzIntvl == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccEqlzCfgSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "EqlzV      : " << fnGetValue("EqlzV") << " (" << fnGetRawValue("EqlzV") << ")" << endl;
        cout << "EqlzTime      : " << fnGetValue("EqlzTime") << " (" << fnGetRawValue("EqlzTime") << ")" << endl;
        cout << "EqlzIntvl      : " << fnGetValue("EqlzIntvl") << " (" << fnGetRawValue("EqlzIntvl") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "EqlzV") {
            return static_cast<uint32_t>(msg.uiEqlzV);
        }
        else if (mnem == "EqlzTime") {
            return static_cast<uint32_t>(msg.uiEqlzTime);
        }
        else if (mnem == "EqlzIntvl") {
            return static_cast<uint32_t>(msg.ucEqlzIntvl);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "EqlzV") {
     msg.uiEqlzV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "EqlzTime") {
     msg.uiEqlzTime = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "EqlzIntvl") {
     msg.ucEqlzIntvl = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "EqlzV") {
            return 0.05000000074505806 * (long double)(msg.uiEqlzV + 0.0);
        }
        else if (mnem == "EqlzTime") {
            return 1.0 * (long double)(msg.uiEqlzTime + 0.0);
        }
        else if (mnem == "EqlzIntvl") {
            return 1.0 * (long double)(msg.ucEqlzIntvl + 0.0);
        }
        return 0.0;
    }
} SccEqlzCfgSts;

// Auto-generated class definition for RVC_tzPGN_SCC_EQLZ_STS
typedef struct SccEqlzSts : public MessageBase {
RVC_tzPGN_SCC_EQLZ_STS msg;
SccEqlzSts () {  memset(&msg, 0xFF, sizeof(msg));  };
SccEqlzSts (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_EQLZ_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "TimeRemain") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiTimeRemain + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiTimeRemain == 0xffff) ? "No Data" : (msg.uiTimeRemain == 0xfffe) ? "Out of range" : (msg.uiTimeRemain == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "PreChgSts") {
            if (ENUMLOOKUP[9075].find(msg.tePreChgSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.tePreChgSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.tePreChgSts];
              }
        }
        else if (mnem == "TimeSinceEqlz") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucTimeSinceEqlz + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "days");
            return (msg.ucTimeSinceEqlz == 0xff) ? "No Data" : (msg.ucTimeSinceEqlz == 0xfe) ? "Out of range" : (msg.ucTimeSinceEqlz == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccEqlzSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "TimeRemain      : " << fnGetValue("TimeRemain") << " (" << fnGetRawValue("TimeRemain") << ")" << endl;
        cout << "PreChgSts      : " << fnGetValue("PreChgSts") << " (" << fnGetRawValue("PreChgSts") << ")" << endl;
        cout << "TimeSinceEqlz      : " << fnGetValue("TimeSinceEqlz") << " (" << fnGetRawValue("TimeSinceEqlz") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "TimeRemain") {
            return static_cast<uint32_t>(msg.uiTimeRemain);
        }
        else if (mnem == "PreChgSts") {
            return static_cast<uint32_t>(msg.tePreChgSts);
        }
        else if (mnem == "TimeSinceEqlz") {
            return static_cast<uint32_t>(msg.ucTimeSinceEqlz);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "TimeRemain") {
     msg.uiTimeRemain = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "PreChgSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.tePreChgSts = static_cast<decltype(msg.tePreChgSts)>(enumValue);
     else msg.tePreChgSts = static_cast<decltype(msg.tePreChgSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "TimeSinceEqlz") {
     msg.ucTimeSinceEqlz = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "TimeRemain") {
            return 1.0 * (long double)(msg.uiTimeRemain + 0.0);
        }
        else if (mnem == "PreChgSts") {
            return 1.0 * (long double)(msg.tePreChgSts + 0.0);
        }
        else if (mnem == "TimeSinceEqlz") {
            return 1.0 * (long double)(msg.ucTimeSinceEqlz + 0.0);
        }
        return 0.0;
    }
} SccEqlzSts;

// Auto-generated class definition for RVC_tzPGN_SCC_CFG_CMD
typedef struct SccCfgCmd : public MessageBase {
RVC_tzPGN_SCC_CFG_CMD msg;
SccCfgCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
SccCfgCmd (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_CFG_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "ChgAlg") {
            if (ENUMLOOKUP[9408].find(msg.teChgAlg) == ENUMLOOKUP[9408].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgAlg);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9408][msg.teChgAlg];
              }
        }
        else if (mnem == "ChgMode") {
            if (ENUMLOOKUP[9409].find(msg.teChgMode) == ENUMLOOKUP[9409].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9409][msg.teChgMode];
              }
        }
        else if (mnem == "BattSensPres") {
            if (ENUMLOOKUP[9066].find(msg.teBattSensPres) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattSensPres);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teBattSensPres];
              }
        }
        else if (mnem == "LinkageMode") {
            if (ENUMLOOKUP[9066].find(msg.teLinkageMode) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLinkageMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teLinkageMode];
              }
        }
        else if (mnem == "BattType") {
            if (ENUMLOOKUP[9410].find(msg.teBattType) == ENUMLOOKUP[9410].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9410][msg.teBattType];
              }
        }
        else if (mnem == "BattBankSz") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiBattBankSz + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "AH");
            return (msg.uiBattBankSz == 0xffff) ? "No Data" : (msg.uiBattBankSz == 0xfffe) ? "Out of range" : (msg.uiBattBankSz == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "MaxChgI") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucMaxChgI + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "A");
            return (msg.ucMaxChgI == 0xff) ? "No Data" : (msg.ucMaxChgI == 0xfe) ? "Out of range" : (msg.ucMaxChgI == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccCfgCmd" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "ChgAlg      : " << fnGetValue("ChgAlg") << " (" << fnGetRawValue("ChgAlg") << ")" << endl;
        cout << "ChgMode      : " << fnGetValue("ChgMode") << " (" << fnGetRawValue("ChgMode") << ")" << endl;
        cout << "BattSensPres      : " << fnGetValue("BattSensPres") << " (" << fnGetRawValue("BattSensPres") << ")" << endl;
        cout << "LinkageMode      : " << fnGetValue("LinkageMode") << " (" << fnGetRawValue("LinkageMode") << ")" << endl;
        cout << "BattType      : " << fnGetValue("BattType") << " (" << fnGetRawValue("BattType") << ")" << endl;
        cout << "BattBankSz      : " << fnGetValue("BattBankSz") << " (" << fnGetRawValue("BattBankSz") << ")" << endl;
        cout << "MaxChgI      : " << fnGetValue("MaxChgI") << " (" << fnGetRawValue("MaxChgI") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "ChgAlg") {
            return static_cast<uint32_t>(msg.teChgAlg);
        }
        else if (mnem == "ChgMode") {
            return static_cast<uint32_t>(msg.teChgMode);
        }
        else if (mnem == "BattSensPres") {
            return static_cast<uint32_t>(msg.teBattSensPres);
        }
        else if (mnem == "LinkageMode") {
            return static_cast<uint32_t>(msg.teLinkageMode);
        }
        else if (mnem == "BattType") {
            return static_cast<uint32_t>(msg.teBattType);
        }
        else if (mnem == "BattBankSz") {
            return static_cast<uint32_t>(msg.uiBattBankSz);
        }
        else if (mnem == "MaxChgI") {
            return static_cast<uint32_t>(msg.ucMaxChgI);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ChgAlg") {
     int enumValue = findEnumValue(ENUMLOOKUP[9408], value);
     if (enumValue != -1) msg.teChgAlg = static_cast<decltype(msg.teChgAlg)>(enumValue);
     else msg.teChgAlg = static_cast<decltype(msg.teChgAlg)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9409], value);
     if (enumValue != -1) msg.teChgMode = static_cast<decltype(msg.teChgMode)>(enumValue);
     else msg.teChgMode = static_cast<decltype(msg.teChgMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattSensPres") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teBattSensPres = static_cast<decltype(msg.teBattSensPres)>(enumValue);
     else msg.teBattSensPres = static_cast<decltype(msg.teBattSensPres)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LinkageMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teLinkageMode = static_cast<decltype(msg.teLinkageMode)>(enumValue);
     else msg.teLinkageMode = static_cast<decltype(msg.teLinkageMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9410], value);
     if (enumValue != -1) msg.teBattType = static_cast<decltype(msg.teBattType)>(enumValue);
     else msg.teBattType = static_cast<decltype(msg.teBattType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattBankSz") {
     msg.uiBattBankSz = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "MaxChgI") {
     msg.ucMaxChgI = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnBatteryType2Cmd") return fnBatteryType2Cmd(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "ChgAlg") {
            return 1.0 * (long double)(msg.teChgAlg + 0.0);
        }
        else if (mnem == "ChgMode") {
            return 1.0 * (long double)(msg.teChgMode + 0.0);
        }
        else if (mnem == "BattSensPres") {
            return 1.0 * (long double)(msg.teBattSensPres + 0.0);
        }
        else if (mnem == "LinkageMode") {
            return 1.0 * (long double)(msg.teLinkageMode + 0.0);
        }
        else if (mnem == "BattType") {
            return 1.0 * (long double)(msg.teBattType + 0.0);
        }
        else if (mnem == "BattBankSz") {
            return 1.0 * (long double)(msg.uiBattBankSz + 0.0);
        }
        else if (mnem == "MaxChgI") {
            return 1.0 * (long double)(msg.ucMaxChgI + 0.0);
        }
        return 0.0;
    }
} SccCfgCmd;

// Auto-generated class definition for RVC_tzPGN_SCC_CMD
typedef struct SccCmd : public MessageBase {
RVC_tzPGN_SCC_CMD msg;
SccCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
SccCmd (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Sts") {
            if (ENUMLOOKUP[9411].find(msg.teSts) == ENUMLOOKUP[9411].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9411][msg.teSts];
              }
        }
        else if (mnem == "EnableOnPwrUp") {
            if (ENUMLOOKUP[9066].find(msg.teEnableOnPwrUp) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teEnableOnPwrUp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teEnableOnPwrUp];
              }
        }
        else if (mnem == "ClrHist") {
            if (ENUMLOOKUP[9066].find(msg.teClrHist) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teClrHist);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teClrHist];
              }
        }
        else if (mnem == "ForceChg") {
            if (ENUMLOOKUP[1484358105].find(msg.teForceChg) == ENUMLOOKUP[1484358105].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teForceChg);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1484358105][msg.teForceChg];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccCmd" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Sts      : " << fnGetValue("Sts") << " (" << fnGetRawValue("Sts") << ")" << endl;
        cout << "EnableOnPwrUp      : " << fnGetValue("EnableOnPwrUp") << " (" << fnGetRawValue("EnableOnPwrUp") << ")" << endl;
        cout << "ClrHist      : " << fnGetValue("ClrHist") << " (" << fnGetRawValue("ClrHist") << ")" << endl;
        cout << "ForceChg      : " << fnGetValue("ForceChg") << " (" << fnGetRawValue("ForceChg") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Sts") {
            return static_cast<uint32_t>(msg.teSts);
        }
        else if (mnem == "EnableOnPwrUp") {
            return static_cast<uint32_t>(msg.teEnableOnPwrUp);
        }
        else if (mnem == "ClrHist") {
            return static_cast<uint32_t>(msg.teClrHist);
        }
        else if (mnem == "ForceChg") {
            return static_cast<uint32_t>(msg.teForceChg);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Sts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9411], value);
     if (enumValue != -1) msg.teSts = static_cast<decltype(msg.teSts)>(enumValue);
     else msg.teSts = static_cast<decltype(msg.teSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "EnableOnPwrUp") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teEnableOnPwrUp = static_cast<decltype(msg.teEnableOnPwrUp)>(enumValue);
     else msg.teEnableOnPwrUp = static_cast<decltype(msg.teEnableOnPwrUp)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ClrHist") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teClrHist = static_cast<decltype(msg.teClrHist)>(enumValue);
     else msg.teClrHist = static_cast<decltype(msg.teClrHist)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ForceChg") {
     int enumValue = findEnumValue(ENUMLOOKUP[1484358105], value);
     if (enumValue != -1) msg.teForceChg = static_cast<decltype(msg.teForceChg)>(enumValue);
     else msg.teForceChg = static_cast<decltype(msg.teForceChg)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnChargerEnable2Cmd") return fnChargerEnable2Cmd(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Sts") {
            return 1.0 * (long double)(msg.teSts + 0.0);
        }
        else if (mnem == "EnableOnPwrUp") {
            return 1.0 * (long double)(msg.teEnableOnPwrUp + 0.0);
        }
        else if (mnem == "ClrHist") {
            return 1.0 * (long double)(msg.teClrHist + 0.0);
        }
        else if (mnem == "ForceChg") {
            return 1.0 * (long double)(msg.teForceChg + 0.0);
        }
        return 0.0;
    }
} SccCmd;

// Auto-generated class definition for RVC_tzPGN_SCC_CFG_STS
typedef struct SccCfgSts : public MessageBase {
RVC_tzPGN_SCC_CFG_STS msg;
SccCfgSts () {  memset(&msg, 0xFF, sizeof(msg));  };
SccCfgSts (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_CFG_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "ChgAlg") {
            if (ENUMLOOKUP[9408].find(msg.teChgAlg) == ENUMLOOKUP[9408].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgAlg);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9408][msg.teChgAlg];
              }
        }
        else if (mnem == "ChgMode") {
            if (ENUMLOOKUP[9409].find(msg.teChgMode) == ENUMLOOKUP[9409].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9409][msg.teChgMode];
              }
        }
        else if (mnem == "BattSensPres") {
            if (ENUMLOOKUP[9075].find(msg.teBattSensPres) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattSensPres);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBattSensPres];
              }
        }
        else if (mnem == "LinkMode") {
            if (ENUMLOOKUP[9075].find(msg.teLinkMode) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLinkMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teLinkMode];
              }
        }
        else if (mnem == "BattType") {
            if (ENUMLOOKUP[9410].find(msg.teBattType) == ENUMLOOKUP[9410].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9410][msg.teBattType];
              }
        }
        else if (mnem == "BattBankSz") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiBattBankSz + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "AH");
            return (msg.uiBattBankSz == 0xffff) ? "No Data" : (msg.uiBattBankSz == 0xfffe) ? "Out of range" : (msg.uiBattBankSz == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "MaxChgI") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucMaxChgI + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "A");
            return (msg.ucMaxChgI == 0xff) ? "No Data" : (msg.ucMaxChgI == 0xfe) ? "Out of range" : (msg.ucMaxChgI == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccCfgSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "ChgAlg      : " << fnGetValue("ChgAlg") << " (" << fnGetRawValue("ChgAlg") << ")" << endl;
        cout << "ChgMode      : " << fnGetValue("ChgMode") << " (" << fnGetRawValue("ChgMode") << ")" << endl;
        cout << "BattSensPres      : " << fnGetValue("BattSensPres") << " (" << fnGetRawValue("BattSensPres") << ")" << endl;
        cout << "LinkMode      : " << fnGetValue("LinkMode") << " (" << fnGetRawValue("LinkMode") << ")" << endl;
        cout << "BattType      : " << fnGetValue("BattType") << " (" << fnGetRawValue("BattType") << ")" << endl;
        cout << "BattBankSz      : " << fnGetValue("BattBankSz") << " (" << fnGetRawValue("BattBankSz") << ")" << endl;
        cout << "MaxChgI      : " << fnGetValue("MaxChgI") << " (" << fnGetRawValue("MaxChgI") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "ChgAlg") {
            return static_cast<uint32_t>(msg.teChgAlg);
        }
        else if (mnem == "ChgMode") {
            return static_cast<uint32_t>(msg.teChgMode);
        }
        else if (mnem == "BattSensPres") {
            return static_cast<uint32_t>(msg.teBattSensPres);
        }
        else if (mnem == "LinkMode") {
            return static_cast<uint32_t>(msg.teLinkMode);
        }
        else if (mnem == "BattType") {
            return static_cast<uint32_t>(msg.teBattType);
        }
        else if (mnem == "BattBankSz") {
            return static_cast<uint32_t>(msg.uiBattBankSz);
        }
        else if (mnem == "MaxChgI") {
            return static_cast<uint32_t>(msg.ucMaxChgI);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ChgAlg") {
     int enumValue = findEnumValue(ENUMLOOKUP[9408], value);
     if (enumValue != -1) msg.teChgAlg = static_cast<decltype(msg.teChgAlg)>(enumValue);
     else msg.teChgAlg = static_cast<decltype(msg.teChgAlg)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9409], value);
     if (enumValue != -1) msg.teChgMode = static_cast<decltype(msg.teChgMode)>(enumValue);
     else msg.teChgMode = static_cast<decltype(msg.teChgMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattSensPres") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBattSensPres = static_cast<decltype(msg.teBattSensPres)>(enumValue);
     else msg.teBattSensPres = static_cast<decltype(msg.teBattSensPres)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LinkMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teLinkMode = static_cast<decltype(msg.teLinkMode)>(enumValue);
     else msg.teLinkMode = static_cast<decltype(msg.teLinkMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9410], value);
     if (enumValue != -1) msg.teBattType = static_cast<decltype(msg.teBattType)>(enumValue);
     else msg.teBattType = static_cast<decltype(msg.teBattType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattBankSz") {
     msg.uiBattBankSz = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "MaxChgI") {
     msg.ucMaxChgI = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnSts2BatteryType") return fnSts2BatteryType(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "ChgAlg") {
            return 1.0 * (long double)(msg.teChgAlg + 0.0);
        }
        else if (mnem == "ChgMode") {
            return 1.0 * (long double)(msg.teChgMode + 0.0);
        }
        else if (mnem == "BattSensPres") {
            return 1.0 * (long double)(msg.teBattSensPres + 0.0);
        }
        else if (mnem == "LinkMode") {
            return 1.0 * (long double)(msg.teLinkMode + 0.0);
        }
        else if (mnem == "BattType") {
            return 1.0 * (long double)(msg.teBattType + 0.0);
        }
        else if (mnem == "BattBankSz") {
            return 1.0 * (long double)(msg.uiBattBankSz + 0.0);
        }
        else if (mnem == "MaxChgI") {
            return 1.0 * (long double)(msg.ucMaxChgI + 0.0);
        }
        return 0.0;
    }
} SccCfgSts;

// Auto-generated class definition for RVC_tzPGN_SCC_STS
typedef struct SccSts : public MessageBase {
RVC_tzPGN_SCC_STS msg;
SccSts () {  memset(&msg, 0xFF, sizeof(msg));  };
SccSts (void * pvStruct) {  msg = *(RVC_tzPGN_SCC_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "ChgV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiChgV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiChgV == 0xffff) ? "No Data" : (msg.uiChgV == 0xfffe) ? "Out of range" : (msg.uiChgV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ChgI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiChgI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiChgI == 0xffff) ? "No Data" : (msg.uiChgI == 0xfffe) ? "Out of range" : (msg.uiChgI == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ChgIPer") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucChgIPer + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucChgIPer == 0xff) ? "No Data" : (msg.ucChgIPer == 0xfe) ? "Out of range" : (msg.ucChgIPer == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "OpState") {
            if (ENUMLOOKUP[1599683911].find(msg.teOpState) == ENUMLOOKUP[1599683911].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOpState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1599683911][msg.teOpState];
              }
        }
        else if (mnem == "PwrUpEnDis") {
            if (ENUMLOOKUP[9075].find(msg.tePwrUpEnDis) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.tePwrUpEnDis);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.tePwrUpEnDis];
              }
        }
        else if (mnem == "ClrHist") {
            if (ENUMLOOKUP[9075].find(msg.teClrHist) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teClrHist);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teClrHist];
              }
        }
        else if (mnem == "ForceChg") {
            if (ENUMLOOKUP[1484358105].find(msg.teForceChg) == ENUMLOOKUP[1484358105].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teForceChg);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1484358105][msg.teForceChg];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SccSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "ChgV      : " << fnGetValue("ChgV") << " (" << fnGetRawValue("ChgV") << ")" << endl;
        cout << "ChgI      : " << fnGetValue("ChgI") << " (" << fnGetRawValue("ChgI") << ")" << endl;
        cout << "ChgIPer      : " << fnGetValue("ChgIPer") << " (" << fnGetRawValue("ChgIPer") << ")" << endl;
        cout << "OpState      : " << fnGetValue("OpState") << " (" << fnGetRawValue("OpState") << ")" << endl;
        cout << "PwrUpEnDis      : " << fnGetValue("PwrUpEnDis") << " (" << fnGetRawValue("PwrUpEnDis") << ")" << endl;
        cout << "ClrHist      : " << fnGetValue("ClrHist") << " (" << fnGetRawValue("ClrHist") << ")" << endl;
        cout << "ForceChg      : " << fnGetValue("ForceChg") << " (" << fnGetRawValue("ForceChg") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "ChgV") {
            return static_cast<uint32_t>(msg.uiChgV);
        }
        else if (mnem == "ChgI") {
            return static_cast<uint32_t>(msg.uiChgI);
        }
        else if (mnem == "ChgIPer") {
            return static_cast<uint32_t>(msg.ucChgIPer);
        }
        else if (mnem == "OpState") {
            return static_cast<uint32_t>(msg.teOpState);
        }
        else if (mnem == "PwrUpEnDis") {
            return static_cast<uint32_t>(msg.tePwrUpEnDis);
        }
        else if (mnem == "ClrHist") {
            return static_cast<uint32_t>(msg.teClrHist);
        }
        else if (mnem == "ForceChg") {
            return static_cast<uint32_t>(msg.teForceChg);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "ChgV") {
     msg.uiChgV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "ChgI") {
     msg.uiChgI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "ChgIPer") {
     msg.ucChgIPer = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "OpState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1599683911], value);
     if (enumValue != -1) msg.teOpState = static_cast<decltype(msg.teOpState)>(enumValue);
     else msg.teOpState = static_cast<decltype(msg.teOpState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PwrUpEnDis") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.tePwrUpEnDis = static_cast<decltype(msg.tePwrUpEnDis)>(enumValue);
     else msg.tePwrUpEnDis = static_cast<decltype(msg.tePwrUpEnDis)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ClrHist") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teClrHist = static_cast<decltype(msg.teClrHist)>(enumValue);
     else msg.teClrHist = static_cast<decltype(msg.teClrHist)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ForceChg") {
     int enumValue = findEnumValue(ENUMLOOKUP[1484358105], value);
     if (enumValue != -1) msg.teForceChg = static_cast<decltype(msg.teForceChg)>(enumValue);
     else msg.teForceChg = static_cast<decltype(msg.teForceChg)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnSccSts2ChgOpState") return fnSccSts2ChgOpState(param_value);
        if (func == "fnSts2ChargerEnable") return fnSts2ChargerEnable(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "ChgV") {
            return 0.05000000074505806 * (long double)(msg.uiChgV + 0.0);
        }
        else if (mnem == "ChgI") {
            return 0.05000000074505806 * (long double)(msg.uiChgI + -32000.0);
        }
        else if (mnem == "ChgIPer") {
            return 0.5 * (long double)(msg.ucChgIPer + 0.0);
        }
        else if (mnem == "OpState") {
            return 1.0 * (long double)(msg.teOpState + 0.0);
        }
        else if (mnem == "PwrUpEnDis") {
            return 1.0 * (long double)(msg.tePwrUpEnDis + 0.0);
        }
        else if (mnem == "ClrHist") {
            return 1.0 * (long double)(msg.teClrHist + 0.0);
        }
        else if (mnem == "ForceChg") {
            return 1.0 * (long double)(msg.teForceChg + 0.0);
        }
        return 0.0;
    }
} SccSts;

// Auto-generated class definition for RVC_tzPGN_INV_TEMP_STS
typedef struct InvTempSts : public MessageBase {
RVC_tzPGN_INV_TEMP_STS msg;
InvTempSts () {  memset(&msg, 0xFF, sizeof(msg));  };
InvTempSts (void * pvStruct) {  msg = *(RVC_tzPGN_INV_TEMP_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "Fet1Temp") {
            char buffer[50];
            auto engval = 0.03125 * (long double) (msg.uiFet1Temp + -8736.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "deg C");
            return (msg.uiFet1Temp == 0xffff) ? "No Data" : (msg.uiFet1Temp == 0xfffe) ? "Out of range" : (msg.uiFet1Temp == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "XfmrTemp") {
            char buffer[50];
            auto engval = 0.03125 * (long double) (msg.uiXfmrTemp + -8736.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "deg C");
            return (msg.uiXfmrTemp == 0xffff) ? "No Data" : (msg.uiXfmrTemp == 0xfffe) ? "Out of range" : (msg.uiXfmrTemp == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Fet2Temp") {
            char buffer[50];
            auto engval = 0.03125 * (long double) (msg.uiFet2Temp + -8736.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "deg C");
            return (msg.uiFet2Temp == 0xffff) ? "No Data" : (msg.uiFet2Temp == 0xfffe) ? "Out of range" : (msg.uiFet2Temp == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvTempSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Fet1Temp      : " << fnGetValue("Fet1Temp") << " (" << fnGetRawValue("Fet1Temp") << ")" << endl;
        cout << "XfmrTemp      : " << fnGetValue("XfmrTemp") << " (" << fnGetRawValue("XfmrTemp") << ")" << endl;
        cout << "Fet2Temp      : " << fnGetValue("Fet2Temp") << " (" << fnGetRawValue("Fet2Temp") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Fet1Temp") {
            return static_cast<uint32_t>(msg.uiFet1Temp);
        }
        else if (mnem == "XfmrTemp") {
            return static_cast<uint32_t>(msg.uiXfmrTemp);
        }
        else if (mnem == "Fet2Temp") {
            return static_cast<uint32_t>(msg.uiFet2Temp);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Fet1Temp") {
     msg.uiFet1Temp = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.03125, -8736.0);
        }
        else if (mnem == "XfmrTemp") {
     msg.uiXfmrTemp = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.03125, -8736.0);
        }
        else if (mnem == "Fet2Temp") {
     msg.uiFet2Temp = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.03125, -8736.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Fet1Temp") {
            return 0.03125 * (long double)(msg.uiFet1Temp + -8736.0);
        }
        else if (mnem == "XfmrTemp") {
            return 0.03125 * (long double)(msg.uiXfmrTemp + -8736.0);
        }
        else if (mnem == "Fet2Temp") {
            return 0.03125 * (long double)(msg.uiFet2Temp + -8736.0);
        }
        return 0.0;
    }
} InvTempSts;

// Auto-generated class definition for RVC_tzPGN_CHG_CFG_CMD4
typedef struct ChgCfgCmd4 : public MessageBase {
RVC_tzPGN_CHG_CFG_CMD4 msg;
ChgCfgCmd4 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgCfgCmd4 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_CFG_CMD4 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "BulkTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiBulkTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiBulkTime == 0xffff) ? "No Data" : (msg.uiBulkTime == 0xfffe) ? "Out of range" : (msg.uiBulkTime == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "AbsorpTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiAbsorpTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiAbsorpTime == 0xffff) ? "No Data" : (msg.uiAbsorpTime == 0xfffe) ? "Out of range" : (msg.uiAbsorpTime == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "FloatTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiFloatTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiFloatTime == 0xffff) ? "No Data" : (msg.uiFloatTime == 0xfffe) ? "Out of range" : (msg.uiFloatTime == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgCfgCmd4" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "BulkTime      : " << fnGetValue("BulkTime") << " (" << fnGetRawValue("BulkTime") << ")" << endl;
        cout << "AbsorpTime      : " << fnGetValue("AbsorpTime") << " (" << fnGetRawValue("AbsorpTime") << ")" << endl;
        cout << "FloatTime      : " << fnGetValue("FloatTime") << " (" << fnGetRawValue("FloatTime") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "BulkTime") {
            return static_cast<uint32_t>(msg.uiBulkTime);
        }
        else if (mnem == "AbsorpTime") {
            return static_cast<uint32_t>(msg.uiAbsorpTime);
        }
        else if (mnem == "FloatTime") {
            return static_cast<uint32_t>(msg.uiFloatTime);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "BulkTime") {
     msg.uiBulkTime = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "AbsorpTime") {
     msg.uiAbsorpTime = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "FloatTime") {
     msg.uiFloatTime = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "BulkTime") {
            return 1.0 * (long double)(msg.uiBulkTime + 0.0);
        }
        else if (mnem == "AbsorpTime") {
            return 1.0 * (long double)(msg.uiAbsorpTime + 0.0);
        }
        else if (mnem == "FloatTime") {
            return 1.0 * (long double)(msg.uiFloatTime + 0.0);
        }
        return 0.0;
    }
} ChgCfgCmd4;

// Auto-generated class definition for RVC_tzPGN_CHG_CFG_STS4
typedef struct ChgCfgSts4 : public MessageBase {
RVC_tzPGN_CHG_CFG_STS4 msg;
ChgCfgSts4 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgCfgSts4 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_CFG_STS4 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "BulkTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiBulkTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiBulkTime == 0xffff) ? "No Data" : (msg.uiBulkTime == 0xfffe) ? "Out of range" : (msg.uiBulkTime == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "AbsorpTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiAbsorpTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiAbsorpTime == 0xffff) ? "No Data" : (msg.uiAbsorpTime == 0xfffe) ? "Out of range" : (msg.uiAbsorpTime == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "FloatTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiFloatTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiFloatTime == 0xffff) ? "No Data" : (msg.uiFloatTime == 0xfffe) ? "Out of range" : (msg.uiFloatTime == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgCfgSts4" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "BulkTime      : " << fnGetValue("BulkTime") << " (" << fnGetRawValue("BulkTime") << ")" << endl;
        cout << "AbsorpTime      : " << fnGetValue("AbsorpTime") << " (" << fnGetRawValue("AbsorpTime") << ")" << endl;
        cout << "FloatTime      : " << fnGetValue("FloatTime") << " (" << fnGetRawValue("FloatTime") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "BulkTime") {
            return static_cast<uint32_t>(msg.uiBulkTime);
        }
        else if (mnem == "AbsorpTime") {
            return static_cast<uint32_t>(msg.uiAbsorpTime);
        }
        else if (mnem == "FloatTime") {
            return static_cast<uint32_t>(msg.uiFloatTime);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "BulkTime") {
     msg.uiBulkTime = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "AbsorpTime") {
     msg.uiAbsorpTime = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "FloatTime") {
     msg.uiFloatTime = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "BulkTime") {
            return 1.0 * (long double)(msg.uiBulkTime + 0.0);
        }
        else if (mnem == "AbsorpTime") {
            return 1.0 * (long double)(msg.uiAbsorpTime + 0.0);
        }
        else if (mnem == "FloatTime") {
            return 1.0 * (long double)(msg.uiFloatTime + 0.0);
        }
        return 0.0;
    }
} ChgCfgSts4;

// Auto-generated class definition for RVC_tzPGN_DC_SRC_STS6
typedef struct DcSrcSts6 : public MessageBase {
RVC_tzPGN_DC_SRC_STS6 msg;
DcSrcSts6 () {  memset(&msg, 0xFF, sizeof(msg));  };
DcSrcSts6 (void * pvStruct) {  msg = *(RVC_tzPGN_DC_SRC_STS6 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "DcInst") {
            if (ENUMLOOKUP[421711928].find(msg.teDcInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDcInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teDcInst];
              }
        }
        else if (mnem == "DevPri") {
            if (ENUMLOOKUP[1486082168].find(msg.teDevPri) == ENUMLOOKUP[1486082168].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDevPri);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1486082168][msg.teDevPri];
              }
        }
        else if (mnem == "HiVoltLimitSts") {
            if (ENUMLOOKUP[9075].find(msg.teHiVoltLimitSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHiVoltLimitSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teHiVoltLimitSts];
              }
        }
        else if (mnem == "HiVoltDisconSts") {
            if (ENUMLOOKUP[276767036].find(msg.teHiVoltDisconSts) == ENUMLOOKUP[276767036].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHiVoltDisconSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[276767036][msg.teHiVoltDisconSts];
              }
        }
        else if (mnem == "LowVoltLimitSts") {
            if (ENUMLOOKUP[9075].find(msg.teLowVoltLimitSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowVoltLimitSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teLowVoltLimitSts];
              }
        }
        else if (mnem == "LowVoltDisconSts") {
            if (ENUMLOOKUP[276767036].find(msg.teLowVoltDisconSts) == ENUMLOOKUP[276767036].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowVoltDisconSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[276767036][msg.teLowVoltDisconSts];
              }
        }
        else if (mnem == "LowSocLimitSts") {
            if (ENUMLOOKUP[9075].find(msg.teLowSocLimitSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowSocLimitSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teLowSocLimitSts];
              }
        }
        else if (mnem == "LowSocDisconSts") {
            if (ENUMLOOKUP[276767036].find(msg.teLowSocDisconSts) == ENUMLOOKUP[276767036].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowSocDisconSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[276767036][msg.teLowSocDisconSts];
              }
        }
        else if (mnem == "LowDcSrcTempLimitSts") {
            if (ENUMLOOKUP[9075].find(msg.teLowDcSrcTempLimitSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowDcSrcTempLimitSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teLowDcSrcTempLimitSts];
              }
        }
        else if (mnem == "LowDcSrcTempDisconSts") {
            if (ENUMLOOKUP[276767036].find(msg.teLowDcSrcTempDisconSts) == ENUMLOOKUP[276767036].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLowDcSrcTempDisconSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[276767036][msg.teLowDcSrcTempDisconSts];
              }
        }
        else if (mnem == "HiDcSrcTempLimitSts") {
            if (ENUMLOOKUP[9075].find(msg.teHiDcSrcTempLimitSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHiDcSrcTempLimitSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teHiDcSrcTempLimitSts];
              }
        }
        else if (mnem == "HiDcSrcTempDisconSts") {
            if (ENUMLOOKUP[276767036].find(msg.teHiDcSrcTempDisconSts) == ENUMLOOKUP[276767036].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHiDcSrcTempDisconSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[276767036][msg.teHiDcSrcTempDisconSts];
              }
        }
        else if (mnem == "HiAmpDcSrcLimitSts") {
            if (ENUMLOOKUP[9075].find(msg.teHiAmpDcSrcLimitSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHiAmpDcSrcLimitSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teHiAmpDcSrcLimitSts];
              }
        }
        else if (mnem == "HiAmpDcSrcDisconSts") {
            if (ENUMLOOKUP[276767036].find(msg.teHiAmpDcSrcDisconSts) == ENUMLOOKUP[276767036].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teHiAmpDcSrcDisconSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[276767036][msg.teHiAmpDcSrcDisconSts];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: DcSrcSts6" << std::endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "DevPri      : " << fnGetValue("DevPri") << " (" << fnGetRawValue("DevPri") << ")" << endl;
        cout << "HiVoltLimitSts      : " << fnGetValue("HiVoltLimitSts") << " (" << fnGetRawValue("HiVoltLimitSts") << ")" << endl;
        cout << "HiVoltDisconSts      : " << fnGetValue("HiVoltDisconSts") << " (" << fnGetRawValue("HiVoltDisconSts") << ")" << endl;
        cout << "LowVoltLimitSts      : " << fnGetValue("LowVoltLimitSts") << " (" << fnGetRawValue("LowVoltLimitSts") << ")" << endl;
        cout << "LowVoltDisconSts      : " << fnGetValue("LowVoltDisconSts") << " (" << fnGetRawValue("LowVoltDisconSts") << ")" << endl;
        cout << "LowSocLimitSts      : " << fnGetValue("LowSocLimitSts") << " (" << fnGetRawValue("LowSocLimitSts") << ")" << endl;
        cout << "LowSocDisconSts      : " << fnGetValue("LowSocDisconSts") << " (" << fnGetRawValue("LowSocDisconSts") << ")" << endl;
        cout << "LowDcSrcTempLimitSts      : " << fnGetValue("LowDcSrcTempLimitSts") << " (" << fnGetRawValue("LowDcSrcTempLimitSts") << ")" << endl;
        cout << "LowDcSrcTempDisconSts      : " << fnGetValue("LowDcSrcTempDisconSts") << " (" << fnGetRawValue("LowDcSrcTempDisconSts") << ")" << endl;
        cout << "HiDcSrcTempLimitSts      : " << fnGetValue("HiDcSrcTempLimitSts") << " (" << fnGetRawValue("HiDcSrcTempLimitSts") << ")" << endl;
        cout << "HiDcSrcTempDisconSts      : " << fnGetValue("HiDcSrcTempDisconSts") << " (" << fnGetRawValue("HiDcSrcTempDisconSts") << ")" << endl;
        cout << "HiAmpDcSrcLimitSts      : " << fnGetValue("HiAmpDcSrcLimitSts") << " (" << fnGetRawValue("HiAmpDcSrcLimitSts") << ")" << endl;
        cout << "HiAmpDcSrcDisconSts      : " << fnGetValue("HiAmpDcSrcDisconSts") << " (" << fnGetRawValue("HiAmpDcSrcDisconSts") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.teDcInst);
        }
        else if (mnem == "DevPri") {
            return static_cast<uint32_t>(msg.teDevPri);
        }
        else if (mnem == "HiVoltLimitSts") {
            return static_cast<uint32_t>(msg.teHiVoltLimitSts);
        }
        else if (mnem == "HiVoltDisconSts") {
            return static_cast<uint32_t>(msg.teHiVoltDisconSts);
        }
        else if (mnem == "LowVoltLimitSts") {
            return static_cast<uint32_t>(msg.teLowVoltLimitSts);
        }
        else if (mnem == "LowVoltDisconSts") {
            return static_cast<uint32_t>(msg.teLowVoltDisconSts);
        }
        else if (mnem == "LowSocLimitSts") {
            return static_cast<uint32_t>(msg.teLowSocLimitSts);
        }
        else if (mnem == "LowSocDisconSts") {
            return static_cast<uint32_t>(msg.teLowSocDisconSts);
        }
        else if (mnem == "LowDcSrcTempLimitSts") {
            return static_cast<uint32_t>(msg.teLowDcSrcTempLimitSts);
        }
        else if (mnem == "LowDcSrcTempDisconSts") {
            return static_cast<uint32_t>(msg.teLowDcSrcTempDisconSts);
        }
        else if (mnem == "HiDcSrcTempLimitSts") {
            return static_cast<uint32_t>(msg.teHiDcSrcTempLimitSts);
        }
        else if (mnem == "HiDcSrcTempDisconSts") {
            return static_cast<uint32_t>(msg.teHiDcSrcTempDisconSts);
        }
        else if (mnem == "HiAmpDcSrcLimitSts") {
            return static_cast<uint32_t>(msg.teHiAmpDcSrcLimitSts);
        }
        else if (mnem == "HiAmpDcSrcDisconSts") {
            return static_cast<uint32_t>(msg.teHiAmpDcSrcDisconSts);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "DcInst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teDcInst = static_cast<decltype(msg.teDcInst)>(enumValue);
     else msg.teDcInst = static_cast<decltype(msg.teDcInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DevPri") {
     int enumValue = findEnumValue(ENUMLOOKUP[1486082168], value);
     if (enumValue != -1) msg.teDevPri = static_cast<decltype(msg.teDevPri)>(enumValue);
     else msg.teDevPri = static_cast<decltype(msg.teDevPri)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiVoltLimitSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teHiVoltLimitSts = static_cast<decltype(msg.teHiVoltLimitSts)>(enumValue);
     else msg.teHiVoltLimitSts = static_cast<decltype(msg.teHiVoltLimitSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiVoltDisconSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[276767036], value);
     if (enumValue != -1) msg.teHiVoltDisconSts = static_cast<decltype(msg.teHiVoltDisconSts)>(enumValue);
     else msg.teHiVoltDisconSts = static_cast<decltype(msg.teHiVoltDisconSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowVoltLimitSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teLowVoltLimitSts = static_cast<decltype(msg.teLowVoltLimitSts)>(enumValue);
     else msg.teLowVoltLimitSts = static_cast<decltype(msg.teLowVoltLimitSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowVoltDisconSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[276767036], value);
     if (enumValue != -1) msg.teLowVoltDisconSts = static_cast<decltype(msg.teLowVoltDisconSts)>(enumValue);
     else msg.teLowVoltDisconSts = static_cast<decltype(msg.teLowVoltDisconSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowSocLimitSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teLowSocLimitSts = static_cast<decltype(msg.teLowSocLimitSts)>(enumValue);
     else msg.teLowSocLimitSts = static_cast<decltype(msg.teLowSocLimitSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowSocDisconSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[276767036], value);
     if (enumValue != -1) msg.teLowSocDisconSts = static_cast<decltype(msg.teLowSocDisconSts)>(enumValue);
     else msg.teLowSocDisconSts = static_cast<decltype(msg.teLowSocDisconSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowDcSrcTempLimitSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teLowDcSrcTempLimitSts = static_cast<decltype(msg.teLowDcSrcTempLimitSts)>(enumValue);
     else msg.teLowDcSrcTempLimitSts = static_cast<decltype(msg.teLowDcSrcTempLimitSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LowDcSrcTempDisconSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[276767036], value);
     if (enumValue != -1) msg.teLowDcSrcTempDisconSts = static_cast<decltype(msg.teLowDcSrcTempDisconSts)>(enumValue);
     else msg.teLowDcSrcTempDisconSts = static_cast<decltype(msg.teLowDcSrcTempDisconSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiDcSrcTempLimitSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teHiDcSrcTempLimitSts = static_cast<decltype(msg.teHiDcSrcTempLimitSts)>(enumValue);
     else msg.teHiDcSrcTempLimitSts = static_cast<decltype(msg.teHiDcSrcTempLimitSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiDcSrcTempDisconSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[276767036], value);
     if (enumValue != -1) msg.teHiDcSrcTempDisconSts = static_cast<decltype(msg.teHiDcSrcTempDisconSts)>(enumValue);
     else msg.teHiDcSrcTempDisconSts = static_cast<decltype(msg.teHiDcSrcTempDisconSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiAmpDcSrcLimitSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teHiAmpDcSrcLimitSts = static_cast<decltype(msg.teHiAmpDcSrcLimitSts)>(enumValue);
     else msg.teHiAmpDcSrcLimitSts = static_cast<decltype(msg.teHiAmpDcSrcLimitSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiAmpDcSrcDisconSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[276767036], value);
     if (enumValue != -1) msg.teHiAmpDcSrcDisconSts = static_cast<decltype(msg.teHiAmpDcSrcDisconSts)>(enumValue);
     else msg.teHiAmpDcSrcDisconSts = static_cast<decltype(msg.teHiAmpDcSrcDisconSts)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.teDcInst + 0.0);
        }
        else if (mnem == "DevPri") {
            return 1.0 * (long double)(msg.teDevPri + 0.0);
        }
        else if (mnem == "HiVoltLimitSts") {
            return 1.0 * (long double)(msg.teHiVoltLimitSts + 0.0);
        }
        else if (mnem == "HiVoltDisconSts") {
            return 1.0 * (long double)(msg.teHiVoltDisconSts + 0.0);
        }
        else if (mnem == "LowVoltLimitSts") {
            return 1.0 * (long double)(msg.teLowVoltLimitSts + 0.0);
        }
        else if (mnem == "LowVoltDisconSts") {
            return 1.0 * (long double)(msg.teLowVoltDisconSts + 0.0);
        }
        else if (mnem == "LowSocLimitSts") {
            return 1.0 * (long double)(msg.teLowSocLimitSts + 0.0);
        }
        else if (mnem == "LowSocDisconSts") {
            return 1.0 * (long double)(msg.teLowSocDisconSts + 0.0);
        }
        else if (mnem == "LowDcSrcTempLimitSts") {
            return 1.0 * (long double)(msg.teLowDcSrcTempLimitSts + 0.0);
        }
        else if (mnem == "LowDcSrcTempDisconSts") {
            return 1.0 * (long double)(msg.teLowDcSrcTempDisconSts + 0.0);
        }
        else if (mnem == "HiDcSrcTempLimitSts") {
            return 1.0 * (long double)(msg.teHiDcSrcTempLimitSts + 0.0);
        }
        else if (mnem == "HiDcSrcTempDisconSts") {
            return 1.0 * (long double)(msg.teHiDcSrcTempDisconSts + 0.0);
        }
        else if (mnem == "HiAmpDcSrcLimitSts") {
            return 1.0 * (long double)(msg.teHiAmpDcSrcLimitSts + 0.0);
        }
        else if (mnem == "HiAmpDcSrcDisconSts") {
            return 1.0 * (long double)(msg.teHiAmpDcSrcDisconSts + 0.0);
        }
        return 0.0;
    }
} DcSrcSts6;

// Auto-generated class definition for RVC_tzPGN_DC_SRC_STS4
typedef struct DcSrcSts4 : public MessageBase {
RVC_tzPGN_DC_SRC_STS4 msg;
DcSrcSts4 () {  memset(&msg, 0xFF, sizeof(msg));  };
DcSrcSts4 (void * pvStruct) {  msg = *(RVC_tzPGN_DC_SRC_STS4 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            if (ENUMLOOKUP[421711928].find(msg.teInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teInst];
              }
        }
        else if (mnem == "DevPri") {
            if (ENUMLOOKUP[1486082168].find(msg.teDevPri) == ENUMLOOKUP[1486082168].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDevPri);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1486082168][msg.teDevPri];
              }
        }
        else if (mnem == "DesChgState") {
            if (ENUMLOOKUP[1599683911].find(msg.teDesChgState) == ENUMLOOKUP[1599683911].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDesChgState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1599683911][msg.teDesChgState];
              }
        }
        else if (mnem == "DesDcV") {
            return (msg.uiDesDcV == 0xffff) ? "No Data" : (msg.uiDesDcV == 0xfffe) ? "Out of range" : (msg.uiDesDcV == 0xfffd) ? "Reserved" : std::to_string(msg.uiDesDcV);
        }
        else if (mnem == "DesDcI") {
            return (msg.uiDesDcI == 0xffff) ? "No Data" : (msg.uiDesDcI == 0xfffe) ? "Out of range" : (msg.uiDesDcI == 0xfffd) ? "Reserved" : std::to_string(msg.uiDesDcI);
        }
        else if (mnem == "BattType") {
            if (ENUMLOOKUP[9410].find(msg.teBattType) == ENUMLOOKUP[9410].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9410][msg.teBattType];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: DcSrcSts4" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DevPri      : " << fnGetValue("DevPri") << " (" << fnGetRawValue("DevPri") << ")" << endl;
        cout << "DesChgState      : " << fnGetValue("DesChgState") << " (" << fnGetRawValue("DesChgState") << ")" << endl;
        cout << "DesDcV      : " << fnGetValue("DesDcV") << " (" << fnGetRawValue("DesDcV") << ")" << endl;
        cout << "DesDcI      : " << fnGetValue("DesDcI") << " (" << fnGetRawValue("DesDcI") << ")" << endl;
        cout << "BattType      : " << fnGetValue("BattType") << " (" << fnGetRawValue("BattType") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.teInst);
        }
        else if (mnem == "DevPri") {
            return static_cast<uint32_t>(msg.teDevPri);
        }
        else if (mnem == "DesChgState") {
            return static_cast<uint32_t>(msg.teDesChgState);
        }
        else if (mnem == "DesDcV") {
            return static_cast<uint32_t>(msg.uiDesDcV);
        }
        else if (mnem == "DesDcI") {
            return static_cast<uint32_t>(msg.uiDesDcI);
        }
        else if (mnem == "BattType") {
            return static_cast<uint32_t>(msg.teBattType);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teInst = static_cast<decltype(msg.teInst)>(enumValue);
     else msg.teInst = static_cast<decltype(msg.teInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DevPri") {
     int enumValue = findEnumValue(ENUMLOOKUP[1486082168], value);
     if (enumValue != -1) msg.teDevPri = static_cast<decltype(msg.teDevPri)>(enumValue);
     else msg.teDevPri = static_cast<decltype(msg.teDevPri)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DesChgState") {
     int enumValue = findEnumValue(ENUMLOOKUP[1599683911], value);
     if (enumValue != -1) msg.teDesChgState = static_cast<decltype(msg.teDesChgState)>(enumValue);
     else msg.teDesChgState = static_cast<decltype(msg.teDesChgState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DesDcV") {
     msg.uiDesDcV = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "DesDcI") {
     msg.uiDesDcI = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "BattType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9410], value);
     if (enumValue != -1) msg.teBattType = static_cast<decltype(msg.teBattType)>(enumValue);
     else msg.teBattType = static_cast<decltype(msg.teBattType)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.teInst + 0.0);
        }
        else if (mnem == "DevPri") {
            return 1.0 * (long double)(msg.teDevPri + 0.0);
        }
        else if (mnem == "DesChgState") {
            return 1.0 * (long double)(msg.teDesChgState + 0.0);
        }
        else if (mnem == "DesDcV") {
            return 1.0 * (long double)(msg.uiDesDcV + 0.0);
        }
        else if (mnem == "DesDcI") {
            return 1.0 * (long double)(msg.uiDesDcI + 0.0);
        }
        else if (mnem == "BattType") {
            return 1.0 * (long double)(msg.teBattType + 0.0);
        }
        return 0.0;
    }
} DcSrcSts4;

// Auto-generated class definition for RVC_tzPGN_CHG_CFG_CMD3
typedef struct ChgCfgCmd3 : public MessageBase {
RVC_tzPGN_CHG_CFG_CMD3 msg;
ChgCfgCmd3 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgCfgCmd3 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_CFG_CMD3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "BulkV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBulkV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBulkV == 0xffff) ? "No Data" : (msg.uiBulkV == 0xfffe) ? "Out of range" : (msg.uiBulkV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "AbsorpV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiAbsorpV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiAbsorpV == 0xffff) ? "No Data" : (msg.uiAbsorpV == 0xfffe) ? "Out of range" : (msg.uiAbsorpV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "FloatV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiFloatV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiFloatV == 0xffff) ? "No Data" : (msg.uiFloatV == 0xfffe) ? "Out of range" : (msg.uiFloatV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TempCompConst") {
            return (msg.ucTempCompConst == 0xff) ? "No Data" : (msg.ucTempCompConst == 0xfe) ? "Out of range" : (msg.ucTempCompConst == 0xfd) ? "Reserved" : std::to_string(msg.ucTempCompConst);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgCfgCmd3" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "BulkV      : " << fnGetValue("BulkV") << " (" << fnGetRawValue("BulkV") << ")" << endl;
        cout << "AbsorpV      : " << fnGetValue("AbsorpV") << " (" << fnGetRawValue("AbsorpV") << ")" << endl;
        cout << "FloatV      : " << fnGetValue("FloatV") << " (" << fnGetRawValue("FloatV") << ")" << endl;
        cout << "TempCompConst      : " << fnGetValue("TempCompConst") << " (" << fnGetRawValue("TempCompConst") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "BulkV") {
            return static_cast<uint32_t>(msg.uiBulkV);
        }
        else if (mnem == "AbsorpV") {
            return static_cast<uint32_t>(msg.uiAbsorpV);
        }
        else if (mnem == "FloatV") {
            return static_cast<uint32_t>(msg.uiFloatV);
        }
        else if (mnem == "TempCompConst") {
            return static_cast<uint32_t>(msg.ucTempCompConst);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "BulkV") {
     msg.uiBulkV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "AbsorpV") {
     msg.uiAbsorpV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "FloatV") {
     msg.uiFloatV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "TempCompConst") {
     msg.ucTempCompConst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "BulkV") {
            return 0.05000000074505806 * (long double)(msg.uiBulkV + 0.0);
        }
        else if (mnem == "AbsorpV") {
            return 0.05000000074505806 * (long double)(msg.uiAbsorpV + 0.0);
        }
        else if (mnem == "FloatV") {
            return 0.05000000074505806 * (long double)(msg.uiFloatV + 0.0);
        }
        else if (mnem == "TempCompConst") {
            return 1.0 * (long double)(msg.ucTempCompConst + 0.0);
        }
        return 0.0;
    }
} ChgCfgCmd3;

// Auto-generated class definition for RVC_tzPGN_CHG_CFG_STS3
typedef struct ChgCfgSts3 : public MessageBase {
RVC_tzPGN_CHG_CFG_STS3 msg;
ChgCfgSts3 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgCfgSts3 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_CFG_STS3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "BulkV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiBulkV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiBulkV == 0xffff) ? "No Data" : (msg.uiBulkV == 0xfffe) ? "Out of range" : (msg.uiBulkV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "AbsorpV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiAbsorpV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiAbsorpV == 0xffff) ? "No Data" : (msg.uiAbsorpV == 0xfffe) ? "Out of range" : (msg.uiAbsorpV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "FloatV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiFloatV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiFloatV == 0xffff) ? "No Data" : (msg.uiFloatV == 0xfffe) ? "Out of range" : (msg.uiFloatV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TempCompConst") {
            return (msg.ucTempCompConst == 0xff) ? "No Data" : (msg.ucTempCompConst == 0xfe) ? "Out of range" : (msg.ucTempCompConst == 0xfd) ? "Reserved" : std::to_string(msg.ucTempCompConst);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgCfgSts3" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "BulkV      : " << fnGetValue("BulkV") << " (" << fnGetRawValue("BulkV") << ")" << endl;
        cout << "AbsorpV      : " << fnGetValue("AbsorpV") << " (" << fnGetRawValue("AbsorpV") << ")" << endl;
        cout << "FloatV      : " << fnGetValue("FloatV") << " (" << fnGetRawValue("FloatV") << ")" << endl;
        cout << "TempCompConst      : " << fnGetValue("TempCompConst") << " (" << fnGetRawValue("TempCompConst") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "BulkV") {
            return static_cast<uint32_t>(msg.uiBulkV);
        }
        else if (mnem == "AbsorpV") {
            return static_cast<uint32_t>(msg.uiAbsorpV);
        }
        else if (mnem == "FloatV") {
            return static_cast<uint32_t>(msg.uiFloatV);
        }
        else if (mnem == "TempCompConst") {
            return static_cast<uint32_t>(msg.ucTempCompConst);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "BulkV") {
     msg.uiBulkV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "AbsorpV") {
     msg.uiAbsorpV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "FloatV") {
     msg.uiFloatV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "TempCompConst") {
     msg.ucTempCompConst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "BulkV") {
            return 0.05000000074505806 * (long double)(msg.uiBulkV + 0.0);
        }
        else if (mnem == "AbsorpV") {
            return 0.05000000074505806 * (long double)(msg.uiAbsorpV + 0.0);
        }
        else if (mnem == "FloatV") {
            return 0.05000000074505806 * (long double)(msg.uiFloatV + 0.0);
        }
        else if (mnem == "TempCompConst") {
            return 1.0 * (long double)(msg.ucTempCompConst + 0.0);
        }
        return 0.0;
    }
} ChgCfgSts3;

// Auto-generated class definition for RVC_tzPGN_INV_CFG_CMD3
typedef struct InvCfgCmd3 : public MessageBase {
RVC_tzPGN_INV_CFG_CMD3 msg;
InvCfgCmd3 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvCfgCmd3 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_CFG_CMD3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "DcSrcShtDwnDly") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.uiDcSrcShtDwnDly + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "s");
            return (msg.uiDcSrcShtDwnDly == 0xffff) ? "No Data" : (msg.uiDcSrcShtDwnDly == 0xfffe) ? "Out of range" : (msg.uiDcSrcShtDwnDly == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "StackMd") {
            if (ENUMLOOKUP[-1191777267].find(msg.teStackMd) == ENUMLOOKUP[-1191777267].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teStackMd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-1191777267][msg.teStackMd];
              }
        }
        else if (mnem == "DcUvSdRecLvl") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcUvSdRecLvl + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcUvSdRecLvl == 0xffff) ? "No Data" : (msg.uiDcUvSdRecLvl == 0xfffe) ? "Out of range" : (msg.uiDcUvSdRecLvl == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "GenSupportEngI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiGenSupportEngI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiGenSupportEngI == 0xffff) ? "No Data" : (msg.uiGenSupportEngI == 0xfffe) ? "Out of range" : (msg.uiGenSupportEngI == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvCfgCmd3" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DcSrcShtDwnDly      : " << fnGetValue("DcSrcShtDwnDly") << " (" << fnGetRawValue("DcSrcShtDwnDly") << ")" << endl;
        cout << "StackMd      : " << fnGetValue("StackMd") << " (" << fnGetRawValue("StackMd") << ")" << endl;
        cout << "DcUvSdRecLvl      : " << fnGetValue("DcUvSdRecLvl") << " (" << fnGetRawValue("DcUvSdRecLvl") << ")" << endl;
        cout << "GenSupportEngI      : " << fnGetValue("GenSupportEngI") << " (" << fnGetRawValue("GenSupportEngI") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "DcSrcShtDwnDly") {
            return static_cast<uint32_t>(msg.uiDcSrcShtDwnDly);
        }
        else if (mnem == "StackMd") {
            return static_cast<uint32_t>(msg.teStackMd);
        }
        else if (mnem == "DcUvSdRecLvl") {
            return static_cast<uint32_t>(msg.uiDcUvSdRecLvl);
        }
        else if (mnem == "GenSupportEngI") {
            return static_cast<uint32_t>(msg.uiGenSupportEngI);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcSrcShtDwnDly") {
     msg.uiDcSrcShtDwnDly = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.5, 0.0);
        }
        else if (mnem == "StackMd") {
     int enumValue = findEnumValue(ENUMLOOKUP[-1191777267], value);
     if (enumValue != -1) msg.teStackMd = static_cast<decltype(msg.teStackMd)>(enumValue);
     else msg.teStackMd = static_cast<decltype(msg.teStackMd)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcUvSdRecLvl") {
     msg.uiDcUvSdRecLvl = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "GenSupportEngI") {
     msg.uiGenSupportEngI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "DcSrcShtDwnDly") {
            return 0.5 * (long double)(msg.uiDcSrcShtDwnDly + 0.0);
        }
        else if (mnem == "StackMd") {
            return 1.0 * (long double)(msg.teStackMd + 0.0);
        }
        else if (mnem == "DcUvSdRecLvl") {
            return 0.05000000074505806 * (long double)(msg.uiDcUvSdRecLvl + 0.0);
        }
        else if (mnem == "GenSupportEngI") {
            return 0.05000000074505806 * (long double)(msg.uiGenSupportEngI + -32000.0);
        }
        return 0.0;
    }
} InvCfgCmd3;

// Auto-generated class definition for RVC_tzPGN_INV_CFG_STS3
typedef struct InvCfgSts3 : public MessageBase {
RVC_tzPGN_INV_CFG_STS3 msg;
InvCfgSts3 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvCfgSts3 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_CFG_STS3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "DcSrcShtDwnDly") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.uiDcSrcShtDwnDly + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "s");
            return (msg.uiDcSrcShtDwnDly == 0xffff) ? "No Data" : (msg.uiDcSrcShtDwnDly == 0xfffe) ? "Out of range" : (msg.uiDcSrcShtDwnDly == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "StackMd") {
            if (ENUMLOOKUP[-1191777267].find(msg.teStackMd) == ENUMLOOKUP[-1191777267].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teStackMd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[-1191777267][msg.teStackMd];
              }
        }
        else if (mnem == "DcUvSdRecLvl") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcUvSdRecLvl + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcUvSdRecLvl == 0xffff) ? "No Data" : (msg.uiDcUvSdRecLvl == 0xfffe) ? "Out of range" : (msg.uiDcUvSdRecLvl == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "GenSupportEngI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiGenSupportEngI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiGenSupportEngI == 0xffff) ? "No Data" : (msg.uiGenSupportEngI == 0xfffe) ? "Out of range" : (msg.uiGenSupportEngI == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvCfgSts3" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DcSrcShtDwnDly      : " << fnGetValue("DcSrcShtDwnDly") << " (" << fnGetRawValue("DcSrcShtDwnDly") << ")" << endl;
        cout << "StackMd      : " << fnGetValue("StackMd") << " (" << fnGetRawValue("StackMd") << ")" << endl;
        cout << "DcUvSdRecLvl      : " << fnGetValue("DcUvSdRecLvl") << " (" << fnGetRawValue("DcUvSdRecLvl") << ")" << endl;
        cout << "GenSupportEngI      : " << fnGetValue("GenSupportEngI") << " (" << fnGetRawValue("GenSupportEngI") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "DcSrcShtDwnDly") {
            return static_cast<uint32_t>(msg.uiDcSrcShtDwnDly);
        }
        else if (mnem == "StackMd") {
            return static_cast<uint32_t>(msg.teStackMd);
        }
        else if (mnem == "DcUvSdRecLvl") {
            return static_cast<uint32_t>(msg.uiDcUvSdRecLvl);
        }
        else if (mnem == "GenSupportEngI") {
            return static_cast<uint32_t>(msg.uiGenSupportEngI);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcSrcShtDwnDly") {
     msg.uiDcSrcShtDwnDly = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.5, 0.0);
        }
        else if (mnem == "StackMd") {
     int enumValue = findEnumValue(ENUMLOOKUP[-1191777267], value);
     if (enumValue != -1) msg.teStackMd = static_cast<decltype(msg.teStackMd)>(enumValue);
     else msg.teStackMd = static_cast<decltype(msg.teStackMd)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcUvSdRecLvl") {
     msg.uiDcUvSdRecLvl = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "GenSupportEngI") {
     msg.uiGenSupportEngI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "DcSrcShtDwnDly") {
            return 0.5 * (long double)(msg.uiDcSrcShtDwnDly + 0.0);
        }
        else if (mnem == "StackMd") {
            return 1.0 * (long double)(msg.teStackMd + 0.0);
        }
        else if (mnem == "DcUvSdRecLvl") {
            return 0.05000000074505806 * (long double)(msg.uiDcUvSdRecLvl + 0.0);
        }
        else if (mnem == "GenSupportEngI") {
            return 0.05000000074505806 * (long double)(msg.uiGenSupportEngI + -32000.0);
        }
        return 0.0;
    }
} InvCfgSts3;

// Auto-generated class definition for RVC_tzPGN_INV_DC_STS
typedef struct InvDcSts : public MessageBase {
RVC_tzPGN_INV_DC_STS msg;
InvDcSts () {  memset(&msg, 0xFF, sizeof(msg));  };
InvDcSts (void * pvStruct) {  msg = *(RVC_tzPGN_INV_DC_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "DcVolt") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcVolt + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcVolt == 0xffff) ? "No Data" : (msg.uiDcVolt == 0xfffe) ? "Out of range" : (msg.uiDcVolt == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DcAmps") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcAmps + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiDcAmps == 0xffff) ? "No Data" : (msg.uiDcAmps == 0xfffe) ? "Out of range" : (msg.uiDcAmps == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvDcSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DcVolt      : " << fnGetValue("DcVolt") << " (" << fnGetRawValue("DcVolt") << ")" << endl;
        cout << "DcAmps      : " << fnGetValue("DcAmps") << " (" << fnGetRawValue("DcAmps") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "DcVolt") {
            return static_cast<uint32_t>(msg.uiDcVolt);
        }
        else if (mnem == "DcAmps") {
            return static_cast<uint32_t>(msg.uiDcAmps);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcVolt") {
     msg.uiDcVolt = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "DcAmps") {
     msg.uiDcAmps = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "DcVolt") {
            return 0.05000000074505806 * (long double)(msg.uiDcVolt + 0.0);
        }
        else if (mnem == "DcAmps") {
            return 0.05000000074505806 * (long double)(msg.uiDcAmps + -32000.0);
        }
        return 0.0;
    }
} InvDcSts;

// Auto-generated class definition for RVC_tzPGN_CHG_AC_FLT_CFG_CMD2
typedef struct ChgAcFltCfgCmd2 : public MessageBase {
RVC_tzPGN_CHG_AC_FLT_CFG_CMD2 msg;
ChgAcFltCfgCmd2 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgAcFltCfgCmd2 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_AC_FLT_CFG_CMD2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[2056474510].find(msg.teLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "HiFreqLimit") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucHiFreqLimit + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Hz");
            return (msg.ucHiFreqLimit == 0xff) ? "No Data" : (msg.ucHiFreqLimit == 0xfe) ? "Out of range" : (msg.ucHiFreqLimit == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LoFreqLimit") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucLoFreqLimit + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Hz");
            return (msg.ucLoFreqLimit == 0xff) ? "No Data" : (msg.ucLoFreqLimit == 0xfe) ? "Out of range" : (msg.ucLoFreqLimit == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgAcFltCfgCmd2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "HiFreqLimit      : " << fnGetValue("HiFreqLimit") << " (" << fnGetRawValue("HiFreqLimit") << ")" << endl;
        cout << "LoFreqLimit      : " << fnGetValue("LoFreqLimit") << " (" << fnGetRawValue("LoFreqLimit") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "HiFreqLimit") {
            return static_cast<uint32_t>(msg.ucHiFreqLimit);
        }
        else if (mnem == "LoFreqLimit") {
            return static_cast<uint32_t>(msg.ucLoFreqLimit);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiFreqLimit") {
     msg.ucHiFreqLimit = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "LoFreqLimit") {
     msg.ucLoFreqLimit = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "HiFreqLimit") {
            return 1.0 * (long double)(msg.ucHiFreqLimit + 0.0);
        }
        else if (mnem == "LoFreqLimit") {
            return 1.0 * (long double)(msg.ucLoFreqLimit + 0.0);
        }
        return 0.0;
    }
} ChgAcFltCfgCmd2;

// Auto-generated class definition for RVC_tzPGN_CHG_AC_FLT_CFG_CMD1
typedef struct ChgAcFltCfgCmd1 : public MessageBase {
RVC_tzPGN_CHG_AC_FLT_CFG_CMD1 msg;
ChgAcFltCfgCmd1 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgAcFltCfgCmd1 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_AC_FLT_CFG_CMD1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[2056474510].find(msg.teLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "ExtremeLoV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtremeLoV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucExtremeLoV == 0xff) ? "No Data" : (msg.ucExtremeLoV == 0xfe) ? "Out of range" : (msg.ucExtremeLoV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LoV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucLoV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucLoV == 0xff) ? "No Data" : (msg.ucLoV == 0xfe) ? "Out of range" : (msg.ucLoV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "HiV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucHiV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucHiV == 0xff) ? "No Data" : (msg.ucHiV == 0xfe) ? "Out of range" : (msg.ucHiV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ExtremeHiV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtremeHiV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucExtremeHiV == 0xff) ? "No Data" : (msg.ucExtremeHiV == 0xfe) ? "Out of range" : (msg.ucExtremeHiV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "QualTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucQualTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucQualTime == 0xff) ? "No Data" : (msg.ucQualTime == 0xfe) ? "Out of range" : (msg.ucQualTime == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BypassMode") {
            if (ENUMLOOKUP[9075].find(msg.teBypassMode) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBypassMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBypassMode];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgAcFltCfgCmd1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "ExtremeLoV      : " << fnGetValue("ExtremeLoV") << " (" << fnGetRawValue("ExtremeLoV") << ")" << endl;
        cout << "LoV      : " << fnGetValue("LoV") << " (" << fnGetRawValue("LoV") << ")" << endl;
        cout << "HiV      : " << fnGetValue("HiV") << " (" << fnGetRawValue("HiV") << ")" << endl;
        cout << "ExtremeHiV      : " << fnGetValue("ExtremeHiV") << " (" << fnGetRawValue("ExtremeHiV") << ")" << endl;
        cout << "QualTime      : " << fnGetValue("QualTime") << " (" << fnGetRawValue("QualTime") << ")" << endl;
        cout << "BypassMode      : " << fnGetValue("BypassMode") << " (" << fnGetRawValue("BypassMode") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "ExtremeLoV") {
            return static_cast<uint32_t>(msg.ucExtremeLoV);
        }
        else if (mnem == "LoV") {
            return static_cast<uint32_t>(msg.ucLoV);
        }
        else if (mnem == "HiV") {
            return static_cast<uint32_t>(msg.ucHiV);
        }
        else if (mnem == "ExtremeHiV") {
            return static_cast<uint32_t>(msg.ucExtremeHiV);
        }
        else if (mnem == "QualTime") {
            return static_cast<uint32_t>(msg.ucQualTime);
        }
        else if (mnem == "BypassMode") {
            return static_cast<uint32_t>(msg.teBypassMode);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ExtremeLoV") {
     msg.ucExtremeLoV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "LoV") {
     msg.ucLoV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "HiV") {
     msg.ucHiV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "ExtremeHiV") {
     msg.ucExtremeHiV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "QualTime") {
     msg.ucQualTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "BypassMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBypassMode = static_cast<decltype(msg.teBypassMode)>(enumValue);
     else msg.teBypassMode = static_cast<decltype(msg.teBypassMode)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "ExtremeLoV") {
            return 1.0 * (long double)(msg.ucExtremeLoV + 0.0);
        }
        else if (mnem == "LoV") {
            return 1.0 * (long double)(msg.ucLoV + 0.0);
        }
        else if (mnem == "HiV") {
            return 1.0 * (long double)(msg.ucHiV + 0.0);
        }
        else if (mnem == "ExtremeHiV") {
            return 1.0 * (long double)(msg.ucExtremeHiV + 0.0);
        }
        else if (mnem == "QualTime") {
            return 1.0 * (long double)(msg.ucQualTime + 0.0);
        }
        else if (mnem == "BypassMode") {
            return 1.0 * (long double)(msg.teBypassMode + 0.0);
        }
        return 0.0;
    }
} ChgAcFltCfgCmd1;

// Auto-generated class definition for RVC_tzPGN_CHG_AC_FLT_CFG_STS2
typedef struct ChgAcFltCfgSts2 : public MessageBase {
RVC_tzPGN_CHG_AC_FLT_CFG_STS2 msg;
ChgAcFltCfgSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgAcFltCfgSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_AC_FLT_CFG_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[2056474510].find(msg.teLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "HiFreqLimit") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucHiFreqLimit + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Hz");
            return (msg.ucHiFreqLimit == 0xff) ? "No Data" : (msg.ucHiFreqLimit == 0xfe) ? "Out of range" : (msg.ucHiFreqLimit == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LoFreqLimit") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucLoFreqLimit + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Hz");
            return (msg.ucLoFreqLimit == 0xff) ? "No Data" : (msg.ucLoFreqLimit == 0xfe) ? "Out of range" : (msg.ucLoFreqLimit == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgAcFltCfgSts2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "HiFreqLimit      : " << fnGetValue("HiFreqLimit") << " (" << fnGetRawValue("HiFreqLimit") << ")" << endl;
        cout << "LoFreqLimit      : " << fnGetValue("LoFreqLimit") << " (" << fnGetRawValue("LoFreqLimit") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "HiFreqLimit") {
            return static_cast<uint32_t>(msg.ucHiFreqLimit);
        }
        else if (mnem == "LoFreqLimit") {
            return static_cast<uint32_t>(msg.ucLoFreqLimit);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiFreqLimit") {
     msg.ucHiFreqLimit = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "LoFreqLimit") {
     msg.ucLoFreqLimit = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "HiFreqLimit") {
            return 1.0 * (long double)(msg.ucHiFreqLimit + 0.0);
        }
        else if (mnem == "LoFreqLimit") {
            return 1.0 * (long double)(msg.ucLoFreqLimit + 0.0);
        }
        return 0.0;
    }
} ChgAcFltCfgSts2;

// Auto-generated class definition for RVC_tzPGN_CHG_AC_FLT_CFG_STS1
typedef struct ChgAcFltCfgSts1 : public MessageBase {
RVC_tzPGN_CHG_AC_FLT_CFG_STS1 msg;
ChgAcFltCfgSts1 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgAcFltCfgSts1 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_AC_FLT_CFG_STS1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[2056474510].find(msg.teLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "ExtremeLoV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtremeLoV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucExtremeLoV == 0xff) ? "No Data" : (msg.ucExtremeLoV == 0xfe) ? "Out of range" : (msg.ucExtremeLoV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LoV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucLoV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucLoV == 0xff) ? "No Data" : (msg.ucLoV == 0xfe) ? "Out of range" : (msg.ucLoV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "HiV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucHiV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucHiV == 0xff) ? "No Data" : (msg.ucHiV == 0xfe) ? "Out of range" : (msg.ucHiV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ExtremeHiV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtremeHiV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucExtremeHiV == 0xff) ? "No Data" : (msg.ucExtremeHiV == 0xfe) ? "Out of range" : (msg.ucExtremeHiV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "QualTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucQualTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucQualTime == 0xff) ? "No Data" : (msg.ucQualTime == 0xfe) ? "Out of range" : (msg.ucQualTime == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BypassMode") {
            if (ENUMLOOKUP[9075].find(msg.teBypassMode) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBypassMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBypassMode];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgAcFltCfgSts1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "ExtremeLoV      : " << fnGetValue("ExtremeLoV") << " (" << fnGetRawValue("ExtremeLoV") << ")" << endl;
        cout << "LoV      : " << fnGetValue("LoV") << " (" << fnGetRawValue("LoV") << ")" << endl;
        cout << "HiV      : " << fnGetValue("HiV") << " (" << fnGetRawValue("HiV") << ")" << endl;
        cout << "ExtremeHiV      : " << fnGetValue("ExtremeHiV") << " (" << fnGetRawValue("ExtremeHiV") << ")" << endl;
        cout << "QualTime      : " << fnGetValue("QualTime") << " (" << fnGetRawValue("QualTime") << ")" << endl;
        cout << "BypassMode      : " << fnGetValue("BypassMode") << " (" << fnGetRawValue("BypassMode") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "ExtremeLoV") {
            return static_cast<uint32_t>(msg.ucExtremeLoV);
        }
        else if (mnem == "LoV") {
            return static_cast<uint32_t>(msg.ucLoV);
        }
        else if (mnem == "HiV") {
            return static_cast<uint32_t>(msg.ucHiV);
        }
        else if (mnem == "ExtremeHiV") {
            return static_cast<uint32_t>(msg.ucExtremeHiV);
        }
        else if (mnem == "QualTime") {
            return static_cast<uint32_t>(msg.ucQualTime);
        }
        else if (mnem == "BypassMode") {
            return static_cast<uint32_t>(msg.teBypassMode);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ExtremeLoV") {
     msg.ucExtremeLoV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "LoV") {
     msg.ucLoV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "HiV") {
     msg.ucHiV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "ExtremeHiV") {
     msg.ucExtremeHiV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "QualTime") {
     msg.ucQualTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "BypassMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBypassMode = static_cast<decltype(msg.teBypassMode)>(enumValue);
     else msg.teBypassMode = static_cast<decltype(msg.teBypassMode)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "ExtremeLoV") {
            return 1.0 * (long double)(msg.ucExtremeLoV + 0.0);
        }
        else if (mnem == "LoV") {
            return 1.0 * (long double)(msg.ucLoV + 0.0);
        }
        else if (mnem == "HiV") {
            return 1.0 * (long double)(msg.ucHiV + 0.0);
        }
        else if (mnem == "ExtremeHiV") {
            return 1.0 * (long double)(msg.ucExtremeHiV + 0.0);
        }
        else if (mnem == "QualTime") {
            return 1.0 * (long double)(msg.ucQualTime + 0.0);
        }
        else if (mnem == "BypassMode") {
            return 1.0 * (long double)(msg.teBypassMode + 0.0);
        }
        return 0.0;
    }
} ChgAcFltCfgSts1;

// Auto-generated class definition for RVC_tzPGN_CHG_AC_STS4
typedef struct ChgAcSts4 : public MessageBase {
RVC_tzPGN_CHG_AC_STS4 msg;
ChgAcSts4 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgAcSts4 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_AC_STS4 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[2056474510].find(msg.teLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "VFlt") {
            if (ENUMLOOKUP[1485834791].find(msg.teVFlt) == ENUMLOOKUP[1485834791].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teVFlt);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1485834791][msg.teVFlt];
              }
        }
        else if (mnem == "FltSurgeProt") {
            if (ENUMLOOKUP[9075].find(msg.teFltSurgeProt) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltSurgeProt);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltSurgeProt];
              }
        }
        else if (mnem == "FltHiFreq") {
            if (ENUMLOOKUP[9075].find(msg.teFltHiFreq) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltHiFreq);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltHiFreq];
              }
        }
        else if (mnem == "FltLoFreq") {
            if (ENUMLOOKUP[9075].find(msg.teFltLoFreq) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltLoFreq);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltLoFreq];
              }
        }
        else if (mnem == "BypassModeAct") {
            if (ENUMLOOKUP[9075].find(msg.teBypassModeAct) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBypassModeAct);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBypassModeAct];
              }
        }
        else if (mnem == "QualifStat") {
            if (ENUMLOOKUP[872434401].find(msg.teQualifStat) == ENUMLOOKUP[872434401].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teQualifStat);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[872434401][msg.teQualifStat];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgAcSts4" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "VFlt      : " << fnGetValue("VFlt") << " (" << fnGetRawValue("VFlt") << ")" << endl;
        cout << "FltSurgeProt      : " << fnGetValue("FltSurgeProt") << " (" << fnGetRawValue("FltSurgeProt") << ")" << endl;
        cout << "FltHiFreq      : " << fnGetValue("FltHiFreq") << " (" << fnGetRawValue("FltHiFreq") << ")" << endl;
        cout << "FltLoFreq      : " << fnGetValue("FltLoFreq") << " (" << fnGetRawValue("FltLoFreq") << ")" << endl;
        cout << "BypassModeAct      : " << fnGetValue("BypassModeAct") << " (" << fnGetRawValue("BypassModeAct") << ")" << endl;
        cout << "QualifStat      : " << fnGetValue("QualifStat") << " (" << fnGetRawValue("QualifStat") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "VFlt") {
            return static_cast<uint32_t>(msg.teVFlt);
        }
        else if (mnem == "FltSurgeProt") {
            return static_cast<uint32_t>(msg.teFltSurgeProt);
        }
        else if (mnem == "FltHiFreq") {
            return static_cast<uint32_t>(msg.teFltHiFreq);
        }
        else if (mnem == "FltLoFreq") {
            return static_cast<uint32_t>(msg.teFltLoFreq);
        }
        else if (mnem == "BypassModeAct") {
            return static_cast<uint32_t>(msg.teBypassModeAct);
        }
        else if (mnem == "QualifStat") {
            return static_cast<uint32_t>(msg.teQualifStat);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "VFlt") {
     int enumValue = findEnumValue(ENUMLOOKUP[1485834791], value);
     if (enumValue != -1) msg.teVFlt = static_cast<decltype(msg.teVFlt)>(enumValue);
     else msg.teVFlt = static_cast<decltype(msg.teVFlt)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "FltSurgeProt") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltSurgeProt = static_cast<decltype(msg.teFltSurgeProt)>(enumValue);
     else msg.teFltSurgeProt = static_cast<decltype(msg.teFltSurgeProt)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "FltHiFreq") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltHiFreq = static_cast<decltype(msg.teFltHiFreq)>(enumValue);
     else msg.teFltHiFreq = static_cast<decltype(msg.teFltHiFreq)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "FltLoFreq") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltLoFreq = static_cast<decltype(msg.teFltLoFreq)>(enumValue);
     else msg.teFltLoFreq = static_cast<decltype(msg.teFltLoFreq)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BypassModeAct") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBypassModeAct = static_cast<decltype(msg.teBypassModeAct)>(enumValue);
     else msg.teBypassModeAct = static_cast<decltype(msg.teBypassModeAct)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "QualifStat") {
     int enumValue = findEnumValue(ENUMLOOKUP[872434401], value);
     if (enumValue != -1) msg.teQualifStat = static_cast<decltype(msg.teQualifStat)>(enumValue);
     else msg.teQualifStat = static_cast<decltype(msg.teQualifStat)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "VFlt") {
            return 1.0 * (long double)(msg.teVFlt + 0.0);
        }
        else if (mnem == "FltSurgeProt") {
            return 1.0 * (long double)(msg.teFltSurgeProt + 0.0);
        }
        else if (mnem == "FltHiFreq") {
            return 1.0 * (long double)(msg.teFltHiFreq + 0.0);
        }
        else if (mnem == "FltLoFreq") {
            return 1.0 * (long double)(msg.teFltLoFreq + 0.0);
        }
        else if (mnem == "BypassModeAct") {
            return 1.0 * (long double)(msg.teBypassModeAct + 0.0);
        }
        else if (mnem == "QualifStat") {
            return 1.0 * (long double)(msg.teQualifStat + 0.0);
        }
        return 0.0;
    }
} ChgAcSts4;

// Auto-generated class definition for RVC_tzPGN_INV_AC_FLT_CFG_CMD1
typedef struct InvAcFltCfgCmd1 : public MessageBase {
RVC_tzPGN_INV_AC_FLT_CFG_CMD1 msg;
InvAcFltCfgCmd1 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvAcFltCfgCmd1 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_AC_FLT_CFG_CMD1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "ExtremeLoV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtremeLoV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucExtremeLoV == 0xff) ? "No Data" : (msg.ucExtremeLoV == 0xfe) ? "Out of range" : (msg.ucExtremeLoV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LoV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucLoV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucLoV == 0xff) ? "No Data" : (msg.ucLoV == 0xfe) ? "Out of range" : (msg.ucLoV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "HiV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucHiV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucHiV == 0xff) ? "No Data" : (msg.ucHiV == 0xfe) ? "Out of range" : (msg.ucHiV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ExtremeHiV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtremeHiV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucExtremeHiV == 0xff) ? "No Data" : (msg.ucExtremeHiV == 0xfe) ? "Out of range" : (msg.ucExtremeHiV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "QualTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucQualTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucQualTime == 0xff) ? "No Data" : (msg.ucQualTime == 0xfe) ? "Out of range" : (msg.ucQualTime == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BypassMode") {
            if (ENUMLOOKUP[9075].find(msg.teBypassMode) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBypassMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBypassMode];
              }
        }
        else if (mnem == "RsvBits") {
            return std::to_string(msg.ucRsvBits);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvAcFltCfgCmd1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "ExtremeLoV      : " << fnGetValue("ExtremeLoV") << " (" << fnGetRawValue("ExtremeLoV") << ")" << endl;
        cout << "LoV      : " << fnGetValue("LoV") << " (" << fnGetRawValue("LoV") << ")" << endl;
        cout << "HiV      : " << fnGetValue("HiV") << " (" << fnGetRawValue("HiV") << ")" << endl;
        cout << "ExtremeHiV      : " << fnGetValue("ExtremeHiV") << " (" << fnGetRawValue("ExtremeHiV") << ")" << endl;
        cout << "QualTime      : " << fnGetValue("QualTime") << " (" << fnGetRawValue("QualTime") << ")" << endl;
        cout << "BypassMode      : " << fnGetValue("BypassMode") << " (" << fnGetRawValue("BypassMode") << ")" << endl;
        cout << "RsvBits      : " << fnGetValue("RsvBits") << " (" << fnGetRawValue("RsvBits") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "ExtremeLoV") {
            return static_cast<uint32_t>(msg.ucExtremeLoV);
        }
        else if (mnem == "LoV") {
            return static_cast<uint32_t>(msg.ucLoV);
        }
        else if (mnem == "HiV") {
            return static_cast<uint32_t>(msg.ucHiV);
        }
        else if (mnem == "ExtremeHiV") {
            return static_cast<uint32_t>(msg.ucExtremeHiV);
        }
        else if (mnem == "QualTime") {
            return static_cast<uint32_t>(msg.ucQualTime);
        }
        else if (mnem == "BypassMode") {
            return static_cast<uint32_t>(msg.teBypassMode);
        }
        else if (mnem == "RsvBits") {
            return static_cast<uint32_t>(msg.ucRsvBits);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "ExtremeLoV") {
     msg.ucExtremeLoV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "LoV") {
     msg.ucLoV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "HiV") {
     msg.ucHiV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "ExtremeHiV") {
     msg.ucExtremeHiV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "QualTime") {
     msg.ucQualTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "BypassMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBypassMode = static_cast<decltype(msg.teBypassMode)>(enumValue);
     else msg.teBypassMode = static_cast<decltype(msg.teBypassMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RsvBits") {
     msg.ucRsvBits = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "ExtremeLoV") {
            return 1.0 * (long double)(msg.ucExtremeLoV + 0.0);
        }
        else if (mnem == "LoV") {
            return 1.0 * (long double)(msg.ucLoV + 0.0);
        }
        else if (mnem == "HiV") {
            return 1.0 * (long double)(msg.ucHiV + 0.0);
        }
        else if (mnem == "ExtremeHiV") {
            return 1.0 * (long double)(msg.ucExtremeHiV + 0.0);
        }
        else if (mnem == "QualTime") {
            return 1.0 * (long double)(msg.ucQualTime + 0.0);
        }
        else if (mnem == "BypassMode") {
            return 1.0 * (long double)(msg.teBypassMode + 0.0);
        }
        else if (mnem == "RsvBits") {
            return 1.0 * (long double)(msg.ucRsvBits + 0.0);
        }
        return 0.0;
    }
} InvAcFltCfgCmd1;

// Auto-generated class definition for RVC_tzPGN_INV_AC_FLT_CFG_STS1
typedef struct InvAcFltCfgSts1 : public MessageBase {
RVC_tzPGN_INV_AC_FLT_CFG_STS1 msg;
InvAcFltCfgSts1 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvAcFltCfgSts1 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_AC_FLT_CFG_STS1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "ExtremeLoV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtremeLoV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucExtremeLoV == 0xff) ? "No Data" : (msg.ucExtremeLoV == 0xfe) ? "Out of range" : (msg.ucExtremeLoV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LoV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucLoV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucLoV == 0xff) ? "No Data" : (msg.ucLoV == 0xfe) ? "Out of range" : (msg.ucLoV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "HiV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucHiV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucHiV == 0xff) ? "No Data" : (msg.ucHiV == 0xfe) ? "Out of range" : (msg.ucHiV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ExtremeHiV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtremeHiV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucExtremeHiV == 0xff) ? "No Data" : (msg.ucExtremeHiV == 0xfe) ? "Out of range" : (msg.ucExtremeHiV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "QualTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucQualTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucQualTime == 0xff) ? "No Data" : (msg.ucQualTime == 0xfe) ? "Out of range" : (msg.ucQualTime == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BypassMode") {
            if (ENUMLOOKUP[9075].find(msg.teBypassMode) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBypassMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBypassMode];
              }
        }
        else if (mnem == "RsvBits") {
            return std::to_string(msg.ucRsvBits);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvAcFltCfgSts1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "ExtremeLoV      : " << fnGetValue("ExtremeLoV") << " (" << fnGetRawValue("ExtremeLoV") << ")" << endl;
        cout << "LoV      : " << fnGetValue("LoV") << " (" << fnGetRawValue("LoV") << ")" << endl;
        cout << "HiV      : " << fnGetValue("HiV") << " (" << fnGetRawValue("HiV") << ")" << endl;
        cout << "ExtremeHiV      : " << fnGetValue("ExtremeHiV") << " (" << fnGetRawValue("ExtremeHiV") << ")" << endl;
        cout << "QualTime      : " << fnGetValue("QualTime") << " (" << fnGetRawValue("QualTime") << ")" << endl;
        cout << "BypassMode      : " << fnGetValue("BypassMode") << " (" << fnGetRawValue("BypassMode") << ")" << endl;
        cout << "RsvBits      : " << fnGetValue("RsvBits") << " (" << fnGetRawValue("RsvBits") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "ExtremeLoV") {
            return static_cast<uint32_t>(msg.ucExtremeLoV);
        }
        else if (mnem == "LoV") {
            return static_cast<uint32_t>(msg.ucLoV);
        }
        else if (mnem == "HiV") {
            return static_cast<uint32_t>(msg.ucHiV);
        }
        else if (mnem == "ExtremeHiV") {
            return static_cast<uint32_t>(msg.ucExtremeHiV);
        }
        else if (mnem == "QualTime") {
            return static_cast<uint32_t>(msg.ucQualTime);
        }
        else if (mnem == "BypassMode") {
            return static_cast<uint32_t>(msg.teBypassMode);
        }
        else if (mnem == "RsvBits") {
            return static_cast<uint32_t>(msg.ucRsvBits);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "ExtremeLoV") {
     msg.ucExtremeLoV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "LoV") {
     msg.ucLoV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "HiV") {
     msg.ucHiV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "ExtremeHiV") {
     msg.ucExtremeHiV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "QualTime") {
     msg.ucQualTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "BypassMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBypassMode = static_cast<decltype(msg.teBypassMode)>(enumValue);
     else msg.teBypassMode = static_cast<decltype(msg.teBypassMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RsvBits") {
     msg.ucRsvBits = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "ExtremeLoV") {
            return 1.0 * (long double)(msg.ucExtremeLoV + 0.0);
        }
        else if (mnem == "LoV") {
            return 1.0 * (long double)(msg.ucLoV + 0.0);
        }
        else if (mnem == "HiV") {
            return 1.0 * (long double)(msg.ucHiV + 0.0);
        }
        else if (mnem == "ExtremeHiV") {
            return 1.0 * (long double)(msg.ucExtremeHiV + 0.0);
        }
        else if (mnem == "QualTime") {
            return 1.0 * (long double)(msg.ucQualTime + 0.0);
        }
        else if (mnem == "BypassMode") {
            return 1.0 * (long double)(msg.teBypassMode + 0.0);
        }
        else if (mnem == "RsvBits") {
            return 1.0 * (long double)(msg.ucRsvBits + 0.0);
        }
        return 0.0;
    }
} InvAcFltCfgSts1;

// Auto-generated class definition for RVC_tzPGN_INV_AC_STS4
typedef struct InvAcSts4 : public MessageBase {
RVC_tzPGN_INV_AC_STS4 msg;
InvAcSts4 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvAcSts4 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_AC_STS4 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[2056474510].find(msg.teLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "VFlt") {
            if (ENUMLOOKUP[1485834791].find(msg.teVFlt) == ENUMLOOKUP[1485834791].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teVFlt);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1485834791][msg.teVFlt];
              }
        }
        else if (mnem == "FltSurgeProt") {
            if (ENUMLOOKUP[9075].find(msg.teFltSurgeProt) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltSurgeProt);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltSurgeProt];
              }
        }
        else if (mnem == "FltHiFreq") {
            if (ENUMLOOKUP[9075].find(msg.teFltHiFreq) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltHiFreq);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltHiFreq];
              }
        }
        else if (mnem == "FltLoFreq") {
            if (ENUMLOOKUP[9075].find(msg.teFltLoFreq) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltLoFreq);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltLoFreq];
              }
        }
        else if (mnem == "BypassModeAct") {
            if (ENUMLOOKUP[9075].find(msg.teBypassModeAct) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBypassModeAct);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBypassModeAct];
              }
        }
        else if (mnem == "QualifStat") {
            if (ENUMLOOKUP[872434401].find(msg.teQualifStat) == ENUMLOOKUP[872434401].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teQualifStat);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[872434401][msg.teQualifStat];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvAcSts4" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "VFlt      : " << fnGetValue("VFlt") << " (" << fnGetRawValue("VFlt") << ")" << endl;
        cout << "FltSurgeProt      : " << fnGetValue("FltSurgeProt") << " (" << fnGetRawValue("FltSurgeProt") << ")" << endl;
        cout << "FltHiFreq      : " << fnGetValue("FltHiFreq") << " (" << fnGetRawValue("FltHiFreq") << ")" << endl;
        cout << "FltLoFreq      : " << fnGetValue("FltLoFreq") << " (" << fnGetRawValue("FltLoFreq") << ")" << endl;
        cout << "BypassModeAct      : " << fnGetValue("BypassModeAct") << " (" << fnGetRawValue("BypassModeAct") << ")" << endl;
        cout << "QualifStat      : " << fnGetValue("QualifStat") << " (" << fnGetRawValue("QualifStat") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "VFlt") {
            return static_cast<uint32_t>(msg.teVFlt);
        }
        else if (mnem == "FltSurgeProt") {
            return static_cast<uint32_t>(msg.teFltSurgeProt);
        }
        else if (mnem == "FltHiFreq") {
            return static_cast<uint32_t>(msg.teFltHiFreq);
        }
        else if (mnem == "FltLoFreq") {
            return static_cast<uint32_t>(msg.teFltLoFreq);
        }
        else if (mnem == "BypassModeAct") {
            return static_cast<uint32_t>(msg.teBypassModeAct);
        }
        else if (mnem == "QualifStat") {
            return static_cast<uint32_t>(msg.teQualifStat);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "VFlt") {
     int enumValue = findEnumValue(ENUMLOOKUP[1485834791], value);
     if (enumValue != -1) msg.teVFlt = static_cast<decltype(msg.teVFlt)>(enumValue);
     else msg.teVFlt = static_cast<decltype(msg.teVFlt)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "FltSurgeProt") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltSurgeProt = static_cast<decltype(msg.teFltSurgeProt)>(enumValue);
     else msg.teFltSurgeProt = static_cast<decltype(msg.teFltSurgeProt)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "FltHiFreq") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltHiFreq = static_cast<decltype(msg.teFltHiFreq)>(enumValue);
     else msg.teFltHiFreq = static_cast<decltype(msg.teFltHiFreq)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "FltLoFreq") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltLoFreq = static_cast<decltype(msg.teFltLoFreq)>(enumValue);
     else msg.teFltLoFreq = static_cast<decltype(msg.teFltLoFreq)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BypassModeAct") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBypassModeAct = static_cast<decltype(msg.teBypassModeAct)>(enumValue);
     else msg.teBypassModeAct = static_cast<decltype(msg.teBypassModeAct)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "QualifStat") {
     int enumValue = findEnumValue(ENUMLOOKUP[872434401], value);
     if (enumValue != -1) msg.teQualifStat = static_cast<decltype(msg.teQualifStat)>(enumValue);
     else msg.teQualifStat = static_cast<decltype(msg.teQualifStat)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "VFlt") {
            return 1.0 * (long double)(msg.teVFlt + 0.0);
        }
        else if (mnem == "FltSurgeProt") {
            return 1.0 * (long double)(msg.teFltSurgeProt + 0.0);
        }
        else if (mnem == "FltHiFreq") {
            return 1.0 * (long double)(msg.teFltHiFreq + 0.0);
        }
        else if (mnem == "FltLoFreq") {
            return 1.0 * (long double)(msg.teFltLoFreq + 0.0);
        }
        else if (mnem == "BypassModeAct") {
            return 1.0 * (long double)(msg.teBypassModeAct + 0.0);
        }
        else if (mnem == "QualifStat") {
            return 1.0 * (long double)(msg.teQualifStat + 0.0);
        }
        return 0.0;
    }
} InvAcSts4;

// Auto-generated class definition for RVC_tzPGN_CHG_CFG_CMD2
typedef struct ChgCfgCmd2 : public MessageBase {
RVC_tzPGN_CHG_CFG_CMD2 msg;
ChgCfgCmd2 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgCfgCmd2 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_CFG_CMD2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "MaxChgIPer") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucMaxChgIPer + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucMaxChgIPer == 0xff) ? "No Data" : (msg.ucMaxChgIPer == 0xfe) ? "Out of range" : (msg.ucMaxChgIPer == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ChgRateLimitPerBankSz") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucChgRateLimitPerBankSz + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucChgRateLimitPerBankSz == 0xff) ? "No Data" : (msg.ucChgRateLimitPerBankSz == 0xfe) ? "Out of range" : (msg.ucChgRateLimitPerBankSz == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ShoreBrkSz") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucShoreBrkSz + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "A");
            return (msg.ucShoreBrkSz == 0xff) ? "No Data" : (msg.ucShoreBrkSz == 0xfe) ? "Out of range" : (msg.ucShoreBrkSz == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DefBattTemp") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucDefBattTemp + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucDefBattTemp == 0xff) ? "No Data" : (msg.ucDefBattTemp == 0xfe) ? "Out of range" : (msg.ucDefBattTemp == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ReChgVolt") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiReChgVolt + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiReChgVolt == 0xffff) ? "No Data" : (msg.uiReChgVolt == 0xfffe) ? "Out of range" : (msg.uiReChgVolt == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgCfgCmd2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "MaxChgIPer      : " << fnGetValue("MaxChgIPer") << " (" << fnGetRawValue("MaxChgIPer") << ")" << endl;
        cout << "ChgRateLimitPerBankSz      : " << fnGetValue("ChgRateLimitPerBankSz") << " (" << fnGetRawValue("ChgRateLimitPerBankSz") << ")" << endl;
        cout << "ShoreBrkSz      : " << fnGetValue("ShoreBrkSz") << " (" << fnGetRawValue("ShoreBrkSz") << ")" << endl;
        cout << "DefBattTemp      : " << fnGetValue("DefBattTemp") << " (" << fnGetRawValue("DefBattTemp") << ")" << endl;
        cout << "ReChgVolt      : " << fnGetValue("ReChgVolt") << " (" << fnGetRawValue("ReChgVolt") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "MaxChgIPer") {
            return static_cast<uint32_t>(msg.ucMaxChgIPer);
        }
        else if (mnem == "ChgRateLimitPerBankSz") {
            return static_cast<uint32_t>(msg.ucChgRateLimitPerBankSz);
        }
        else if (mnem == "ShoreBrkSz") {
            return static_cast<uint32_t>(msg.ucShoreBrkSz);
        }
        else if (mnem == "DefBattTemp") {
            return static_cast<uint32_t>(msg.ucDefBattTemp);
        }
        else if (mnem == "ReChgVolt") {
            return static_cast<uint32_t>(msg.uiReChgVolt);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "MaxChgIPer") {
     msg.ucMaxChgIPer = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "ChgRateLimitPerBankSz") {
     msg.ucChgRateLimitPerBankSz = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "ShoreBrkSz") {
     msg.ucShoreBrkSz = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "DefBattTemp") {
     msg.ucDefBattTemp = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
        else if (mnem == "ReChgVolt") {
     msg.uiReChgVolt = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnDefBattTemp2Cmd") return fnDefBattTemp2Cmd(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "MaxChgIPer") {
            return 0.5 * (long double)(msg.ucMaxChgIPer + 0.0);
        }
        else if (mnem == "ChgRateLimitPerBankSz") {
            return 0.5 * (long double)(msg.ucChgRateLimitPerBankSz + 0.0);
        }
        else if (mnem == "ShoreBrkSz") {
            return 1.0 * (long double)(msg.ucShoreBrkSz + 0.0);
        }
        else if (mnem == "DefBattTemp") {
            return 1.0 * (long double)(msg.ucDefBattTemp + -40.0);
        }
        else if (mnem == "ReChgVolt") {
            return 0.05000000074505806 * (long double)(msg.uiReChgVolt + 0.0);
        }
        return 0.0;
    }
} ChgCfgCmd2;

// Auto-generated class definition for RVC_tzPGN_CHG_CFG_STS2
typedef struct ChgCfgSts2 : public MessageBase {
RVC_tzPGN_CHG_CFG_STS2 msg;
ChgCfgSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgCfgSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_CFG_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "MaxChgIPer") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucMaxChgIPer + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucMaxChgIPer == 0xff) ? "No Data" : (msg.ucMaxChgIPer == 0xfe) ? "Out of range" : (msg.ucMaxChgIPer == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ChgRateLimitPerBankSz") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucChgRateLimitPerBankSz + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucChgRateLimitPerBankSz == 0xff) ? "No Data" : (msg.ucChgRateLimitPerBankSz == 0xfe) ? "Out of range" : (msg.ucChgRateLimitPerBankSz == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ShoreBrkSz") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucShoreBrkSz + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "A");
            return (msg.ucShoreBrkSz == 0xff) ? "No Data" : (msg.ucShoreBrkSz == 0xfe) ? "Out of range" : (msg.ucShoreBrkSz == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DefBattTemp") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucDefBattTemp + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucDefBattTemp == 0xff) ? "No Data" : (msg.ucDefBattTemp == 0xfe) ? "Out of range" : (msg.ucDefBattTemp == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ReChgVolt") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiReChgVolt + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiReChgVolt == 0xffff) ? "No Data" : (msg.uiReChgVolt == 0xfffe) ? "Out of range" : (msg.uiReChgVolt == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgCfgSts2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "MaxChgIPer      : " << fnGetValue("MaxChgIPer") << " (" << fnGetRawValue("MaxChgIPer") << ")" << endl;
        cout << "ChgRateLimitPerBankSz      : " << fnGetValue("ChgRateLimitPerBankSz") << " (" << fnGetRawValue("ChgRateLimitPerBankSz") << ")" << endl;
        cout << "ShoreBrkSz      : " << fnGetValue("ShoreBrkSz") << " (" << fnGetRawValue("ShoreBrkSz") << ")" << endl;
        cout << "DefBattTemp      : " << fnGetValue("DefBattTemp") << " (" << fnGetRawValue("DefBattTemp") << ")" << endl;
        cout << "ReChgVolt      : " << fnGetValue("ReChgVolt") << " (" << fnGetRawValue("ReChgVolt") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "MaxChgIPer") {
            return static_cast<uint32_t>(msg.ucMaxChgIPer);
        }
        else if (mnem == "ChgRateLimitPerBankSz") {
            return static_cast<uint32_t>(msg.ucChgRateLimitPerBankSz);
        }
        else if (mnem == "ShoreBrkSz") {
            return static_cast<uint32_t>(msg.ucShoreBrkSz);
        }
        else if (mnem == "DefBattTemp") {
            return static_cast<uint32_t>(msg.ucDefBattTemp);
        }
        else if (mnem == "ReChgVolt") {
            return static_cast<uint32_t>(msg.uiReChgVolt);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "MaxChgIPer") {
     msg.ucMaxChgIPer = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "ChgRateLimitPerBankSz") {
     msg.ucChgRateLimitPerBankSz = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "ShoreBrkSz") {
     msg.ucShoreBrkSz = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "DefBattTemp") {
     msg.ucDefBattTemp = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
        else if (mnem == "ReChgVolt") {
     msg.uiReChgVolt = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnSts2DefBattTemp") return fnSts2DefBattTemp(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "MaxChgIPer") {
            return 0.5 * (long double)(msg.ucMaxChgIPer + 0.0);
        }
        else if (mnem == "ChgRateLimitPerBankSz") {
            return 0.5 * (long double)(msg.ucChgRateLimitPerBankSz + 0.0);
        }
        else if (mnem == "ShoreBrkSz") {
            return 1.0 * (long double)(msg.ucShoreBrkSz + 0.0);
        }
        else if (mnem == "DefBattTemp") {
            return 1.0 * (long double)(msg.ucDefBattTemp + -40.0);
        }
        else if (mnem == "ReChgVolt") {
            return 0.05000000074505806 * (long double)(msg.uiReChgVolt + 0.0);
        }
        return 0.0;
    }
} ChgCfgSts2;

// Auto-generated class definition for RVC_tzPGN_CHG_EQLZ_CFG_CMD
typedef struct ChgEqlzCfgCmd : public MessageBase {
RVC_tzPGN_CHG_EQLZ_CFG_CMD msg;
ChgEqlzCfgCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgEqlzCfgCmd (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_EQLZ_CFG_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "EqlzV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiEqlzV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiEqlzV == 0xffff) ? "No Data" : (msg.uiEqlzV == 0xfffe) ? "Out of range" : (msg.uiEqlzV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "EqlzTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiEqlzTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiEqlzTime == 0xffff) ? "No Data" : (msg.uiEqlzTime == 0xfffe) ? "Out of range" : (msg.uiEqlzTime == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgEqlzCfgCmd" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "EqlzV      : " << fnGetValue("EqlzV") << " (" << fnGetRawValue("EqlzV") << ")" << endl;
        cout << "EqlzTime      : " << fnGetValue("EqlzTime") << " (" << fnGetRawValue("EqlzTime") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "EqlzV") {
            return static_cast<uint32_t>(msg.uiEqlzV);
        }
        else if (mnem == "EqlzTime") {
            return static_cast<uint32_t>(msg.uiEqlzTime);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "EqlzV") {
     msg.uiEqlzV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "EqlzTime") {
     msg.uiEqlzTime = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "EqlzV") {
            return 0.05000000074505806 * (long double)(msg.uiEqlzV + 0.0);
        }
        else if (mnem == "EqlzTime") {
            return 1.0 * (long double)(msg.uiEqlzTime + 0.0);
        }
        return 0.0;
    }
} ChgEqlzCfgCmd;

// Auto-generated class definition for RVC_tzPGN_CHG_EQLZ_CFG_STS
typedef struct ChgEqlzCfgSts : public MessageBase {
RVC_tzPGN_CHG_EQLZ_CFG_STS msg;
ChgEqlzCfgSts () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgEqlzCfgSts (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_EQLZ_CFG_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "EqlzV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiEqlzV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiEqlzV == 0xffff) ? "No Data" : (msg.uiEqlzV == 0xfffe) ? "Out of range" : (msg.uiEqlzV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "EqlzTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiEqlzTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiEqlzTime == 0xffff) ? "No Data" : (msg.uiEqlzTime == 0xfffe) ? "Out of range" : (msg.uiEqlzTime == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgEqlzCfgSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "EqlzV      : " << fnGetValue("EqlzV") << " (" << fnGetRawValue("EqlzV") << ")" << endl;
        cout << "EqlzTime      : " << fnGetValue("EqlzTime") << " (" << fnGetRawValue("EqlzTime") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "EqlzV") {
            return static_cast<uint32_t>(msg.uiEqlzV);
        }
        else if (mnem == "EqlzTime") {
            return static_cast<uint32_t>(msg.uiEqlzTime);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "EqlzV") {
     msg.uiEqlzV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "EqlzTime") {
     msg.uiEqlzTime = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "EqlzV") {
            return 0.05000000074505806 * (long double)(msg.uiEqlzV + 0.0);
        }
        else if (mnem == "EqlzTime") {
            return 1.0 * (long double)(msg.uiEqlzTime + 0.0);
        }
        return 0.0;
    }
} ChgEqlzCfgSts;

// Auto-generated class definition for RVC_tzPGN_CHG_EQLZ_STS
typedef struct ChgEqlzSts : public MessageBase {
RVC_tzPGN_CHG_EQLZ_STS msg;
ChgEqlzSts () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgEqlzSts (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_EQLZ_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "TimeRem") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiTimeRem + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiTimeRem == 0xffff) ? "No Data" : (msg.uiTimeRem == 0xfffe) ? "Out of range" : (msg.uiTimeRem == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "PreChgSts") {
            if (ENUMLOOKUP[1484268128].find(msg.tePreChgSts) == ENUMLOOKUP[1484268128].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.tePreChgSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1484268128][msg.tePreChgSts];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgEqlzSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "TimeRem      : " << fnGetValue("TimeRem") << " (" << fnGetRawValue("TimeRem") << ")" << endl;
        cout << "PreChgSts      : " << fnGetValue("PreChgSts") << " (" << fnGetRawValue("PreChgSts") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "TimeRem") {
            return static_cast<uint32_t>(msg.uiTimeRem);
        }
        else if (mnem == "PreChgSts") {
            return static_cast<uint32_t>(msg.tePreChgSts);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "TimeRem") {
     msg.uiTimeRem = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "PreChgSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[1484268128], value);
     if (enumValue != -1) msg.tePreChgSts = static_cast<decltype(msg.tePreChgSts)>(enumValue);
     else msg.tePreChgSts = static_cast<decltype(msg.tePreChgSts)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "TimeRem") {
            return 1.0 * (long double)(msg.uiTimeRem + 0.0);
        }
        else if (mnem == "PreChgSts") {
            return 1.0 * (long double)(msg.tePreChgSts + 0.0);
        }
        return 0.0;
    }
} ChgEqlzSts;

// Auto-generated class definition for RVC_tzPGN_AC_FLT_CTRL_CFG_CMD2
typedef struct AcFltCtrlCfgCmd2 : public MessageBase {
RVC_tzPGN_AC_FLT_CTRL_CFG_CMD2 msg;
AcFltCtrlCfgCmd2 () {  memset(&msg, 0xFF, sizeof(msg));  };
AcFltCtrlCfgCmd2 (void * pvStruct) {  msg = *(RVC_tzPGN_AC_FLT_CTRL_CFG_CMD2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[9075].find(msg.teLine) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "HiFreqLimit") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucHiFreqLimit + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Hz");
            return (msg.ucHiFreqLimit == 0xff) ? "No Data" : (msg.ucHiFreqLimit == 0xfe) ? "Out of range" : (msg.ucHiFreqLimit == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LoFreqLimit") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucLoFreqLimit + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Hz");
            return (msg.ucLoFreqLimit == 0xff) ? "No Data" : (msg.ucLoFreqLimit == 0xfe) ? "Out of range" : (msg.ucLoFreqLimit == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AcFltCtrlCfgCmd2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "HiFreqLimit      : " << fnGetValue("HiFreqLimit") << " (" << fnGetRawValue("HiFreqLimit") << ")" << endl;
        cout << "LoFreqLimit      : " << fnGetValue("LoFreqLimit") << " (" << fnGetRawValue("LoFreqLimit") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "HiFreqLimit") {
            return static_cast<uint32_t>(msg.ucHiFreqLimit);
        }
        else if (mnem == "LoFreqLimit") {
            return static_cast<uint32_t>(msg.ucLoFreqLimit);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiFreqLimit") {
     msg.ucHiFreqLimit = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "LoFreqLimit") {
     msg.ucLoFreqLimit = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "HiFreqLimit") {
            return 1.0 * (long double)(msg.ucHiFreqLimit + 0.0);
        }
        else if (mnem == "LoFreqLimit") {
            return 1.0 * (long double)(msg.ucLoFreqLimit + 0.0);
        }
        return 0.0;
    }
} AcFltCtrlCfgCmd2;

// Auto-generated class definition for RVC_tzPGN_AC_FLT_CTRL_CFG_CMD1
typedef struct AcFltCtrlCfgCmd1 : public MessageBase {
RVC_tzPGN_AC_FLT_CTRL_CFG_CMD1 msg;
AcFltCtrlCfgCmd1 () {  memset(&msg, 0xFF, sizeof(msg));  };
AcFltCtrlCfgCmd1 (void * pvStruct) {  msg = *(RVC_tzPGN_AC_FLT_CTRL_CFG_CMD1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[9075].find(msg.teLine) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "ExtremeLoV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtremeLoV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucExtremeLoV == 0xff) ? "No Data" : (msg.ucExtremeLoV == 0xfe) ? "Out of range" : (msg.ucExtremeLoV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LoV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucLoV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucLoV == 0xff) ? "No Data" : (msg.ucLoV == 0xfe) ? "Out of range" : (msg.ucLoV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "HiV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucHiV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucHiV == 0xff) ? "No Data" : (msg.ucHiV == 0xfe) ? "Out of range" : (msg.ucHiV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ExtremeHiV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtremeHiV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucExtremeHiV == 0xff) ? "No Data" : (msg.ucExtremeHiV == 0xfe) ? "Out of range" : (msg.ucExtremeHiV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "QualTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucQualTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucQualTime == 0xff) ? "No Data" : (msg.ucQualTime == 0xfe) ? "Out of range" : (msg.ucQualTime == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BypassMode") {
            if (ENUMLOOKUP[9075].find(msg.teBypassMode) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBypassMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBypassMode];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AcFltCtrlCfgCmd1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "ExtremeLoV      : " << fnGetValue("ExtremeLoV") << " (" << fnGetRawValue("ExtremeLoV") << ")" << endl;
        cout << "LoV      : " << fnGetValue("LoV") << " (" << fnGetRawValue("LoV") << ")" << endl;
        cout << "HiV      : " << fnGetValue("HiV") << " (" << fnGetRawValue("HiV") << ")" << endl;
        cout << "ExtremeHiV      : " << fnGetValue("ExtremeHiV") << " (" << fnGetRawValue("ExtremeHiV") << ")" << endl;
        cout << "QualTime      : " << fnGetValue("QualTime") << " (" << fnGetRawValue("QualTime") << ")" << endl;
        cout << "BypassMode      : " << fnGetValue("BypassMode") << " (" << fnGetRawValue("BypassMode") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "ExtremeLoV") {
            return static_cast<uint32_t>(msg.ucExtremeLoV);
        }
        else if (mnem == "LoV") {
            return static_cast<uint32_t>(msg.ucLoV);
        }
        else if (mnem == "HiV") {
            return static_cast<uint32_t>(msg.ucHiV);
        }
        else if (mnem == "ExtremeHiV") {
            return static_cast<uint32_t>(msg.ucExtremeHiV);
        }
        else if (mnem == "QualTime") {
            return static_cast<uint32_t>(msg.ucQualTime);
        }
        else if (mnem == "BypassMode") {
            return static_cast<uint32_t>(msg.teBypassMode);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ExtremeLoV") {
     msg.ucExtremeLoV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "LoV") {
     msg.ucLoV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "HiV") {
     msg.ucHiV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "ExtremeHiV") {
     msg.ucExtremeHiV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "QualTime") {
     msg.ucQualTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "BypassMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBypassMode = static_cast<decltype(msg.teBypassMode)>(enumValue);
     else msg.teBypassMode = static_cast<decltype(msg.teBypassMode)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "ExtremeLoV") {
            return 1.0 * (long double)(msg.ucExtremeLoV + 0.0);
        }
        else if (mnem == "LoV") {
            return 1.0 * (long double)(msg.ucLoV + 0.0);
        }
        else if (mnem == "HiV") {
            return 1.0 * (long double)(msg.ucHiV + 0.0);
        }
        else if (mnem == "ExtremeHiV") {
            return 1.0 * (long double)(msg.ucExtremeHiV + 0.0);
        }
        else if (mnem == "QualTime") {
            return 1.0 * (long double)(msg.ucQualTime + 0.0);
        }
        else if (mnem == "BypassMode") {
            return 1.0 * (long double)(msg.teBypassMode + 0.0);
        }
        return 0.0;
    }
} AcFltCtrlCfgCmd1;

// Auto-generated class definition for RVC_tzPGN_AC_FLT_CTRL_CFG_STS2
typedef struct AcFltCtrlCfgSts2 : public MessageBase {
RVC_tzPGN_AC_FLT_CTRL_CFG_STS2 msg;
AcFltCtrlCfgSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
AcFltCtrlCfgSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_AC_FLT_CTRL_CFG_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[9075].find(msg.teLine) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "HiFreqLimit") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucHiFreqLimit + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Hz");
            return (msg.ucHiFreqLimit == 0xff) ? "No Data" : (msg.ucHiFreqLimit == 0xfe) ? "Out of range" : (msg.ucHiFreqLimit == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LoFreqLimit") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucLoFreqLimit + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Hz");
            return (msg.ucLoFreqLimit == 0xff) ? "No Data" : (msg.ucLoFreqLimit == 0xfe) ? "Out of range" : (msg.ucLoFreqLimit == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AcFltCtrlCfgSts2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "HiFreqLimit      : " << fnGetValue("HiFreqLimit") << " (" << fnGetRawValue("HiFreqLimit") << ")" << endl;
        cout << "LoFreqLimit      : " << fnGetValue("LoFreqLimit") << " (" << fnGetRawValue("LoFreqLimit") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "HiFreqLimit") {
            return static_cast<uint32_t>(msg.ucHiFreqLimit);
        }
        else if (mnem == "LoFreqLimit") {
            return static_cast<uint32_t>(msg.ucLoFreqLimit);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "HiFreqLimit") {
     msg.ucHiFreqLimit = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "LoFreqLimit") {
     msg.ucLoFreqLimit = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "HiFreqLimit") {
            return 1.0 * (long double)(msg.ucHiFreqLimit + 0.0);
        }
        else if (mnem == "LoFreqLimit") {
            return 1.0 * (long double)(msg.ucLoFreqLimit + 0.0);
        }
        return 0.0;
    }
} AcFltCtrlCfgSts2;

// Auto-generated class definition for RVC_tzPGN_AC_FLT_CTRL_CFG_STS1
typedef struct AcFltCtrlCfgSts1 : public MessageBase {
RVC_tzPGN_AC_FLT_CTRL_CFG_STS1 msg;
AcFltCtrlCfgSts1 () {  memset(&msg, 0xFF, sizeof(msg));  };
AcFltCtrlCfgSts1 (void * pvStruct) {  msg = *(RVC_tzPGN_AC_FLT_CTRL_CFG_STS1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[9075].find(msg.teLine) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "ExtremeLoV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtremeLoV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucExtremeLoV == 0xff) ? "No Data" : (msg.ucExtremeLoV == 0xfe) ? "Out of range" : (msg.ucExtremeLoV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LoV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucLoV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucLoV == 0xff) ? "No Data" : (msg.ucLoV == 0xfe) ? "Out of range" : (msg.ucLoV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "HiV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucHiV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucHiV == 0xff) ? "No Data" : (msg.ucHiV == 0xfe) ? "Out of range" : (msg.ucHiV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ExtremeHiV") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucExtremeHiV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "V");
            return (msg.ucExtremeHiV == 0xff) ? "No Data" : (msg.ucExtremeHiV == 0xfe) ? "Out of range" : (msg.ucExtremeHiV == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "QualTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucQualTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucQualTime == 0xff) ? "No Data" : (msg.ucQualTime == 0xfe) ? "Out of range" : (msg.ucQualTime == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BypassMode") {
            if (ENUMLOOKUP[9075].find(msg.teBypassMode) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBypassMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBypassMode];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AcFltCtrlCfgSts1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "ExtremeLoV      : " << fnGetValue("ExtremeLoV") << " (" << fnGetRawValue("ExtremeLoV") << ")" << endl;
        cout << "LoV      : " << fnGetValue("LoV") << " (" << fnGetRawValue("LoV") << ")" << endl;
        cout << "HiV      : " << fnGetValue("HiV") << " (" << fnGetRawValue("HiV") << ")" << endl;
        cout << "ExtremeHiV      : " << fnGetValue("ExtremeHiV") << " (" << fnGetRawValue("ExtremeHiV") << ")" << endl;
        cout << "QualTime      : " << fnGetValue("QualTime") << " (" << fnGetRawValue("QualTime") << ")" << endl;
        cout << "BypassMode      : " << fnGetValue("BypassMode") << " (" << fnGetRawValue("BypassMode") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "ExtremeLoV") {
            return static_cast<uint32_t>(msg.ucExtremeLoV);
        }
        else if (mnem == "LoV") {
            return static_cast<uint32_t>(msg.ucLoV);
        }
        else if (mnem == "HiV") {
            return static_cast<uint32_t>(msg.ucHiV);
        }
        else if (mnem == "ExtremeHiV") {
            return static_cast<uint32_t>(msg.ucExtremeHiV);
        }
        else if (mnem == "QualTime") {
            return static_cast<uint32_t>(msg.ucQualTime);
        }
        else if (mnem == "BypassMode") {
            return static_cast<uint32_t>(msg.teBypassMode);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ExtremeLoV") {
     msg.ucExtremeLoV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "LoV") {
     msg.ucLoV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "HiV") {
     msg.ucHiV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "ExtremeHiV") {
     msg.ucExtremeHiV = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "QualTime") {
     msg.ucQualTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "BypassMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBypassMode = static_cast<decltype(msg.teBypassMode)>(enumValue);
     else msg.teBypassMode = static_cast<decltype(msg.teBypassMode)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "ExtremeLoV") {
            return 1.0 * (long double)(msg.ucExtremeLoV + 0.0);
        }
        else if (mnem == "LoV") {
            return 1.0 * (long double)(msg.ucLoV + 0.0);
        }
        else if (mnem == "HiV") {
            return 1.0 * (long double)(msg.ucHiV + 0.0);
        }
        else if (mnem == "ExtremeHiV") {
            return 1.0 * (long double)(msg.ucExtremeHiV + 0.0);
        }
        else if (mnem == "QualTime") {
            return 1.0 * (long double)(msg.ucQualTime + 0.0);
        }
        else if (mnem == "BypassMode") {
            return 1.0 * (long double)(msg.teBypassMode + 0.0);
        }
        return 0.0;
    }
} AcFltCtrlCfgSts1;

// Auto-generated class definition for RVC_tzPGN_AGS_CRIT_CMD_XFER_AC_V
typedef struct AgsCritCmdXferAcV : public MessageBase {
RVC_tzPGN_AGS_CRIT_CMD_XFER_AC_V msg;
AgsCritCmdXferAcV () {  memset(&msg, 0xFF, sizeof(msg));  };
AgsCritCmdXferAcV (void * pvStruct) {  msg = *(RVC_tzPGN_AGS_CRIT_CMD_XFER_AC_V *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "Cmd") {
            if (ENUMLOOKUP[9066].find(msg.teCmd) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCmd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teCmd];
              }
        }
        else if (mnem == "ActSts") {
            if (ENUMLOOKUP[9066].find(msg.teActSts) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teActSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teActSts];
              }
        }
        else if (mnem == "CritType") {
            if (ENUMLOOKUP[9422].find(msg.teCritType) == ENUMLOOKUP[9422].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCritType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9422][msg.teCritType];
              }
        }
        else if (mnem == "AcInst") {
            return (msg.ucAcInst == 0xff) ? "No Data" : (msg.ucAcInst == 0xfe) ? "Out of range" : (msg.ucAcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucAcInst);
        }
        else if (mnem == "AcVThresh") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiAcVThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiAcVThresh == 0xffff) ? "No Data" : (msg.uiAcVThresh == 0xfffe) ? "Out of range" : (msg.uiAcVThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeUnderThresh") {
            return (msg.ucTimeUnderThresh == 0xff) ? "No Data" : (msg.ucTimeUnderThresh == 0xfe) ? "Out of range" : (msg.ucTimeUnderThresh == 0xfd) ? "Reserved" : std::to_string(msg.ucTimeUnderThresh);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AgsCritCmdXferAcV" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Cmd      : " << fnGetValue("Cmd") << " (" << fnGetRawValue("Cmd") << ")" << endl;
        cout << "ActSts      : " << fnGetValue("ActSts") << " (" << fnGetRawValue("ActSts") << ")" << endl;
        cout << "CritType      : " << fnGetValue("CritType") << " (" << fnGetRawValue("CritType") << ")" << endl;
        cout << "AcInst      : " << fnGetValue("AcInst") << " (" << fnGetRawValue("AcInst") << ")" << endl;
        cout << "AcVThresh      : " << fnGetValue("AcVThresh") << " (" << fnGetRawValue("AcVThresh") << ")" << endl;
        cout << "TimeUnderThresh      : " << fnGetValue("TimeUnderThresh") << " (" << fnGetRawValue("TimeUnderThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Cmd") {
            return static_cast<uint32_t>(msg.teCmd);
        }
        else if (mnem == "ActSts") {
            return static_cast<uint32_t>(msg.teActSts);
        }
        else if (mnem == "CritType") {
            return static_cast<uint32_t>(msg.teCritType);
        }
        else if (mnem == "AcInst") {
            return static_cast<uint32_t>(msg.ucAcInst);
        }
        else if (mnem == "AcVThresh") {
            return static_cast<uint32_t>(msg.uiAcVThresh);
        }
        else if (mnem == "TimeUnderThresh") {
            return static_cast<uint32_t>(msg.ucTimeUnderThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Cmd") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teCmd = static_cast<decltype(msg.teCmd)>(enumValue);
     else msg.teCmd = static_cast<decltype(msg.teCmd)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ActSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teActSts = static_cast<decltype(msg.teActSts)>(enumValue);
     else msg.teActSts = static_cast<decltype(msg.teActSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CritType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9422], value);
     if (enumValue != -1) msg.teCritType = static_cast<decltype(msg.teCritType)>(enumValue);
     else msg.teCritType = static_cast<decltype(msg.teCritType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AcInst") {
     msg.ucAcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "AcVThresh") {
     msg.uiAcVThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "TimeUnderThresh") {
     msg.ucTimeUnderThresh = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Cmd") {
            return 1.0 * (long double)(msg.teCmd + 0.0);
        }
        else if (mnem == "ActSts") {
            return 1.0 * (long double)(msg.teActSts + 0.0);
        }
        else if (mnem == "CritType") {
            return 1.0 * (long double)(msg.teCritType + 0.0);
        }
        else if (mnem == "AcInst") {
            return 1.0 * (long double)(msg.ucAcInst + 0.0);
        }
        else if (mnem == "AcVThresh") {
            return 0.05000000074505806 * (long double)(msg.uiAcVThresh + 0.0);
        }
        else if (mnem == "TimeUnderThresh") {
            return 1.0 * (long double)(msg.ucTimeUnderThresh + 0.0);
        }
        return 0.0;
    }
} AgsCritCmdXferAcV;

// Auto-generated class definition for RVC_tzPGN_AGS_CRIT_CMD_DC_SOC
typedef struct AgsCritCmdDcSoc : public MessageBase {
RVC_tzPGN_AGS_CRIT_CMD_DC_SOC msg;
AgsCritCmdDcSoc () {  memset(&msg, 0xFF, sizeof(msg));  };
AgsCritCmdDcSoc (void * pvStruct) {  msg = *(RVC_tzPGN_AGS_CRIT_CMD_DC_SOC *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "Cmd") {
            if (ENUMLOOKUP[9066].find(msg.teCmd) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCmd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teCmd];
              }
        }
        else if (mnem == "ActSts") {
            if (ENUMLOOKUP[9066].find(msg.teActSts) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teActSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teActSts];
              }
        }
        else if (mnem == "CritType") {
            if (ENUMLOOKUP[9422].find(msg.teCritType) == ENUMLOOKUP[9422].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCritType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9422][msg.teCritType];
              }
        }
        else if (mnem == "DcInst") {
            return (msg.ucDcInst == 0xff) ? "No Data" : (msg.ucDcInst == 0xfe) ? "Out of range" : (msg.ucDcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucDcInst);
        }
        else if (mnem == "DcSocThresh") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucDcSocThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucDcSocThresh == 0xff) ? "No Data" : (msg.ucDcSocThresh == 0xfe) ? "Out of range" : (msg.ucDcSocThresh == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeUnderThresh") {
            return (msg.ucTimeUnderThresh == 0xff) ? "No Data" : (msg.ucTimeUnderThresh == 0xfe) ? "Out of range" : (msg.ucTimeUnderThresh == 0xfd) ? "Reserved" : std::to_string(msg.ucTimeUnderThresh);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AgsCritCmdDcSoc" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Cmd      : " << fnGetValue("Cmd") << " (" << fnGetRawValue("Cmd") << ")" << endl;
        cout << "ActSts      : " << fnGetValue("ActSts") << " (" << fnGetRawValue("ActSts") << ")" << endl;
        cout << "CritType      : " << fnGetValue("CritType") << " (" << fnGetRawValue("CritType") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "DcSocThresh      : " << fnGetValue("DcSocThresh") << " (" << fnGetRawValue("DcSocThresh") << ")" << endl;
        cout << "TimeUnderThresh      : " << fnGetValue("TimeUnderThresh") << " (" << fnGetRawValue("TimeUnderThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Cmd") {
            return static_cast<uint32_t>(msg.teCmd);
        }
        else if (mnem == "ActSts") {
            return static_cast<uint32_t>(msg.teActSts);
        }
        else if (mnem == "CritType") {
            return static_cast<uint32_t>(msg.teCritType);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.ucDcInst);
        }
        else if (mnem == "DcSocThresh") {
            return static_cast<uint32_t>(msg.ucDcSocThresh);
        }
        else if (mnem == "TimeUnderThresh") {
            return static_cast<uint32_t>(msg.ucTimeUnderThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Cmd") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teCmd = static_cast<decltype(msg.teCmd)>(enumValue);
     else msg.teCmd = static_cast<decltype(msg.teCmd)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ActSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teActSts = static_cast<decltype(msg.teActSts)>(enumValue);
     else msg.teActSts = static_cast<decltype(msg.teActSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CritType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9422], value);
     if (enumValue != -1) msg.teCritType = static_cast<decltype(msg.teCritType)>(enumValue);
     else msg.teCritType = static_cast<decltype(msg.teCritType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     msg.ucDcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcSocThresh") {
     msg.ucDcSocThresh = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "TimeUnderThresh") {
     msg.ucTimeUnderThresh = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Cmd") {
            return 1.0 * (long double)(msg.teCmd + 0.0);
        }
        else if (mnem == "ActSts") {
            return 1.0 * (long double)(msg.teActSts + 0.0);
        }
        else if (mnem == "CritType") {
            return 1.0 * (long double)(msg.teCritType + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.ucDcInst + 0.0);
        }
        else if (mnem == "DcSocThresh") {
            return 0.5 * (long double)(msg.ucDcSocThresh + 0.0);
        }
        else if (mnem == "TimeUnderThresh") {
            return 1.0 * (long double)(msg.ucTimeUnderThresh + 0.0);
        }
        return 0.0;
    }
} AgsCritCmdDcSoc;

// Auto-generated class definition for RVC_tzPGN_AGS_CRIT_CMD_DC_V
typedef struct AgsCritCmdDcV : public MessageBase {
RVC_tzPGN_AGS_CRIT_CMD_DC_V msg;
AgsCritCmdDcV () {  memset(&msg, 0xFF, sizeof(msg));  };
AgsCritCmdDcV (void * pvStruct) {  msg = *(RVC_tzPGN_AGS_CRIT_CMD_DC_V *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "Cmd") {
            if (ENUMLOOKUP[9066].find(msg.teCmd) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCmd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teCmd];
              }
        }
        else if (mnem == "ActSts") {
            if (ENUMLOOKUP[9066].find(msg.teActSts) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teActSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teActSts];
              }
        }
        else if (mnem == "CritType") {
            if (ENUMLOOKUP[9422].find(msg.teCritType) == ENUMLOOKUP[9422].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCritType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9422][msg.teCritType];
              }
        }
        else if (mnem == "DcInst") {
            return (msg.ucDcInst == 0xff) ? "No Data" : (msg.ucDcInst == 0xfe) ? "Out of range" : (msg.ucDcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucDcInst);
        }
        else if (mnem == "DcVThresh") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcVThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcVThresh == 0xffff) ? "No Data" : (msg.uiDcVThresh == 0xfffe) ? "Out of range" : (msg.uiDcVThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeUnderThresh") {
            return (msg.ucTimeUnderThresh == 0xff) ? "No Data" : (msg.ucTimeUnderThresh == 0xfe) ? "Out of range" : (msg.ucTimeUnderThresh == 0xfd) ? "Reserved" : std::to_string(msg.ucTimeUnderThresh);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AgsCritCmdDcV" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Cmd      : " << fnGetValue("Cmd") << " (" << fnGetRawValue("Cmd") << ")" << endl;
        cout << "ActSts      : " << fnGetValue("ActSts") << " (" << fnGetRawValue("ActSts") << ")" << endl;
        cout << "CritType      : " << fnGetValue("CritType") << " (" << fnGetRawValue("CritType") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "DcVThresh      : " << fnGetValue("DcVThresh") << " (" << fnGetRawValue("DcVThresh") << ")" << endl;
        cout << "TimeUnderThresh      : " << fnGetValue("TimeUnderThresh") << " (" << fnGetRawValue("TimeUnderThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Cmd") {
            return static_cast<uint32_t>(msg.teCmd);
        }
        else if (mnem == "ActSts") {
            return static_cast<uint32_t>(msg.teActSts);
        }
        else if (mnem == "CritType") {
            return static_cast<uint32_t>(msg.teCritType);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.ucDcInst);
        }
        else if (mnem == "DcVThresh") {
            return static_cast<uint32_t>(msg.uiDcVThresh);
        }
        else if (mnem == "TimeUnderThresh") {
            return static_cast<uint32_t>(msg.ucTimeUnderThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Cmd") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teCmd = static_cast<decltype(msg.teCmd)>(enumValue);
     else msg.teCmd = static_cast<decltype(msg.teCmd)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ActSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teActSts = static_cast<decltype(msg.teActSts)>(enumValue);
     else msg.teActSts = static_cast<decltype(msg.teActSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CritType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9422], value);
     if (enumValue != -1) msg.teCritType = static_cast<decltype(msg.teCritType)>(enumValue);
     else msg.teCritType = static_cast<decltype(msg.teCritType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     msg.ucDcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcVThresh") {
     msg.uiDcVThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "TimeUnderThresh") {
     msg.ucTimeUnderThresh = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Cmd") {
            return 1.0 * (long double)(msg.teCmd + 0.0);
        }
        else if (mnem == "ActSts") {
            return 1.0 * (long double)(msg.teActSts + 0.0);
        }
        else if (mnem == "CritType") {
            return 1.0 * (long double)(msg.teCritType + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.ucDcInst + 0.0);
        }
        else if (mnem == "DcVThresh") {
            return 0.05000000074505806 * (long double)(msg.uiDcVThresh + 0.0);
        }
        else if (mnem == "TimeUnderThresh") {
            return 1.0 * (long double)(msg.ucTimeUnderThresh + 0.0);
        }
        return 0.0;
    }
} AgsCritCmdDcV;

// Auto-generated class definition for RVC_tzPGN_AGS_CRIT_CMD_AMB_TEMP
typedef struct AgsCritCmdAmbTemp : public MessageBase {
RVC_tzPGN_AGS_CRIT_CMD_AMB_TEMP msg;
AgsCritCmdAmbTemp () {  memset(&msg, 0xFF, sizeof(msg));  };
AgsCritCmdAmbTemp (void * pvStruct) {  msg = *(RVC_tzPGN_AGS_CRIT_CMD_AMB_TEMP *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "Cmd") {
            if (ENUMLOOKUP[9066].find(msg.teCmd) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCmd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teCmd];
              }
        }
        else if (mnem == "ActSts") {
            if (ENUMLOOKUP[9066].find(msg.teActSts) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teActSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teActSts];
              }
        }
        else if (mnem == "CritType") {
            if (ENUMLOOKUP[9422].find(msg.teCritType) == ENUMLOOKUP[9422].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCritType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9422][msg.teCritType];
              }
        }
        else if (mnem == "ThermAmbInst") {
            return (msg.ucThermAmbInst == 0xff) ? "No Data" : (msg.ucThermAmbInst == 0xfe) ? "Out of range" : (msg.ucThermAmbInst == 0xfd) ? "Reserved" : std::to_string(msg.ucThermAmbInst);
        }
        else if (mnem == "AmbTempThresh") {
            char buffer[50];
            auto engval = 0.03125 * (long double) (msg.uiAmbTempThresh + -8736.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "deg C");
            return (msg.uiAmbTempThresh == 0xffff) ? "No Data" : (msg.uiAmbTempThresh == 0xfffe) ? "Out of range" : (msg.uiAmbTempThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeUnderThresh") {
            return (msg.ucTimeUnderThresh == 0xff) ? "No Data" : (msg.ucTimeUnderThresh == 0xfe) ? "Out of range" : (msg.ucTimeUnderThresh == 0xfd) ? "Reserved" : std::to_string(msg.ucTimeUnderThresh);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AgsCritCmdAmbTemp" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Cmd      : " << fnGetValue("Cmd") << " (" << fnGetRawValue("Cmd") << ")" << endl;
        cout << "ActSts      : " << fnGetValue("ActSts") << " (" << fnGetRawValue("ActSts") << ")" << endl;
        cout << "CritType      : " << fnGetValue("CritType") << " (" << fnGetRawValue("CritType") << ")" << endl;
        cout << "ThermAmbInst      : " << fnGetValue("ThermAmbInst") << " (" << fnGetRawValue("ThermAmbInst") << ")" << endl;
        cout << "AmbTempThresh      : " << fnGetValue("AmbTempThresh") << " (" << fnGetRawValue("AmbTempThresh") << ")" << endl;
        cout << "TimeUnderThresh      : " << fnGetValue("TimeUnderThresh") << " (" << fnGetRawValue("TimeUnderThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Cmd") {
            return static_cast<uint32_t>(msg.teCmd);
        }
        else if (mnem == "ActSts") {
            return static_cast<uint32_t>(msg.teActSts);
        }
        else if (mnem == "CritType") {
            return static_cast<uint32_t>(msg.teCritType);
        }
        else if (mnem == "ThermAmbInst") {
            return static_cast<uint32_t>(msg.ucThermAmbInst);
        }
        else if (mnem == "AmbTempThresh") {
            return static_cast<uint32_t>(msg.uiAmbTempThresh);
        }
        else if (mnem == "TimeUnderThresh") {
            return static_cast<uint32_t>(msg.ucTimeUnderThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Cmd") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teCmd = static_cast<decltype(msg.teCmd)>(enumValue);
     else msg.teCmd = static_cast<decltype(msg.teCmd)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ActSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teActSts = static_cast<decltype(msg.teActSts)>(enumValue);
     else msg.teActSts = static_cast<decltype(msg.teActSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CritType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9422], value);
     if (enumValue != -1) msg.teCritType = static_cast<decltype(msg.teCritType)>(enumValue);
     else msg.teCritType = static_cast<decltype(msg.teCritType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ThermAmbInst") {
     msg.ucThermAmbInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "AmbTempThresh") {
     msg.uiAmbTempThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.03125, -8736.0);
        }
        else if (mnem == "TimeUnderThresh") {
     msg.ucTimeUnderThresh = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Cmd") {
            return 1.0 * (long double)(msg.teCmd + 0.0);
        }
        else if (mnem == "ActSts") {
            return 1.0 * (long double)(msg.teActSts + 0.0);
        }
        else if (mnem == "CritType") {
            return 1.0 * (long double)(msg.teCritType + 0.0);
        }
        else if (mnem == "ThermAmbInst") {
            return 1.0 * (long double)(msg.ucThermAmbInst + 0.0);
        }
        else if (mnem == "AmbTempThresh") {
            return 0.03125 * (long double)(msg.uiAmbTempThresh + -8736.0);
        }
        else if (mnem == "TimeUnderThresh") {
            return 1.0 * (long double)(msg.ucTimeUnderThresh + 0.0);
        }
        return 0.0;
    }
} AgsCritCmdAmbTemp;

// Auto-generated class definition for RVC_tzPGN_AGS_CRIT_CMD_DC_I
typedef struct AgsCritCmdDcI : public MessageBase {
RVC_tzPGN_AGS_CRIT_CMD_DC_I msg;
AgsCritCmdDcI () {  memset(&msg, 0xFF, sizeof(msg));  };
AgsCritCmdDcI (void * pvStruct) {  msg = *(RVC_tzPGN_AGS_CRIT_CMD_DC_I *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "Cmd") {
            if (ENUMLOOKUP[9066].find(msg.teCmd) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCmd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teCmd];
              }
        }
        else if (mnem == "ActSts") {
            if (ENUMLOOKUP[9066].find(msg.teActSts) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teActSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teActSts];
              }
        }
        else if (mnem == "CritType") {
            if (ENUMLOOKUP[9422].find(msg.teCritType) == ENUMLOOKUP[9422].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCritType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9422][msg.teCritType];
              }
        }
        else if (mnem == "DcInst") {
            return (msg.ucDcInst == 0xff) ? "No Data" : (msg.ucDcInst == 0xfe) ? "Out of range" : (msg.ucDcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucDcInst);
        }
        else if (mnem == "DcIThresh") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcIThresh + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiDcIThresh == 0xffff) ? "No Data" : (msg.uiDcIThresh == 0xfffe) ? "Out of range" : (msg.uiDcIThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeOverThresh") {
            return (msg.ucTimeOverThresh == 0xff) ? "No Data" : (msg.ucTimeOverThresh == 0xfe) ? "Out of range" : (msg.ucTimeOverThresh == 0xfd) ? "Reserved" : std::to_string(msg.ucTimeOverThresh);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AgsCritCmdDcI" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Cmd      : " << fnGetValue("Cmd") << " (" << fnGetRawValue("Cmd") << ")" << endl;
        cout << "ActSts      : " << fnGetValue("ActSts") << " (" << fnGetRawValue("ActSts") << ")" << endl;
        cout << "CritType      : " << fnGetValue("CritType") << " (" << fnGetRawValue("CritType") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "DcIThresh      : " << fnGetValue("DcIThresh") << " (" << fnGetRawValue("DcIThresh") << ")" << endl;
        cout << "TimeOverThresh      : " << fnGetValue("TimeOverThresh") << " (" << fnGetRawValue("TimeOverThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Cmd") {
            return static_cast<uint32_t>(msg.teCmd);
        }
        else if (mnem == "ActSts") {
            return static_cast<uint32_t>(msg.teActSts);
        }
        else if (mnem == "CritType") {
            return static_cast<uint32_t>(msg.teCritType);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.ucDcInst);
        }
        else if (mnem == "DcIThresh") {
            return static_cast<uint32_t>(msg.uiDcIThresh);
        }
        else if (mnem == "TimeOverThresh") {
            return static_cast<uint32_t>(msg.ucTimeOverThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Cmd") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teCmd = static_cast<decltype(msg.teCmd)>(enumValue);
     else msg.teCmd = static_cast<decltype(msg.teCmd)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ActSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teActSts = static_cast<decltype(msg.teActSts)>(enumValue);
     else msg.teActSts = static_cast<decltype(msg.teActSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CritType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9422], value);
     if (enumValue != -1) msg.teCritType = static_cast<decltype(msg.teCritType)>(enumValue);
     else msg.teCritType = static_cast<decltype(msg.teCritType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     msg.ucDcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcIThresh") {
     msg.uiDcIThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "TimeOverThresh") {
     msg.ucTimeOverThresh = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Cmd") {
            return 1.0 * (long double)(msg.teCmd + 0.0);
        }
        else if (mnem == "ActSts") {
            return 1.0 * (long double)(msg.teActSts + 0.0);
        }
        else if (mnem == "CritType") {
            return 1.0 * (long double)(msg.teCritType + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.ucDcInst + 0.0);
        }
        else if (mnem == "DcIThresh") {
            return 0.05000000074505806 * (long double)(msg.uiDcIThresh + -32000.0);
        }
        else if (mnem == "TimeOverThresh") {
            return 1.0 * (long double)(msg.ucTimeOverThresh + 0.0);
        }
        return 0.0;
    }
} AgsCritCmdDcI;

// Auto-generated class definition for RVC_tzPGN_AGS_CRIT_STS_AMB_TEMP
typedef struct AgsCritStsAmbTemp : public MessageBase {
RVC_tzPGN_AGS_CRIT_STS_AMB_TEMP msg;
AgsCritStsAmbTemp () {  memset(&msg, 0xFF, sizeof(msg));  };
AgsCritStsAmbTemp (void * pvStruct) {  msg = *(RVC_tzPGN_AGS_CRIT_STS_AMB_TEMP *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "CurrDemandSts") {
            if (ENUMLOOKUP[9075].find(msg.teCurrDemandSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCurrDemandSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teCurrDemandSts];
              }
        }
        else if (mnem == "ActSts") {
            if (ENUMLOOKUP[9075].find(msg.teActSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teActSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teActSts];
              }
        }
        else if (mnem == "CritType") {
            if (ENUMLOOKUP[9422].find(msg.teCritType) == ENUMLOOKUP[9422].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCritType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9422][msg.teCritType];
              }
        }
        else if (mnem == "ThermAmbInst") {
            return (msg.ucThermAmbInst == 0xff) ? "No Data" : (msg.ucThermAmbInst == 0xfe) ? "Out of range" : (msg.ucThermAmbInst == 0xfd) ? "Reserved" : std::to_string(msg.ucThermAmbInst);
        }
        else if (mnem == "AmbTempThresh") {
            char buffer[50];
            auto engval = 0.03125 * (long double) (msg.uiAmbTempThresh + -8736.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "deg C");
            return (msg.uiAmbTempThresh == 0xffff) ? "No Data" : (msg.uiAmbTempThresh == 0xfffe) ? "Out of range" : (msg.uiAmbTempThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeUnderThresh") {
            return (msg.ucTimeUnderThresh == 0xff) ? "No Data" : (msg.ucTimeUnderThresh == 0xfe) ? "Out of range" : (msg.ucTimeUnderThresh == 0xfd) ? "Reserved" : std::to_string(msg.ucTimeUnderThresh);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AgsCritStsAmbTemp" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "CurrDemandSts      : " << fnGetValue("CurrDemandSts") << " (" << fnGetRawValue("CurrDemandSts") << ")" << endl;
        cout << "ActSts      : " << fnGetValue("ActSts") << " (" << fnGetRawValue("ActSts") << ")" << endl;
        cout << "CritType      : " << fnGetValue("CritType") << " (" << fnGetRawValue("CritType") << ")" << endl;
        cout << "ThermAmbInst      : " << fnGetValue("ThermAmbInst") << " (" << fnGetRawValue("ThermAmbInst") << ")" << endl;
        cout << "AmbTempThresh      : " << fnGetValue("AmbTempThresh") << " (" << fnGetRawValue("AmbTempThresh") << ")" << endl;
        cout << "TimeUnderThresh      : " << fnGetValue("TimeUnderThresh") << " (" << fnGetRawValue("TimeUnderThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "CurrDemandSts") {
            return static_cast<uint32_t>(msg.teCurrDemandSts);
        }
        else if (mnem == "ActSts") {
            return static_cast<uint32_t>(msg.teActSts);
        }
        else if (mnem == "CritType") {
            return static_cast<uint32_t>(msg.teCritType);
        }
        else if (mnem == "ThermAmbInst") {
            return static_cast<uint32_t>(msg.ucThermAmbInst);
        }
        else if (mnem == "AmbTempThresh") {
            return static_cast<uint32_t>(msg.uiAmbTempThresh);
        }
        else if (mnem == "TimeUnderThresh") {
            return static_cast<uint32_t>(msg.ucTimeUnderThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "CurrDemandSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teCurrDemandSts = static_cast<decltype(msg.teCurrDemandSts)>(enumValue);
     else msg.teCurrDemandSts = static_cast<decltype(msg.teCurrDemandSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ActSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teActSts = static_cast<decltype(msg.teActSts)>(enumValue);
     else msg.teActSts = static_cast<decltype(msg.teActSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CritType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9422], value);
     if (enumValue != -1) msg.teCritType = static_cast<decltype(msg.teCritType)>(enumValue);
     else msg.teCritType = static_cast<decltype(msg.teCritType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ThermAmbInst") {
     msg.ucThermAmbInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "AmbTempThresh") {
     msg.uiAmbTempThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.03125, -8736.0);
        }
        else if (mnem == "TimeUnderThresh") {
     msg.ucTimeUnderThresh = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "CurrDemandSts") {
            return 1.0 * (long double)(msg.teCurrDemandSts + 0.0);
        }
        else if (mnem == "ActSts") {
            return 1.0 * (long double)(msg.teActSts + 0.0);
        }
        else if (mnem == "CritType") {
            return 1.0 * (long double)(msg.teCritType + 0.0);
        }
        else if (mnem == "ThermAmbInst") {
            return 1.0 * (long double)(msg.ucThermAmbInst + 0.0);
        }
        else if (mnem == "AmbTempThresh") {
            return 0.03125 * (long double)(msg.uiAmbTempThresh + -8736.0);
        }
        else if (mnem == "TimeUnderThresh") {
            return 1.0 * (long double)(msg.ucTimeUnderThresh + 0.0);
        }
        return 0.0;
    }
} AgsCritStsAmbTemp;

// Auto-generated class definition for RVC_tzPGN_AGS_CRIT_STS_DC_V
typedef struct AgsCritStsDcV : public MessageBase {
RVC_tzPGN_AGS_CRIT_STS_DC_V msg;
AgsCritStsDcV () {  memset(&msg, 0xFF, sizeof(msg));  };
AgsCritStsDcV (void * pvStruct) {  msg = *(RVC_tzPGN_AGS_CRIT_STS_DC_V *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "CurrDemandSts") {
            if (ENUMLOOKUP[9075].find(msg.teCurrDemandSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCurrDemandSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teCurrDemandSts];
              }
        }
        else if (mnem == "ActSts") {
            if (ENUMLOOKUP[9075].find(msg.teActSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teActSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teActSts];
              }
        }
        else if (mnem == "CritType") {
            if (ENUMLOOKUP[9422].find(msg.teCritType) == ENUMLOOKUP[9422].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCritType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9422][msg.teCritType];
              }
        }
        else if (mnem == "DcInst") {
            return (msg.ucDcInst == 0xff) ? "No Data" : (msg.ucDcInst == 0xfe) ? "Out of range" : (msg.ucDcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucDcInst);
        }
        else if (mnem == "DcVThresh") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcVThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcVThresh == 0xffff) ? "No Data" : (msg.uiDcVThresh == 0xfffe) ? "Out of range" : (msg.uiDcVThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeUnderThresh") {
            return (msg.ucTimeUnderThresh == 0xff) ? "No Data" : (msg.ucTimeUnderThresh == 0xfe) ? "Out of range" : (msg.ucTimeUnderThresh == 0xfd) ? "Reserved" : std::to_string(msg.ucTimeUnderThresh);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AgsCritStsDcV" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "CurrDemandSts      : " << fnGetValue("CurrDemandSts") << " (" << fnGetRawValue("CurrDemandSts") << ")" << endl;
        cout << "ActSts      : " << fnGetValue("ActSts") << " (" << fnGetRawValue("ActSts") << ")" << endl;
        cout << "CritType      : " << fnGetValue("CritType") << " (" << fnGetRawValue("CritType") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "DcVThresh      : " << fnGetValue("DcVThresh") << " (" << fnGetRawValue("DcVThresh") << ")" << endl;
        cout << "TimeUnderThresh      : " << fnGetValue("TimeUnderThresh") << " (" << fnGetRawValue("TimeUnderThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "CurrDemandSts") {
            return static_cast<uint32_t>(msg.teCurrDemandSts);
        }
        else if (mnem == "ActSts") {
            return static_cast<uint32_t>(msg.teActSts);
        }
        else if (mnem == "CritType") {
            return static_cast<uint32_t>(msg.teCritType);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.ucDcInst);
        }
        else if (mnem == "DcVThresh") {
            return static_cast<uint32_t>(msg.uiDcVThresh);
        }
        else if (mnem == "TimeUnderThresh") {
            return static_cast<uint32_t>(msg.ucTimeUnderThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "CurrDemandSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teCurrDemandSts = static_cast<decltype(msg.teCurrDemandSts)>(enumValue);
     else msg.teCurrDemandSts = static_cast<decltype(msg.teCurrDemandSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ActSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teActSts = static_cast<decltype(msg.teActSts)>(enumValue);
     else msg.teActSts = static_cast<decltype(msg.teActSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CritType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9422], value);
     if (enumValue != -1) msg.teCritType = static_cast<decltype(msg.teCritType)>(enumValue);
     else msg.teCritType = static_cast<decltype(msg.teCritType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     msg.ucDcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcVThresh") {
     msg.uiDcVThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "TimeUnderThresh") {
     msg.ucTimeUnderThresh = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "CurrDemandSts") {
            return 1.0 * (long double)(msg.teCurrDemandSts + 0.0);
        }
        else if (mnem == "ActSts") {
            return 1.0 * (long double)(msg.teActSts + 0.0);
        }
        else if (mnem == "CritType") {
            return 1.0 * (long double)(msg.teCritType + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.ucDcInst + 0.0);
        }
        else if (mnem == "DcVThresh") {
            return 0.05000000074505806 * (long double)(msg.uiDcVThresh + 0.0);
        }
        else if (mnem == "TimeUnderThresh") {
            return 1.0 * (long double)(msg.ucTimeUnderThresh + 0.0);
        }
        return 0.0;
    }
} AgsCritStsDcV;

// Auto-generated class definition for RVC_tzPGN_AGS_CRIT_STS_DC_SOC
typedef struct AgsCritStsDcSoc : public MessageBase {
RVC_tzPGN_AGS_CRIT_STS_DC_SOC msg;
AgsCritStsDcSoc () {  memset(&msg, 0xFF, sizeof(msg));  };
AgsCritStsDcSoc (void * pvStruct) {  msg = *(RVC_tzPGN_AGS_CRIT_STS_DC_SOC *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "CurrDemandSts") {
            if (ENUMLOOKUP[9075].find(msg.teCurrDemandSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCurrDemandSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teCurrDemandSts];
              }
        }
        else if (mnem == "ActSts") {
            if (ENUMLOOKUP[9075].find(msg.teActSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teActSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teActSts];
              }
        }
        else if (mnem == "CritType") {
            if (ENUMLOOKUP[9422].find(msg.teCritType) == ENUMLOOKUP[9422].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCritType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9422][msg.teCritType];
              }
        }
        else if (mnem == "DcInst") {
            return (msg.ucDcInst == 0xff) ? "No Data" : (msg.ucDcInst == 0xfe) ? "Out of range" : (msg.ucDcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucDcInst);
        }
        else if (mnem == "DcSocThresh") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucDcSocThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucDcSocThresh == 0xff) ? "No Data" : (msg.ucDcSocThresh == 0xfe) ? "Out of range" : (msg.ucDcSocThresh == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeUnderThresh") {
            return (msg.ucTimeUnderThresh == 0xff) ? "No Data" : (msg.ucTimeUnderThresh == 0xfe) ? "Out of range" : (msg.ucTimeUnderThresh == 0xfd) ? "Reserved" : std::to_string(msg.ucTimeUnderThresh);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AgsCritStsDcSoc" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "CurrDemandSts      : " << fnGetValue("CurrDemandSts") << " (" << fnGetRawValue("CurrDemandSts") << ")" << endl;
        cout << "ActSts      : " << fnGetValue("ActSts") << " (" << fnGetRawValue("ActSts") << ")" << endl;
        cout << "CritType      : " << fnGetValue("CritType") << " (" << fnGetRawValue("CritType") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "DcSocThresh      : " << fnGetValue("DcSocThresh") << " (" << fnGetRawValue("DcSocThresh") << ")" << endl;
        cout << "TimeUnderThresh      : " << fnGetValue("TimeUnderThresh") << " (" << fnGetRawValue("TimeUnderThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "CurrDemandSts") {
            return static_cast<uint32_t>(msg.teCurrDemandSts);
        }
        else if (mnem == "ActSts") {
            return static_cast<uint32_t>(msg.teActSts);
        }
        else if (mnem == "CritType") {
            return static_cast<uint32_t>(msg.teCritType);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.ucDcInst);
        }
        else if (mnem == "DcSocThresh") {
            return static_cast<uint32_t>(msg.ucDcSocThresh);
        }
        else if (mnem == "TimeUnderThresh") {
            return static_cast<uint32_t>(msg.ucTimeUnderThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "CurrDemandSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teCurrDemandSts = static_cast<decltype(msg.teCurrDemandSts)>(enumValue);
     else msg.teCurrDemandSts = static_cast<decltype(msg.teCurrDemandSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ActSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teActSts = static_cast<decltype(msg.teActSts)>(enumValue);
     else msg.teActSts = static_cast<decltype(msg.teActSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CritType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9422], value);
     if (enumValue != -1) msg.teCritType = static_cast<decltype(msg.teCritType)>(enumValue);
     else msg.teCritType = static_cast<decltype(msg.teCritType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     msg.ucDcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcSocThresh") {
     msg.ucDcSocThresh = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "TimeUnderThresh") {
     msg.ucTimeUnderThresh = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "CurrDemandSts") {
            return 1.0 * (long double)(msg.teCurrDemandSts + 0.0);
        }
        else if (mnem == "ActSts") {
            return 1.0 * (long double)(msg.teActSts + 0.0);
        }
        else if (mnem == "CritType") {
            return 1.0 * (long double)(msg.teCritType + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.ucDcInst + 0.0);
        }
        else if (mnem == "DcSocThresh") {
            return 0.5 * (long double)(msg.ucDcSocThresh + 0.0);
        }
        else if (mnem == "TimeUnderThresh") {
            return 1.0 * (long double)(msg.ucTimeUnderThresh + 0.0);
        }
        return 0.0;
    }
} AgsCritStsDcSoc;

// Auto-generated class definition for RVC_tzPGN_AGS_CRIT_STS_DC_I
typedef struct AgsCritStsDcI : public MessageBase {
RVC_tzPGN_AGS_CRIT_STS_DC_I msg;
AgsCritStsDcI () {  memset(&msg, 0xFF, sizeof(msg));  };
AgsCritStsDcI (void * pvStruct) {  msg = *(RVC_tzPGN_AGS_CRIT_STS_DC_I *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "CurrDemandSts") {
            if (ENUMLOOKUP[9075].find(msg.teCurrDemandSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCurrDemandSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teCurrDemandSts];
              }
        }
        else if (mnem == "ActSts") {
            if (ENUMLOOKUP[9075].find(msg.teActSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teActSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teActSts];
              }
        }
        else if (mnem == "CritType") {
            if (ENUMLOOKUP[9422].find(msg.teCritType) == ENUMLOOKUP[9422].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCritType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9422][msg.teCritType];
              }
        }
        else if (mnem == "DcInst") {
            return (msg.ucDcInst == 0xff) ? "No Data" : (msg.ucDcInst == 0xfe) ? "Out of range" : (msg.ucDcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucDcInst);
        }
        else if (mnem == "DcIThresh") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcIThresh + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiDcIThresh == 0xffff) ? "No Data" : (msg.uiDcIThresh == 0xfffe) ? "Out of range" : (msg.uiDcIThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeOverThresh") {
            return (msg.ucTimeOverThresh == 0xff) ? "No Data" : (msg.ucTimeOverThresh == 0xfe) ? "Out of range" : (msg.ucTimeOverThresh == 0xfd) ? "Reserved" : std::to_string(msg.ucTimeOverThresh);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AgsCritStsDcI" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "CurrDemandSts      : " << fnGetValue("CurrDemandSts") << " (" << fnGetRawValue("CurrDemandSts") << ")" << endl;
        cout << "ActSts      : " << fnGetValue("ActSts") << " (" << fnGetRawValue("ActSts") << ")" << endl;
        cout << "CritType      : " << fnGetValue("CritType") << " (" << fnGetRawValue("CritType") << ")" << endl;
        cout << "DcInst      : " << fnGetValue("DcInst") << " (" << fnGetRawValue("DcInst") << ")" << endl;
        cout << "DcIThresh      : " << fnGetValue("DcIThresh") << " (" << fnGetRawValue("DcIThresh") << ")" << endl;
        cout << "TimeOverThresh      : " << fnGetValue("TimeOverThresh") << " (" << fnGetRawValue("TimeOverThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "CurrDemandSts") {
            return static_cast<uint32_t>(msg.teCurrDemandSts);
        }
        else if (mnem == "ActSts") {
            return static_cast<uint32_t>(msg.teActSts);
        }
        else if (mnem == "CritType") {
            return static_cast<uint32_t>(msg.teCritType);
        }
        else if (mnem == "DcInst") {
            return static_cast<uint32_t>(msg.ucDcInst);
        }
        else if (mnem == "DcIThresh") {
            return static_cast<uint32_t>(msg.uiDcIThresh);
        }
        else if (mnem == "TimeOverThresh") {
            return static_cast<uint32_t>(msg.ucTimeOverThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "CurrDemandSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teCurrDemandSts = static_cast<decltype(msg.teCurrDemandSts)>(enumValue);
     else msg.teCurrDemandSts = static_cast<decltype(msg.teCurrDemandSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ActSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teActSts = static_cast<decltype(msg.teActSts)>(enumValue);
     else msg.teActSts = static_cast<decltype(msg.teActSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CritType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9422], value);
     if (enumValue != -1) msg.teCritType = static_cast<decltype(msg.teCritType)>(enumValue);
     else msg.teCritType = static_cast<decltype(msg.teCritType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcInst") {
     msg.ucDcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcIThresh") {
     msg.uiDcIThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "TimeOverThresh") {
     msg.ucTimeOverThresh = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "CurrDemandSts") {
            return 1.0 * (long double)(msg.teCurrDemandSts + 0.0);
        }
        else if (mnem == "ActSts") {
            return 1.0 * (long double)(msg.teActSts + 0.0);
        }
        else if (mnem == "CritType") {
            return 1.0 * (long double)(msg.teCritType + 0.0);
        }
        else if (mnem == "DcInst") {
            return 1.0 * (long double)(msg.ucDcInst + 0.0);
        }
        else if (mnem == "DcIThresh") {
            return 0.05000000074505806 * (long double)(msg.uiDcIThresh + -32000.0);
        }
        else if (mnem == "TimeOverThresh") {
            return 1.0 * (long double)(msg.ucTimeOverThresh + 0.0);
        }
        return 0.0;
    }
} AgsCritStsDcI;

// Auto-generated class definition for RVC_tzPGN_AGS_CRIT_STS_XFER_AC_V
typedef struct AgsCritStsXferAcV : public MessageBase {
RVC_tzPGN_AGS_CRIT_STS_XFER_AC_V msg;
AgsCritStsXferAcV () {  memset(&msg, 0xFF, sizeof(msg));  };
AgsCritStsXferAcV (void * pvStruct) {  msg = *(RVC_tzPGN_AGS_CRIT_STS_XFER_AC_V *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "CurrDemandSts") {
            if (ENUMLOOKUP[9075].find(msg.teCurrDemandSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCurrDemandSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teCurrDemandSts];
              }
        }
        else if (mnem == "ActSts") {
            if (ENUMLOOKUP[9075].find(msg.teActSts) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teActSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teActSts];
              }
        }
        else if (mnem == "CritType") {
            if (ENUMLOOKUP[9422].find(msg.teCritType) == ENUMLOOKUP[9422].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCritType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9422][msg.teCritType];
              }
        }
        else if (mnem == "AcInst") {
            return (msg.ucAcInst == 0xff) ? "No Data" : (msg.ucAcInst == 0xfe) ? "Out of range" : (msg.ucAcInst == 0xfd) ? "Reserved" : std::to_string(msg.ucAcInst);
        }
        else if (mnem == "AcVThresh") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiAcVThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiAcVThresh == 0xffff) ? "No Data" : (msg.uiAcVThresh == 0xfffe) ? "Out of range" : (msg.uiAcVThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeUnderThresh") {
            return (msg.ucTimeUnderThresh == 0xff) ? "No Data" : (msg.ucTimeUnderThresh == 0xfe) ? "Out of range" : (msg.ucTimeUnderThresh == 0xfd) ? "Reserved" : std::to_string(msg.ucTimeUnderThresh);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: AgsCritStsXferAcV" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "CurrDemandSts      : " << fnGetValue("CurrDemandSts") << " (" << fnGetRawValue("CurrDemandSts") << ")" << endl;
        cout << "ActSts      : " << fnGetValue("ActSts") << " (" << fnGetRawValue("ActSts") << ")" << endl;
        cout << "CritType      : " << fnGetValue("CritType") << " (" << fnGetRawValue("CritType") << ")" << endl;
        cout << "AcInst      : " << fnGetValue("AcInst") << " (" << fnGetRawValue("AcInst") << ")" << endl;
        cout << "AcVThresh      : " << fnGetValue("AcVThresh") << " (" << fnGetRawValue("AcVThresh") << ")" << endl;
        cout << "TimeUnderThresh      : " << fnGetValue("TimeUnderThresh") << " (" << fnGetRawValue("TimeUnderThresh") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "CurrDemandSts") {
            return static_cast<uint32_t>(msg.teCurrDemandSts);
        }
        else if (mnem == "ActSts") {
            return static_cast<uint32_t>(msg.teActSts);
        }
        else if (mnem == "CritType") {
            return static_cast<uint32_t>(msg.teCritType);
        }
        else if (mnem == "AcInst") {
            return static_cast<uint32_t>(msg.ucAcInst);
        }
        else if (mnem == "AcVThresh") {
            return static_cast<uint32_t>(msg.uiAcVThresh);
        }
        else if (mnem == "TimeUnderThresh") {
            return static_cast<uint32_t>(msg.ucTimeUnderThresh);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "CurrDemandSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teCurrDemandSts = static_cast<decltype(msg.teCurrDemandSts)>(enumValue);
     else msg.teCurrDemandSts = static_cast<decltype(msg.teCurrDemandSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ActSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teActSts = static_cast<decltype(msg.teActSts)>(enumValue);
     else msg.teActSts = static_cast<decltype(msg.teActSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CritType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9422], value);
     if (enumValue != -1) msg.teCritType = static_cast<decltype(msg.teCritType)>(enumValue);
     else msg.teCritType = static_cast<decltype(msg.teCritType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AcInst") {
     msg.ucAcInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "AcVThresh") {
     msg.uiAcVThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "TimeUnderThresh") {
     msg.ucTimeUnderThresh = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "CurrDemandSts") {
            return 1.0 * (long double)(msg.teCurrDemandSts + 0.0);
        }
        else if (mnem == "ActSts") {
            return 1.0 * (long double)(msg.teActSts + 0.0);
        }
        else if (mnem == "CritType") {
            return 1.0 * (long double)(msg.teCritType + 0.0);
        }
        else if (mnem == "AcInst") {
            return 1.0 * (long double)(msg.ucAcInst + 0.0);
        }
        else if (mnem == "AcVThresh") {
            return 0.05000000074505806 * (long double)(msg.uiAcVThresh + 0.0);
        }
        else if (mnem == "TimeUnderThresh") {
            return 1.0 * (long double)(msg.ucTimeUnderThresh + 0.0);
        }
        return 0.0;
    }
} AgsCritStsXferAcV;

// Auto-generated class definition for RVC_tzPGN_GEN_DEMAND_CMD
typedef struct GenDemandCmd : public MessageBase {
RVC_tzPGN_GEN_DEMAND_CMD msg;
GenDemandCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
GenDemandCmd (void * pvStruct) {  msg = *(RVC_tzPGN_GEN_DEMAND_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "GenDemand") {
            if (ENUMLOOKUP[9075].find(msg.teGenDemand) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teGenDemand);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teGenDemand];
              }
        }
        else if (mnem == "QuietTimeOverride") {
            if (ENUMLOOKUP[9075].find(msg.teQuietTimeOverride) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teQuietTimeOverride);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teQuietTimeOverride];
              }
        }
        else if (mnem == "ExtActRst") {
            if (ENUMLOOKUP[9075].find(msg.teExtActRst) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teExtActRst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teExtActRst];
              }
        }
        else if (mnem == "ManOverride") {
            if (ENUMLOOKUP[9075].find(msg.teManOverride) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teManOverride);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teManOverride];
              }
        }
        else if (mnem == "GenLock") {
            if (ENUMLOOKUP[9075].find(msg.teGenLock) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teGenLock);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teGenLock];
              }
        }
        else if (mnem == "SetQuietTimeBeginHr") {
            return (msg.ucSetQuietTimeBeginHr == 0xff) ? "No Data" : (msg.ucSetQuietTimeBeginHr == 0xfe) ? "Out of range" : (msg.ucSetQuietTimeBeginHr == 0xfd) ? "Reserved" : std::to_string(msg.ucSetQuietTimeBeginHr);
        }
        else if (mnem == "SetQuietTimeBeginMin") {
            return (msg.ucSetQuietTimeBeginMin == 0xff) ? "No Data" : (msg.ucSetQuietTimeBeginMin == 0xfe) ? "Out of range" : (msg.ucSetQuietTimeBeginMin == 0xfd) ? "Reserved" : std::to_string(msg.ucSetQuietTimeBeginMin);
        }
        else if (mnem == "SetQuietTimeEndHr") {
            return (msg.ucSetQuietTimeEndHr == 0xff) ? "No Data" : (msg.ucSetQuietTimeEndHr == 0xfe) ? "Out of range" : (msg.ucSetQuietTimeEndHr == 0xfd) ? "Reserved" : std::to_string(msg.ucSetQuietTimeEndHr);
        }
        else if (mnem == "SetQuietTimeEndMin") {
            return (msg.ucSetQuietTimeEndMin == 0xff) ? "No Data" : (msg.ucSetQuietTimeEndMin == 0xfe) ? "Out of range" : (msg.ucSetQuietTimeEndMin == 0xfd) ? "Reserved" : std::to_string(msg.ucSetQuietTimeEndMin);
        }
        else if (mnem == "SetMinCycTime") {
            return (msg.ucSetMinCycTime == 0xff) ? "No Data" : (msg.ucSetMinCycTime == 0xfe) ? "Out of range" : (msg.ucSetMinCycTime == 0xfd) ? "Reserved" : std::to_string(msg.ucSetMinCycTime);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: GenDemandCmd" << std::endl;
        cout << "GenDemand      : " << fnGetValue("GenDemand") << " (" << fnGetRawValue("GenDemand") << ")" << endl;
        cout << "QuietTimeOverride      : " << fnGetValue("QuietTimeOverride") << " (" << fnGetRawValue("QuietTimeOverride") << ")" << endl;
        cout << "ExtActRst      : " << fnGetValue("ExtActRst") << " (" << fnGetRawValue("ExtActRst") << ")" << endl;
        cout << "ManOverride      : " << fnGetValue("ManOverride") << " (" << fnGetRawValue("ManOverride") << ")" << endl;
        cout << "GenLock      : " << fnGetValue("GenLock") << " (" << fnGetRawValue("GenLock") << ")" << endl;
        cout << "SetQuietTimeBeginHr      : " << fnGetValue("SetQuietTimeBeginHr") << " (" << fnGetRawValue("SetQuietTimeBeginHr") << ")" << endl;
        cout << "SetQuietTimeBeginMin      : " << fnGetValue("SetQuietTimeBeginMin") << " (" << fnGetRawValue("SetQuietTimeBeginMin") << ")" << endl;
        cout << "SetQuietTimeEndHr      : " << fnGetValue("SetQuietTimeEndHr") << " (" << fnGetRawValue("SetQuietTimeEndHr") << ")" << endl;
        cout << "SetQuietTimeEndMin      : " << fnGetValue("SetQuietTimeEndMin") << " (" << fnGetRawValue("SetQuietTimeEndMin") << ")" << endl;
        cout << "SetMinCycTime      : " << fnGetValue("SetMinCycTime") << " (" << fnGetRawValue("SetMinCycTime") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "GenDemand") {
            return static_cast<uint32_t>(msg.teGenDemand);
        }
        else if (mnem == "QuietTimeOverride") {
            return static_cast<uint32_t>(msg.teQuietTimeOverride);
        }
        else if (mnem == "ExtActRst") {
            return static_cast<uint32_t>(msg.teExtActRst);
        }
        else if (mnem == "ManOverride") {
            return static_cast<uint32_t>(msg.teManOverride);
        }
        else if (mnem == "GenLock") {
            return static_cast<uint32_t>(msg.teGenLock);
        }
        else if (mnem == "SetQuietTimeBeginHr") {
            return static_cast<uint32_t>(msg.ucSetQuietTimeBeginHr);
        }
        else if (mnem == "SetQuietTimeBeginMin") {
            return static_cast<uint32_t>(msg.ucSetQuietTimeBeginMin);
        }
        else if (mnem == "SetQuietTimeEndHr") {
            return static_cast<uint32_t>(msg.ucSetQuietTimeEndHr);
        }
        else if (mnem == "SetQuietTimeEndMin") {
            return static_cast<uint32_t>(msg.ucSetQuietTimeEndMin);
        }
        else if (mnem == "SetMinCycTime") {
            return static_cast<uint32_t>(msg.ucSetMinCycTime);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "GenDemand") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teGenDemand = static_cast<decltype(msg.teGenDemand)>(enumValue);
     else msg.teGenDemand = static_cast<decltype(msg.teGenDemand)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "QuietTimeOverride") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teQuietTimeOverride = static_cast<decltype(msg.teQuietTimeOverride)>(enumValue);
     else msg.teQuietTimeOverride = static_cast<decltype(msg.teQuietTimeOverride)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ExtActRst") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teExtActRst = static_cast<decltype(msg.teExtActRst)>(enumValue);
     else msg.teExtActRst = static_cast<decltype(msg.teExtActRst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ManOverride") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teManOverride = static_cast<decltype(msg.teManOverride)>(enumValue);
     else msg.teManOverride = static_cast<decltype(msg.teManOverride)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "GenLock") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teGenLock = static_cast<decltype(msg.teGenLock)>(enumValue);
     else msg.teGenLock = static_cast<decltype(msg.teGenLock)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SetQuietTimeBeginHr") {
     msg.ucSetQuietTimeBeginHr = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "SetQuietTimeBeginMin") {
     msg.ucSetQuietTimeBeginMin = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "SetQuietTimeEndHr") {
     msg.ucSetQuietTimeEndHr = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "SetQuietTimeEndMin") {
     msg.ucSetQuietTimeEndMin = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "SetMinCycTime") {
     msg.ucSetMinCycTime = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "GenDemand") {
            return 1.0 * (long double)(msg.teGenDemand + 0.0);
        }
        else if (mnem == "QuietTimeOverride") {
            return 1.0 * (long double)(msg.teQuietTimeOverride + 0.0);
        }
        else if (mnem == "ExtActRst") {
            return 1.0 * (long double)(msg.teExtActRst + 0.0);
        }
        else if (mnem == "ManOverride") {
            return 1.0 * (long double)(msg.teManOverride + 0.0);
        }
        else if (mnem == "GenLock") {
            return 1.0 * (long double)(msg.teGenLock + 0.0);
        }
        else if (mnem == "SetQuietTimeBeginHr") {
            return 1.0 * (long double)(msg.ucSetQuietTimeBeginHr + 0.0);
        }
        else if (mnem == "SetQuietTimeBeginMin") {
            return 1.0 * (long double)(msg.ucSetQuietTimeBeginMin + 0.0);
        }
        else if (mnem == "SetQuietTimeEndHr") {
            return 1.0 * (long double)(msg.ucSetQuietTimeEndHr + 0.0);
        }
        else if (mnem == "SetQuietTimeEndMin") {
            return 1.0 * (long double)(msg.ucSetQuietTimeEndMin + 0.0);
        }
        else if (mnem == "SetMinCycTime") {
            return 1.0 * (long double)(msg.ucSetMinCycTime + 0.0);
        }
        return 0.0;
    }
} GenDemandCmd;

// Auto-generated class definition for RVC_tzPGN_GEN_DEMAND_STS
typedef struct GenDemandSts : public MessageBase {
RVC_tzPGN_GEN_DEMAND_STS msg;
GenDemandSts () {  memset(&msg, 0xFF, sizeof(msg));  };
GenDemandSts (void * pvStruct) {  msg = *(RVC_tzPGN_GEN_DEMAND_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "GenDemand") {
            if (ENUMLOOKUP[9075].find(msg.teGenDemand) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teGenDemand);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teGenDemand];
              }
        }
        else if (mnem == "IntGenDemand") {
            if (ENUMLOOKUP[9075].find(msg.teIntGenDemand) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teIntGenDemand);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teIntGenDemand];
              }
        }
        else if (mnem == "NetGenDemand") {
            if (ENUMLOOKUP[9075].find(msg.teNetGenDemand) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teNetGenDemand);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teNetGenDemand];
              }
        }
        else if (mnem == "ExtActDetect") {
            if (ENUMLOOKUP[9075].find(msg.teExtActDetect) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teExtActDetect);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teExtActDetect];
              }
        }
        else if (mnem == "ManOverrideDetect") {
            if (ENUMLOOKUP[9075].find(msg.teManOverrideDetect) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teManOverrideDetect);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teManOverrideDetect];
              }
        }
        else if (mnem == "QuietTime") {
            if (ENUMLOOKUP[9075].find(msg.teQuietTime) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teQuietTime);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teQuietTime];
              }
        }
        else if (mnem == "QuietTimeOverride") {
            if (ENUMLOOKUP[9075].find(msg.teQuietTimeOverride) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teQuietTimeOverride);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teQuietTimeOverride];
              }
        }
        else if (mnem == "GenLock") {
            if (ENUMLOOKUP[9075].find(msg.teGenLock) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teGenLock);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teGenLock];
              }
        }
        else if (mnem == "QuietTimeBeginHr") {
            return (msg.ucQuietTimeBeginHr == 0xff) ? "No Data" : (msg.ucQuietTimeBeginHr == 0xfe) ? "Out of range" : (msg.ucQuietTimeBeginHr == 0xfd) ? "Reserved" : std::to_string(msg.ucQuietTimeBeginHr);
        }
        else if (mnem == "QuietTimeBeginMin") {
            return (msg.ucQuietTimeBeginMin == 0xff) ? "No Data" : (msg.ucQuietTimeBeginMin == 0xfe) ? "Out of range" : (msg.ucQuietTimeBeginMin == 0xfd) ? "Reserved" : std::to_string(msg.ucQuietTimeBeginMin);
        }
        else if (mnem == "QuietTimeEndHr") {
            return (msg.ucQuietTimeEndHr == 0xff) ? "No Data" : (msg.ucQuietTimeEndHr == 0xfe) ? "Out of range" : (msg.ucQuietTimeEndHr == 0xfd) ? "Reserved" : std::to_string(msg.ucQuietTimeEndHr);
        }
        else if (mnem == "QuietTimeEndMin") {
            return (msg.ucQuietTimeEndMin == 0xff) ? "No Data" : (msg.ucQuietTimeEndMin == 0xfe) ? "Out of range" : (msg.ucQuietTimeEndMin == 0xfd) ? "Reserved" : std::to_string(msg.ucQuietTimeEndMin);
        }
        else if (mnem == "MinCycTime") {
            return (msg.ucMinCycTime == 0xff) ? "No Data" : (msg.ucMinCycTime == 0xfe) ? "Out of range" : (msg.ucMinCycTime == 0xfd) ? "Reserved" : std::to_string(msg.ucMinCycTime);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: GenDemandSts" << std::endl;
        cout << "GenDemand      : " << fnGetValue("GenDemand") << " (" << fnGetRawValue("GenDemand") << ")" << endl;
        cout << "IntGenDemand      : " << fnGetValue("IntGenDemand") << " (" << fnGetRawValue("IntGenDemand") << ")" << endl;
        cout << "NetGenDemand      : " << fnGetValue("NetGenDemand") << " (" << fnGetRawValue("NetGenDemand") << ")" << endl;
        cout << "ExtActDetect      : " << fnGetValue("ExtActDetect") << " (" << fnGetRawValue("ExtActDetect") << ")" << endl;
        cout << "ManOverrideDetect      : " << fnGetValue("ManOverrideDetect") << " (" << fnGetRawValue("ManOverrideDetect") << ")" << endl;
        cout << "QuietTime      : " << fnGetValue("QuietTime") << " (" << fnGetRawValue("QuietTime") << ")" << endl;
        cout << "QuietTimeOverride      : " << fnGetValue("QuietTimeOverride") << " (" << fnGetRawValue("QuietTimeOverride") << ")" << endl;
        cout << "GenLock      : " << fnGetValue("GenLock") << " (" << fnGetRawValue("GenLock") << ")" << endl;
        cout << "QuietTimeBeginHr      : " << fnGetValue("QuietTimeBeginHr") << " (" << fnGetRawValue("QuietTimeBeginHr") << ")" << endl;
        cout << "QuietTimeBeginMin      : " << fnGetValue("QuietTimeBeginMin") << " (" << fnGetRawValue("QuietTimeBeginMin") << ")" << endl;
        cout << "QuietTimeEndHr      : " << fnGetValue("QuietTimeEndHr") << " (" << fnGetRawValue("QuietTimeEndHr") << ")" << endl;
        cout << "QuietTimeEndMin      : " << fnGetValue("QuietTimeEndMin") << " (" << fnGetRawValue("QuietTimeEndMin") << ")" << endl;
        cout << "MinCycTime      : " << fnGetValue("MinCycTime") << " (" << fnGetRawValue("MinCycTime") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "GenDemand") {
            return static_cast<uint32_t>(msg.teGenDemand);
        }
        else if (mnem == "IntGenDemand") {
            return static_cast<uint32_t>(msg.teIntGenDemand);
        }
        else if (mnem == "NetGenDemand") {
            return static_cast<uint32_t>(msg.teNetGenDemand);
        }
        else if (mnem == "ExtActDetect") {
            return static_cast<uint32_t>(msg.teExtActDetect);
        }
        else if (mnem == "ManOverrideDetect") {
            return static_cast<uint32_t>(msg.teManOverrideDetect);
        }
        else if (mnem == "QuietTime") {
            return static_cast<uint32_t>(msg.teQuietTime);
        }
        else if (mnem == "QuietTimeOverride") {
            return static_cast<uint32_t>(msg.teQuietTimeOverride);
        }
        else if (mnem == "GenLock") {
            return static_cast<uint32_t>(msg.teGenLock);
        }
        else if (mnem == "QuietTimeBeginHr") {
            return static_cast<uint32_t>(msg.ucQuietTimeBeginHr);
        }
        else if (mnem == "QuietTimeBeginMin") {
            return static_cast<uint32_t>(msg.ucQuietTimeBeginMin);
        }
        else if (mnem == "QuietTimeEndHr") {
            return static_cast<uint32_t>(msg.ucQuietTimeEndHr);
        }
        else if (mnem == "QuietTimeEndMin") {
            return static_cast<uint32_t>(msg.ucQuietTimeEndMin);
        }
        else if (mnem == "MinCycTime") {
            return static_cast<uint32_t>(msg.ucMinCycTime);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "GenDemand") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teGenDemand = static_cast<decltype(msg.teGenDemand)>(enumValue);
     else msg.teGenDemand = static_cast<decltype(msg.teGenDemand)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "IntGenDemand") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teIntGenDemand = static_cast<decltype(msg.teIntGenDemand)>(enumValue);
     else msg.teIntGenDemand = static_cast<decltype(msg.teIntGenDemand)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "NetGenDemand") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teNetGenDemand = static_cast<decltype(msg.teNetGenDemand)>(enumValue);
     else msg.teNetGenDemand = static_cast<decltype(msg.teNetGenDemand)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ExtActDetect") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teExtActDetect = static_cast<decltype(msg.teExtActDetect)>(enumValue);
     else msg.teExtActDetect = static_cast<decltype(msg.teExtActDetect)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ManOverrideDetect") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teManOverrideDetect = static_cast<decltype(msg.teManOverrideDetect)>(enumValue);
     else msg.teManOverrideDetect = static_cast<decltype(msg.teManOverrideDetect)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "QuietTime") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teQuietTime = static_cast<decltype(msg.teQuietTime)>(enumValue);
     else msg.teQuietTime = static_cast<decltype(msg.teQuietTime)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "QuietTimeOverride") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teQuietTimeOverride = static_cast<decltype(msg.teQuietTimeOverride)>(enumValue);
     else msg.teQuietTimeOverride = static_cast<decltype(msg.teQuietTimeOverride)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "GenLock") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teGenLock = static_cast<decltype(msg.teGenLock)>(enumValue);
     else msg.teGenLock = static_cast<decltype(msg.teGenLock)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "QuietTimeBeginHr") {
     msg.ucQuietTimeBeginHr = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "QuietTimeBeginMin") {
     msg.ucQuietTimeBeginMin = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "QuietTimeEndHr") {
     msg.ucQuietTimeEndHr = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "QuietTimeEndMin") {
     msg.ucQuietTimeEndMin = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "MinCycTime") {
     msg.ucMinCycTime = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "GenDemand") {
            return 1.0 * (long double)(msg.teGenDemand + 0.0);
        }
        else if (mnem == "IntGenDemand") {
            return 1.0 * (long double)(msg.teIntGenDemand + 0.0);
        }
        else if (mnem == "NetGenDemand") {
            return 1.0 * (long double)(msg.teNetGenDemand + 0.0);
        }
        else if (mnem == "ExtActDetect") {
            return 1.0 * (long double)(msg.teExtActDetect + 0.0);
        }
        else if (mnem == "ManOverrideDetect") {
            return 1.0 * (long double)(msg.teManOverrideDetect + 0.0);
        }
        else if (mnem == "QuietTime") {
            return 1.0 * (long double)(msg.teQuietTime + 0.0);
        }
        else if (mnem == "QuietTimeOverride") {
            return 1.0 * (long double)(msg.teQuietTimeOverride + 0.0);
        }
        else if (mnem == "GenLock") {
            return 1.0 * (long double)(msg.teGenLock + 0.0);
        }
        else if (mnem == "QuietTimeBeginHr") {
            return 1.0 * (long double)(msg.ucQuietTimeBeginHr + 0.0);
        }
        else if (mnem == "QuietTimeBeginMin") {
            return 1.0 * (long double)(msg.ucQuietTimeBeginMin + 0.0);
        }
        else if (mnem == "QuietTimeEndHr") {
            return 1.0 * (long double)(msg.ucQuietTimeEndHr + 0.0);
        }
        else if (mnem == "QuietTimeEndMin") {
            return 1.0 * (long double)(msg.ucQuietTimeEndMin + 0.0);
        }
        else if (mnem == "MinCycTime") {
            return 1.0 * (long double)(msg.ucMinCycTime + 0.0);
        }
        return 0.0;
    }
} GenDemandSts;

// Auto-generated class definition for RVC_tzPGN_CHG_STATS_STS
typedef struct ChgStatsSts : public MessageBase {
RVC_tzPGN_CHG_STATS_STS msg;
ChgStatsSts () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgStatsSts (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_STATS_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgStatsSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        return 0.0;
    }
} ChgStatsSts;

// Auto-generated class definition for RVC_tzPGN_CHG_CFG_CMD1
typedef struct ChgCfgCmd1 : public MessageBase {
RVC_tzPGN_CHG_CFG_CMD1 msg;
ChgCfgCmd1 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgCfgCmd1 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_CFG_CMD1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "ChgAlg") {
            if (ENUMLOOKUP[9408].find(msg.teChgAlg) == ENUMLOOKUP[9408].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgAlg);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9408][msg.teChgAlg];
              }
        }
        else if (mnem == "ChgMode") {
            if (ENUMLOOKUP[9409].find(msg.teChgMode) == ENUMLOOKUP[9409].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9409][msg.teChgMode];
              }
        }
        else if (mnem == "BattSensPres") {
            if (ENUMLOOKUP[9075].find(msg.teBattSensPres) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattSensPres);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBattSensPres];
              }
        }
        else if (mnem == "ChgInstLine") {
            if (ENUMLOOKUP[2056474510].find(msg.teChgInstLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgInstLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teChgInstLine];
              }
        }
        else if (mnem == "BattBankSz") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiBattBankSz + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "AH");
            return (msg.uiBattBankSz == 0xffff) ? "No Data" : (msg.uiBattBankSz == 0xfffe) ? "Out of range" : (msg.uiBattBankSz == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "BattType") {
            if (ENUMLOOKUP[9410].find(msg.teBattType) == ENUMLOOKUP[9410].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9410][msg.teBattType];
              }
        }
        else if (mnem == "MaxChgI") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucMaxChgI + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "A");
            return (msg.ucMaxChgI == 0xff) ? "No Data" : (msg.ucMaxChgI == 0xfe) ? "Out of range" : (msg.ucMaxChgI == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgCfgCmd1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "ChgAlg      : " << fnGetValue("ChgAlg") << " (" << fnGetRawValue("ChgAlg") << ")" << endl;
        cout << "ChgMode      : " << fnGetValue("ChgMode") << " (" << fnGetRawValue("ChgMode") << ")" << endl;
        cout << "BattSensPres      : " << fnGetValue("BattSensPres") << " (" << fnGetRawValue("BattSensPres") << ")" << endl;
        cout << "ChgInstLine      : " << fnGetValue("ChgInstLine") << " (" << fnGetRawValue("ChgInstLine") << ")" << endl;
        cout << "BattBankSz      : " << fnGetValue("BattBankSz") << " (" << fnGetRawValue("BattBankSz") << ")" << endl;
        cout << "BattType      : " << fnGetValue("BattType") << " (" << fnGetRawValue("BattType") << ")" << endl;
        cout << "MaxChgI      : " << fnGetValue("MaxChgI") << " (" << fnGetRawValue("MaxChgI") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "ChgAlg") {
            return static_cast<uint32_t>(msg.teChgAlg);
        }
        else if (mnem == "ChgMode") {
            return static_cast<uint32_t>(msg.teChgMode);
        }
        else if (mnem == "BattSensPres") {
            return static_cast<uint32_t>(msg.teBattSensPres);
        }
        else if (mnem == "ChgInstLine") {
            return static_cast<uint32_t>(msg.teChgInstLine);
        }
        else if (mnem == "BattBankSz") {
            return static_cast<uint32_t>(msg.uiBattBankSz);
        }
        else if (mnem == "BattType") {
            return static_cast<uint32_t>(msg.teBattType);
        }
        else if (mnem == "MaxChgI") {
            return static_cast<uint32_t>(msg.ucMaxChgI);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "ChgAlg") {
     int enumValue = findEnumValue(ENUMLOOKUP[9408], value);
     if (enumValue != -1) msg.teChgAlg = static_cast<decltype(msg.teChgAlg)>(enumValue);
     else msg.teChgAlg = static_cast<decltype(msg.teChgAlg)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9409], value);
     if (enumValue != -1) msg.teChgMode = static_cast<decltype(msg.teChgMode)>(enumValue);
     else msg.teChgMode = static_cast<decltype(msg.teChgMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattSensPres") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBattSensPres = static_cast<decltype(msg.teBattSensPres)>(enumValue);
     else msg.teBattSensPres = static_cast<decltype(msg.teBattSensPres)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgInstLine") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teChgInstLine = static_cast<decltype(msg.teChgInstLine)>(enumValue);
     else msg.teChgInstLine = static_cast<decltype(msg.teChgInstLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattBankSz") {
     msg.uiBattBankSz = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "BattType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9410], value);
     if (enumValue != -1) msg.teBattType = static_cast<decltype(msg.teBattType)>(enumValue);
     else msg.teBattType = static_cast<decltype(msg.teBattType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "MaxChgI") {
     msg.ucMaxChgI = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "ChgAlg") {
            return 1.0 * (long double)(msg.teChgAlg + 0.0);
        }
        else if (mnem == "ChgMode") {
            return 1.0 * (long double)(msg.teChgMode + 0.0);
        }
        else if (mnem == "BattSensPres") {
            return 1.0 * (long double)(msg.teBattSensPres + 0.0);
        }
        else if (mnem == "ChgInstLine") {
            return 1.0 * (long double)(msg.teChgInstLine + 0.0);
        }
        else if (mnem == "BattBankSz") {
            return 1.0 * (long double)(msg.uiBattBankSz + 0.0);
        }
        else if (mnem == "BattType") {
            return 1.0 * (long double)(msg.teBattType + 0.0);
        }
        else if (mnem == "MaxChgI") {
            return 1.0 * (long double)(msg.ucMaxChgI + 0.0);
        }
        return 0.0;
    }
} ChgCfgCmd1;

// Auto-generated class definition for RVC_tzPGN_CHG_CMD
typedef struct ChgCmd : public MessageBase {
RVC_tzPGN_CHG_CMD msg;
ChgCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgCmd (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "Sts") {
            if (ENUMLOOKUP[9411].find(msg.teSts) == ENUMLOOKUP[9411].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9411][msg.teSts];
              }
        }
        else if (mnem == "DfltStatePwrUp") {
            if (ENUMLOOKUP[9066].find(msg.teDfltStatePwrUp) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDfltStatePwrUp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teDfltStatePwrUp];
              }
        }
        else if (mnem == "AutoReChgEn") {
            if (ENUMLOOKUP[9066].find(msg.teAutoReChgEn) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAutoReChgEn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teAutoReChgEn];
              }
        }
        else if (mnem == "ForceChg") {
            if (ENUMLOOKUP[1484358105].find(msg.teForceChg) == ENUMLOOKUP[1484358105].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teForceChg);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1484358105][msg.teForceChg];
              }
        }
        else if (mnem == "CtrlVCCCV") {
            return (msg.uiCtrlVCCCV == 0xffff) ? "No Data" : (msg.uiCtrlVCCCV == 0xfffe) ? "Out of range" : (msg.uiCtrlVCCCV == 0xfffd) ? "Reserved" : std::to_string(msg.uiCtrlVCCCV);
        }
        else if (mnem == "CtrlICCCV") {
            return (msg.uiCtrlICCCV == 0xffff) ? "No Data" : (msg.uiCtrlICCCV == 0xfffe) ? "Out of range" : (msg.uiCtrlICCCV == 0xfffd) ? "Reserved" : std::to_string(msg.uiCtrlICCCV);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgCmd" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Sts      : " << fnGetValue("Sts") << " (" << fnGetRawValue("Sts") << ")" << endl;
        cout << "DfltStatePwrUp      : " << fnGetValue("DfltStatePwrUp") << " (" << fnGetRawValue("DfltStatePwrUp") << ")" << endl;
        cout << "AutoReChgEn      : " << fnGetValue("AutoReChgEn") << " (" << fnGetRawValue("AutoReChgEn") << ")" << endl;
        cout << "ForceChg      : " << fnGetValue("ForceChg") << " (" << fnGetRawValue("ForceChg") << ")" << endl;
        cout << "CtrlVCCCV      : " << fnGetValue("CtrlVCCCV") << " (" << fnGetRawValue("CtrlVCCCV") << ")" << endl;
        cout << "CtrlICCCV      : " << fnGetValue("CtrlICCCV") << " (" << fnGetRawValue("CtrlICCCV") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Sts") {
            return static_cast<uint32_t>(msg.teSts);
        }
        else if (mnem == "DfltStatePwrUp") {
            return static_cast<uint32_t>(msg.teDfltStatePwrUp);
        }
        else if (mnem == "AutoReChgEn") {
            return static_cast<uint32_t>(msg.teAutoReChgEn);
        }
        else if (mnem == "ForceChg") {
            return static_cast<uint32_t>(msg.teForceChg);
        }
        else if (mnem == "CtrlVCCCV") {
            return static_cast<uint32_t>(msg.uiCtrlVCCCV);
        }
        else if (mnem == "CtrlICCCV") {
            return static_cast<uint32_t>(msg.uiCtrlICCCV);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Sts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9411], value);
     if (enumValue != -1) msg.teSts = static_cast<decltype(msg.teSts)>(enumValue);
     else msg.teSts = static_cast<decltype(msg.teSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DfltStatePwrUp") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teDfltStatePwrUp = static_cast<decltype(msg.teDfltStatePwrUp)>(enumValue);
     else msg.teDfltStatePwrUp = static_cast<decltype(msg.teDfltStatePwrUp)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AutoReChgEn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teAutoReChgEn = static_cast<decltype(msg.teAutoReChgEn)>(enumValue);
     else msg.teAutoReChgEn = static_cast<decltype(msg.teAutoReChgEn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ForceChg") {
     int enumValue = findEnumValue(ENUMLOOKUP[1484358105], value);
     if (enumValue != -1) msg.teForceChg = static_cast<decltype(msg.teForceChg)>(enumValue);
     else msg.teForceChg = static_cast<decltype(msg.teForceChg)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CtrlVCCCV") {
     msg.uiCtrlVCCCV = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "CtrlICCCV") {
     msg.uiCtrlICCCV = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnChgEn2ChgCmdSts") return fnChgEn2ChgCmdSts(param_value);
        if (func == "fnStartEqlz2ChgCmdSts") return fnStartEqlz2ChgCmdSts(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Sts") {
            return 1.0 * (long double)(msg.teSts + 0.0);
        }
        else if (mnem == "DfltStatePwrUp") {
            return 1.0 * (long double)(msg.teDfltStatePwrUp + 0.0);
        }
        else if (mnem == "AutoReChgEn") {
            return 1.0 * (long double)(msg.teAutoReChgEn + 0.0);
        }
        else if (mnem == "ForceChg") {
            return 1.0 * (long double)(msg.teForceChg + 0.0);
        }
        else if (mnem == "CtrlVCCCV") {
            return 1.0 * (long double)(msg.uiCtrlVCCCV + 0.0);
        }
        else if (mnem == "CtrlICCCV") {
            return 1.0 * (long double)(msg.uiCtrlICCCV + 0.0);
        }
        return 0.0;
    }
} ChgCmd;

// Auto-generated class definition for RVC_tzPGN_CHG_CFG_STS1
typedef struct ChgCfgSts1 : public MessageBase {
RVC_tzPGN_CHG_CFG_STS1 msg;
ChgCfgSts1 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgCfgSts1 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_CFG_STS1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "ChgAlg") {
            if (ENUMLOOKUP[9408].find(msg.teChgAlg) == ENUMLOOKUP[9408].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgAlg);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9408][msg.teChgAlg];
              }
        }
        else if (mnem == "ChgMode") {
            if (ENUMLOOKUP[9409].find(msg.teChgMode) == ENUMLOOKUP[9409].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgMode);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9409][msg.teChgMode];
              }
        }
        else if (mnem == "BattSensPres") {
            if (ENUMLOOKUP[9075].find(msg.teBattSensPres) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattSensPres);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBattSensPres];
              }
        }
        else if (mnem == "ChgInstLine") {
            if (ENUMLOOKUP[2056474510].find(msg.teChgInstLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teChgInstLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teChgInstLine];
              }
        }
        else if (mnem == "BattType") {
            if (ENUMLOOKUP[9410].find(msg.teBattType) == ENUMLOOKUP[9410].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9410][msg.teBattType];
              }
        }
        else if (mnem == "BattBankSz") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiBattBankSz + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "AH");
            return (msg.uiBattBankSz == 0xffff) ? "No Data" : (msg.uiBattBankSz == 0xfffe) ? "Out of range" : (msg.uiBattBankSz == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "MaxChgI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiMaxChgI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiMaxChgI == 0xffff) ? "No Data" : (msg.uiMaxChgI == 0xfffe) ? "Out of range" : (msg.uiMaxChgI == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgCfgSts1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "ChgAlg      : " << fnGetValue("ChgAlg") << " (" << fnGetRawValue("ChgAlg") << ")" << endl;
        cout << "ChgMode      : " << fnGetValue("ChgMode") << " (" << fnGetRawValue("ChgMode") << ")" << endl;
        cout << "BattSensPres      : " << fnGetValue("BattSensPres") << " (" << fnGetRawValue("BattSensPres") << ")" << endl;
        cout << "ChgInstLine      : " << fnGetValue("ChgInstLine") << " (" << fnGetRawValue("ChgInstLine") << ")" << endl;
        cout << "BattType      : " << fnGetValue("BattType") << " (" << fnGetRawValue("BattType") << ")" << endl;
        cout << "BattBankSz      : " << fnGetValue("BattBankSz") << " (" << fnGetRawValue("BattBankSz") << ")" << endl;
        cout << "MaxChgI      : " << fnGetValue("MaxChgI") << " (" << fnGetRawValue("MaxChgI") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "ChgAlg") {
            return static_cast<uint32_t>(msg.teChgAlg);
        }
        else if (mnem == "ChgMode") {
            return static_cast<uint32_t>(msg.teChgMode);
        }
        else if (mnem == "BattSensPres") {
            return static_cast<uint32_t>(msg.teBattSensPres);
        }
        else if (mnem == "ChgInstLine") {
            return static_cast<uint32_t>(msg.teChgInstLine);
        }
        else if (mnem == "BattType") {
            return static_cast<uint32_t>(msg.teBattType);
        }
        else if (mnem == "BattBankSz") {
            return static_cast<uint32_t>(msg.uiBattBankSz);
        }
        else if (mnem == "MaxChgI") {
            return static_cast<uint32_t>(msg.uiMaxChgI);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "ChgAlg") {
     int enumValue = findEnumValue(ENUMLOOKUP[9408], value);
     if (enumValue != -1) msg.teChgAlg = static_cast<decltype(msg.teChgAlg)>(enumValue);
     else msg.teChgAlg = static_cast<decltype(msg.teChgAlg)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgMode") {
     int enumValue = findEnumValue(ENUMLOOKUP[9409], value);
     if (enumValue != -1) msg.teChgMode = static_cast<decltype(msg.teChgMode)>(enumValue);
     else msg.teChgMode = static_cast<decltype(msg.teChgMode)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattSensPres") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBattSensPres = static_cast<decltype(msg.teBattSensPres)>(enumValue);
     else msg.teBattSensPres = static_cast<decltype(msg.teBattSensPres)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ChgInstLine") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teChgInstLine = static_cast<decltype(msg.teChgInstLine)>(enumValue);
     else msg.teChgInstLine = static_cast<decltype(msg.teChgInstLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9410], value);
     if (enumValue != -1) msg.teBattType = static_cast<decltype(msg.teBattType)>(enumValue);
     else msg.teBattType = static_cast<decltype(msg.teBattType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattBankSz") {
     msg.uiBattBankSz = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "MaxChgI") {
     msg.uiMaxChgI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "ChgAlg") {
            return 1.0 * (long double)(msg.teChgAlg + 0.0);
        }
        else if (mnem == "ChgMode") {
            return 1.0 * (long double)(msg.teChgMode + 0.0);
        }
        else if (mnem == "BattSensPres") {
            return 1.0 * (long double)(msg.teBattSensPres + 0.0);
        }
        else if (mnem == "ChgInstLine") {
            return 1.0 * (long double)(msg.teChgInstLine + 0.0);
        }
        else if (mnem == "BattType") {
            return 1.0 * (long double)(msg.teBattType + 0.0);
        }
        else if (mnem == "BattBankSz") {
            return 1.0 * (long double)(msg.uiBattBankSz + 0.0);
        }
        else if (mnem == "MaxChgI") {
            return 0.05000000074505806 * (long double)(msg.uiMaxChgI + -32000.0);
        }
        return 0.0;
    }
} ChgCfgSts1;

// Auto-generated class definition for RVC_tzPGN_CHG_STS
typedef struct ChgSts : public MessageBase {
RVC_tzPGN_CHG_STS msg;
ChgSts () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgSts (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "ChgV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiChgV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiChgV == 0xffff) ? "No Data" : (msg.uiChgV == 0xfffe) ? "Out of range" : (msg.uiChgV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ChgI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiChgI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiChgI == 0xffff) ? "No Data" : (msg.uiChgI == 0xfffe) ? "Out of range" : (msg.uiChgI == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ChgIPerMax") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucChgIPerMax + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucChgIPerMax == 0xff) ? "No Data" : (msg.ucChgIPerMax == 0xfe) ? "Out of range" : (msg.ucChgIPerMax == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "OpState") {
            if (ENUMLOOKUP[9407].find(msg.teOpState) == ENUMLOOKUP[9407].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOpState);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9407][msg.teOpState];
              }
        }
        else if (mnem == "DefltStatePwrUp") {
            if (ENUMLOOKUP[9066].find(msg.teDefltStatePwrUp) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDefltStatePwrUp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teDefltStatePwrUp];
              }
        }
        else if (mnem == "AutoReChgEn") {
            if (ENUMLOOKUP[9066].find(msg.teAutoReChgEn) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAutoReChgEn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teAutoReChgEn];
              }
        }
        else if (mnem == "ForceChg") {
            if (ENUMLOOKUP[1484358105].find(msg.teForceChg) == ENUMLOOKUP[1484358105].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teForceChg);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1484358105][msg.teForceChg];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "ChgV      : " << fnGetValue("ChgV") << " (" << fnGetRawValue("ChgV") << ")" << endl;
        cout << "ChgI      : " << fnGetValue("ChgI") << " (" << fnGetRawValue("ChgI") << ")" << endl;
        cout << "ChgIPerMax      : " << fnGetValue("ChgIPerMax") << " (" << fnGetRawValue("ChgIPerMax") << ")" << endl;
        cout << "OpState      : " << fnGetValue("OpState") << " (" << fnGetRawValue("OpState") << ")" << endl;
        cout << "DefltStatePwrUp      : " << fnGetValue("DefltStatePwrUp") << " (" << fnGetRawValue("DefltStatePwrUp") << ")" << endl;
        cout << "AutoReChgEn      : " << fnGetValue("AutoReChgEn") << " (" << fnGetRawValue("AutoReChgEn") << ")" << endl;
        cout << "ForceChg      : " << fnGetValue("ForceChg") << " (" << fnGetRawValue("ForceChg") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "ChgV") {
            return static_cast<uint32_t>(msg.uiChgV);
        }
        else if (mnem == "ChgI") {
            return static_cast<uint32_t>(msg.uiChgI);
        }
        else if (mnem == "ChgIPerMax") {
            return static_cast<uint32_t>(msg.ucChgIPerMax);
        }
        else if (mnem == "OpState") {
            return static_cast<uint32_t>(msg.teOpState);
        }
        else if (mnem == "DefltStatePwrUp") {
            return static_cast<uint32_t>(msg.teDefltStatePwrUp);
        }
        else if (mnem == "AutoReChgEn") {
            return static_cast<uint32_t>(msg.teAutoReChgEn);
        }
        else if (mnem == "ForceChg") {
            return static_cast<uint32_t>(msg.teForceChg);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "ChgV") {
     msg.uiChgV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "ChgI") {
     msg.uiChgI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "ChgIPerMax") {
     msg.ucChgIPerMax = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "OpState") {
     int enumValue = findEnumValue(ENUMLOOKUP[9407], value);
     if (enumValue != -1) msg.teOpState = static_cast<decltype(msg.teOpState)>(enumValue);
     else msg.teOpState = static_cast<decltype(msg.teOpState)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DefltStatePwrUp") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teDefltStatePwrUp = static_cast<decltype(msg.teDefltStatePwrUp)>(enumValue);
     else msg.teDefltStatePwrUp = static_cast<decltype(msg.teDefltStatePwrUp)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AutoReChgEn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teAutoReChgEn = static_cast<decltype(msg.teAutoReChgEn)>(enumValue);
     else msg.teAutoReChgEn = static_cast<decltype(msg.teAutoReChgEn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "ForceChg") {
     int enumValue = findEnumValue(ENUMLOOKUP[1484358105], value);
     if (enumValue != -1) msg.teForceChg = static_cast<decltype(msg.teForceChg)>(enumValue);
     else msg.teForceChg = static_cast<decltype(msg.teForceChg)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "ChgV") {
            return 0.05000000074505806 * (long double)(msg.uiChgV + 0.0);
        }
        else if (mnem == "ChgI") {
            return 0.05000000074505806 * (long double)(msg.uiChgI + -32000.0);
        }
        else if (mnem == "ChgIPerMax") {
            return 0.5 * (long double)(msg.ucChgIPerMax + 0.0);
        }
        else if (mnem == "OpState") {
            return 1.0 * (long double)(msg.teOpState + 0.0);
        }
        else if (mnem == "DefltStatePwrUp") {
            return 1.0 * (long double)(msg.teDefltStatePwrUp + 0.0);
        }
        else if (mnem == "AutoReChgEn") {
            return 1.0 * (long double)(msg.teAutoReChgEn + 0.0);
        }
        else if (mnem == "ForceChg") {
            return 1.0 * (long double)(msg.teForceChg + 0.0);
        }
        return 0.0;
    }
} ChgSts;

// Auto-generated class definition for RVC_tzPGN_CHG_AC_STS3
typedef struct ChgAcSts3 : public MessageBase {
RVC_tzPGN_CHG_AC_STS3 msg;
ChgAcSts3 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgAcSts3 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_AC_STS3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[2056474510].find(msg.teLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "Waveform") {
            if (ENUMLOOKUP[1484338823].find(msg.teWaveform) == ENUMLOOKUP[1484338823].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teWaveform);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1484338823][msg.teWaveform];
              }
        }
        else if (mnem == "PhsSts") {
            if (ENUMLOOKUP[9421].find(msg.tePhsSts) == ENUMLOOKUP[9421].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.tePhsSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9421][msg.tePhsSts];
              }
        }
        else if (mnem == "RealPwr") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiRealPwr + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "W");
            return (msg.uiRealPwr == 0xffff) ? "No Data" : (msg.uiRealPwr == 0xfffe) ? "Out of range" : (msg.uiRealPwr == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ReactivePwr") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiReactivePwr + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "VAR");
            return (msg.uiReactivePwr == 0xffff) ? "No Data" : (msg.uiReactivePwr == 0xfffe) ? "Out of range" : (msg.uiReactivePwr == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "HarmonicDist") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucHarmonicDist + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucHarmonicDist == 0xff) ? "No Data" : (msg.ucHarmonicDist == 0xfe) ? "Out of range" : (msg.ucHarmonicDist == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "CompLeg") {
            return std::to_string(msg.ucCompLeg);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgAcSts3" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "Waveform      : " << fnGetValue("Waveform") << " (" << fnGetRawValue("Waveform") << ")" << endl;
        cout << "PhsSts      : " << fnGetValue("PhsSts") << " (" << fnGetRawValue("PhsSts") << ")" << endl;
        cout << "RealPwr      : " << fnGetValue("RealPwr") << " (" << fnGetRawValue("RealPwr") << ")" << endl;
        cout << "ReactivePwr      : " << fnGetValue("ReactivePwr") << " (" << fnGetRawValue("ReactivePwr") << ")" << endl;
        cout << "HarmonicDist      : " << fnGetValue("HarmonicDist") << " (" << fnGetRawValue("HarmonicDist") << ")" << endl;
        cout << "CompLeg      : " << fnGetValue("CompLeg") << " (" << fnGetRawValue("CompLeg") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "Waveform") {
            return static_cast<uint32_t>(msg.teWaveform);
        }
        else if (mnem == "PhsSts") {
            return static_cast<uint32_t>(msg.tePhsSts);
        }
        else if (mnem == "RealPwr") {
            return static_cast<uint32_t>(msg.uiRealPwr);
        }
        else if (mnem == "ReactivePwr") {
            return static_cast<uint32_t>(msg.uiReactivePwr);
        }
        else if (mnem == "HarmonicDist") {
            return static_cast<uint32_t>(msg.ucHarmonicDist);
        }
        else if (mnem == "CompLeg") {
            return static_cast<uint32_t>(msg.ucCompLeg);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Waveform") {
     int enumValue = findEnumValue(ENUMLOOKUP[1484338823], value);
     if (enumValue != -1) msg.teWaveform = static_cast<decltype(msg.teWaveform)>(enumValue);
     else msg.teWaveform = static_cast<decltype(msg.teWaveform)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PhsSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9421], value);
     if (enumValue != -1) msg.tePhsSts = static_cast<decltype(msg.tePhsSts)>(enumValue);
     else msg.tePhsSts = static_cast<decltype(msg.tePhsSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RealPwr") {
     msg.uiRealPwr = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "ReactivePwr") {
     msg.uiReactivePwr = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, -32000.0);
        }
        else if (mnem == "HarmonicDist") {
     msg.ucHarmonicDist = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "CompLeg") {
     msg.ucCompLeg = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "Waveform") {
            return 1.0 * (long double)(msg.teWaveform + 0.0);
        }
        else if (mnem == "PhsSts") {
            return 1.0 * (long double)(msg.tePhsSts + 0.0);
        }
        else if (mnem == "RealPwr") {
            return 1.0 * (long double)(msg.uiRealPwr + 0.0);
        }
        else if (mnem == "ReactivePwr") {
            return 1.0 * (long double)(msg.uiReactivePwr + -32000.0);
        }
        else if (mnem == "HarmonicDist") {
            return 0.5 * (long double)(msg.ucHarmonicDist + 0.0);
        }
        else if (mnem == "CompLeg") {
            return 1.0 * (long double)(msg.ucCompLeg + 0.0);
        }
        return 0.0;
    }
} ChgAcSts3;

// Auto-generated class definition for RVC_tzPGN_CHG_AC_STS2
typedef struct ChgAcSts2 : public MessageBase {
RVC_tzPGN_CHG_AC_STS2 msg;
ChgAcSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgAcSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_AC_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[2056474510].find(msg.teLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "PkV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiPkV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiPkV == 0xffff) ? "No Data" : (msg.uiPkV == 0xfffe) ? "Out of range" : (msg.uiPkV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "PkI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiPkI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiPkI == 0xffff) ? "No Data" : (msg.uiPkI == 0xfffe) ? "Out of range" : (msg.uiPkI == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "GndI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiGndI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiGndI == 0xffff) ? "No Data" : (msg.uiGndI == 0xfffe) ? "Out of range" : (msg.uiGndI == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Cap") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucCap + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "A");
            return (msg.ucCap == 0xff) ? "No Data" : (msg.ucCap == 0xfe) ? "Out of range" : (msg.ucCap == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgAcSts2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "PkV      : " << fnGetValue("PkV") << " (" << fnGetRawValue("PkV") << ")" << endl;
        cout << "PkI      : " << fnGetValue("PkI") << " (" << fnGetRawValue("PkI") << ")" << endl;
        cout << "GndI      : " << fnGetValue("GndI") << " (" << fnGetRawValue("GndI") << ")" << endl;
        cout << "Cap      : " << fnGetValue("Cap") << " (" << fnGetRawValue("Cap") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "PkV") {
            return static_cast<uint32_t>(msg.uiPkV);
        }
        else if (mnem == "PkI") {
            return static_cast<uint32_t>(msg.uiPkI);
        }
        else if (mnem == "GndI") {
            return static_cast<uint32_t>(msg.uiGndI);
        }
        else if (mnem == "Cap") {
            return static_cast<uint32_t>(msg.ucCap);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PkV") {
     msg.uiPkV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "PkI") {
     msg.uiPkI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "GndI") {
     msg.uiGndI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "Cap") {
     msg.ucCap = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "PkV") {
            return 0.05000000074505806 * (long double)(msg.uiPkV + 0.0);
        }
        else if (mnem == "PkI") {
            return 0.05000000074505806 * (long double)(msg.uiPkI + -32000.0);
        }
        else if (mnem == "GndI") {
            return 0.05000000074505806 * (long double)(msg.uiGndI + -32000.0);
        }
        else if (mnem == "Cap") {
            return 1.0 * (long double)(msg.ucCap + 0.0);
        }
        return 0.0;
    }
} ChgAcSts2;

// Auto-generated class definition for RVC_tzPGN_CHG_AC_STS1
typedef struct ChgAcSts1 : public MessageBase {
RVC_tzPGN_CHG_AC_STS1 msg;
ChgAcSts1 () {  memset(&msg, 0xFF, sizeof(msg));  };
ChgAcSts1 (void * pvStruct) {  msg = *(RVC_tzPGN_CHG_AC_STS1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[2056474510].find(msg.teLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "RmsV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiRmsV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiRmsV == 0xffff) ? "No Data" : (msg.uiRmsV == 0xfffe) ? "Out of range" : (msg.uiRmsV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "RmsI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiRmsI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiRmsI == 0xffff) ? "No Data" : (msg.uiRmsI == 0xfffe) ? "Out of range" : (msg.uiRmsI == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Freq") {
            char buffer[50];
            auto engval = 0.0078125 * (long double) (msg.uiFreq + 0.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "Hz");
            return (msg.uiFreq == 0xffff) ? "No Data" : (msg.uiFreq == 0xfffe) ? "Out of range" : (msg.uiFreq == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "FltOpnGnd") {
            if (ENUMLOOKUP[9075].find(msg.teFltOpnGnd) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltOpnGnd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltOpnGnd];
              }
        }
        else if (mnem == "FltOpnNeutral") {
            if (ENUMLOOKUP[9075].find(msg.teFltOpnNeutral) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltOpnNeutral);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltOpnNeutral];
              }
        }
        else if (mnem == "FltRevPolarity") {
            if (ENUMLOOKUP[9075].find(msg.teFltRevPolarity) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltRevPolarity);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltRevPolarity];
              }
        }
        else if (mnem == "FltGndFlt") {
            if (ENUMLOOKUP[9075].find(msg.teFltGndFlt) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltGndFlt);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltGndFlt];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: ChgAcSts1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "RmsV      : " << fnGetValue("RmsV") << " (" << fnGetRawValue("RmsV") << ")" << endl;
        cout << "RmsI      : " << fnGetValue("RmsI") << " (" << fnGetRawValue("RmsI") << ")" << endl;
        cout << "Freq      : " << fnGetValue("Freq") << " (" << fnGetRawValue("Freq") << ")" << endl;
        cout << "FltOpnGnd      : " << fnGetValue("FltOpnGnd") << " (" << fnGetRawValue("FltOpnGnd") << ")" << endl;
        cout << "FltOpnNeutral      : " << fnGetValue("FltOpnNeutral") << " (" << fnGetRawValue("FltOpnNeutral") << ")" << endl;
        cout << "FltRevPolarity      : " << fnGetValue("FltRevPolarity") << " (" << fnGetRawValue("FltRevPolarity") << ")" << endl;
        cout << "FltGndFlt      : " << fnGetValue("FltGndFlt") << " (" << fnGetRawValue("FltGndFlt") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "RmsV") {
            return static_cast<uint32_t>(msg.uiRmsV);
        }
        else if (mnem == "RmsI") {
            return static_cast<uint32_t>(msg.uiRmsI);
        }
        else if (mnem == "Freq") {
            return static_cast<uint32_t>(msg.uiFreq);
        }
        else if (mnem == "FltOpnGnd") {
            return static_cast<uint32_t>(msg.teFltOpnGnd);
        }
        else if (mnem == "FltOpnNeutral") {
            return static_cast<uint32_t>(msg.teFltOpnNeutral);
        }
        else if (mnem == "FltRevPolarity") {
            return static_cast<uint32_t>(msg.teFltRevPolarity);
        }
        else if (mnem == "FltGndFlt") {
            return static_cast<uint32_t>(msg.teFltGndFlt);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RmsV") {
     msg.uiRmsV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "RmsI") {
     msg.uiRmsI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "Freq") {
     msg.uiFreq = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.0078125, 0.0);
        }
        else if (mnem == "FltOpnGnd") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltOpnGnd = static_cast<decltype(msg.teFltOpnGnd)>(enumValue);
     else msg.teFltOpnGnd = static_cast<decltype(msg.teFltOpnGnd)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "FltOpnNeutral") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltOpnNeutral = static_cast<decltype(msg.teFltOpnNeutral)>(enumValue);
     else msg.teFltOpnNeutral = static_cast<decltype(msg.teFltOpnNeutral)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "FltRevPolarity") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltRevPolarity = static_cast<decltype(msg.teFltRevPolarity)>(enumValue);
     else msg.teFltRevPolarity = static_cast<decltype(msg.teFltRevPolarity)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "FltGndFlt") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltGndFlt = static_cast<decltype(msg.teFltGndFlt)>(enumValue);
     else msg.teFltGndFlt = static_cast<decltype(msg.teFltGndFlt)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "RmsV") {
            return 0.05000000074505806 * (long double)(msg.uiRmsV + 0.0);
        }
        else if (mnem == "RmsI") {
            return 0.05000000074505806 * (long double)(msg.uiRmsI + -32000.0);
        }
        else if (mnem == "Freq") {
            return 0.0078125 * (long double)(msg.uiFreq + 0.0);
        }
        else if (mnem == "FltOpnGnd") {
            return 1.0 * (long double)(msg.teFltOpnGnd + 0.0);
        }
        else if (mnem == "FltOpnNeutral") {
            return 1.0 * (long double)(msg.teFltOpnNeutral + 0.0);
        }
        else if (mnem == "FltRevPolarity") {
            return 1.0 * (long double)(msg.teFltRevPolarity + 0.0);
        }
        else if (mnem == "FltGndFlt") {
            return 1.0 * (long double)(msg.teFltGndFlt + 0.0);
        }
        return 0.0;
    }
} ChgAcSts1;

// Auto-generated class definition for RVC_tzPGN_INV_OPS_STS
typedef struct InvOpsSts : public MessageBase {
RVC_tzPGN_INV_OPS_STS msg;
InvOpsSts () {  memset(&msg, 0xFF, sizeof(msg));  };
InvOpsSts (void * pvStruct) {  msg = *(RVC_tzPGN_INV_OPS_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "TotalInst") {
            return (msg.ucTotalInst == 0xff) ? "No Data" : (msg.ucTotalInst == 0xfe) ? "Out of range" : (msg.ucTotalInst == 0xfd) ? "Reserved" : std::to_string(msg.ucTotalInst);
        }
        else if (mnem == "Voltage") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiVoltage + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiVoltage == 0xffff) ? "No Data" : (msg.uiVoltage == 0xfffe) ? "Out of range" : (msg.uiVoltage == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Current") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiCurrent + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiCurrent == 0xffff) ? "No Data" : (msg.uiCurrent == 0xfffe) ? "Out of range" : (msg.uiCurrent == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Temp") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucTemp + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucTemp == 0xff) ? "No Data" : (msg.ucTemp == 0xfe) ? "Out of range" : (msg.ucTemp == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvOpsSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "TotalInst      : " << fnGetValue("TotalInst") << " (" << fnGetRawValue("TotalInst") << ")" << endl;
        cout << "Voltage      : " << fnGetValue("Voltage") << " (" << fnGetRawValue("Voltage") << ")" << endl;
        cout << "Current      : " << fnGetValue("Current") << " (" << fnGetRawValue("Current") << ")" << endl;
        cout << "Temp      : " << fnGetValue("Temp") << " (" << fnGetRawValue("Temp") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "TotalInst") {
            return static_cast<uint32_t>(msg.ucTotalInst);
        }
        else if (mnem == "Voltage") {
            return static_cast<uint32_t>(msg.uiVoltage);
        }
        else if (mnem == "Current") {
            return static_cast<uint32_t>(msg.uiCurrent);
        }
        else if (mnem == "Temp") {
            return static_cast<uint32_t>(msg.ucTemp);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "TotalInst") {
     msg.ucTotalInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Voltage") {
     msg.uiVoltage = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "Current") {
     msg.uiCurrent = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "Temp") {
     msg.ucTemp = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "TotalInst") {
            return 1.0 * (long double)(msg.ucTotalInst + 0.0);
        }
        else if (mnem == "Voltage") {
            return 0.05000000074505806 * (long double)(msg.uiVoltage + 0.0);
        }
        else if (mnem == "Current") {
            return 0.05000000074505806 * (long double)(msg.uiCurrent + -32000.0);
        }
        else if (mnem == "Temp") {
            return 1.0 * (long double)(msg.ucTemp + -40.0);
        }
        return 0.0;
    }
} InvOpsSts;

// Auto-generated class definition for RVC_tzPGN_INV_HV_DC_BUS_STS
typedef struct InvHvDcBusSts : public MessageBase {
RVC_tzPGN_INV_HV_DC_BUS_STS msg;
InvHvDcBusSts () {  memset(&msg, 0xFF, sizeof(msg));  };
InvHvDcBusSts (void * pvStruct) {  msg = *(RVC_tzPGN_INV_HV_DC_BUS_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "TotalInst") {
            return (msg.ucTotalInst == 0xff) ? "No Data" : (msg.ucTotalInst == 0xfe) ? "Out of range" : (msg.ucTotalInst == 0xfd) ? "Reserved" : std::to_string(msg.ucTotalInst);
        }
        else if (mnem == "Voltage") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiVoltage + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiVoltage == 0xffff) ? "No Data" : (msg.uiVoltage == 0xfffe) ? "Out of range" : (msg.uiVoltage == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Current") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiCurrent + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiCurrent == 0xffff) ? "No Data" : (msg.uiCurrent == 0xfffe) ? "Out of range" : (msg.uiCurrent == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Temp") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucTemp + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucTemp == 0xff) ? "No Data" : (msg.ucTemp == 0xfe) ? "Out of range" : (msg.ucTemp == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvHvDcBusSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "TotalInst      : " << fnGetValue("TotalInst") << " (" << fnGetRawValue("TotalInst") << ")" << endl;
        cout << "Voltage      : " << fnGetValue("Voltage") << " (" << fnGetRawValue("Voltage") << ")" << endl;
        cout << "Current      : " << fnGetValue("Current") << " (" << fnGetRawValue("Current") << ")" << endl;
        cout << "Temp      : " << fnGetValue("Temp") << " (" << fnGetRawValue("Temp") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "TotalInst") {
            return static_cast<uint32_t>(msg.ucTotalInst);
        }
        else if (mnem == "Voltage") {
            return static_cast<uint32_t>(msg.uiVoltage);
        }
        else if (mnem == "Current") {
            return static_cast<uint32_t>(msg.uiCurrent);
        }
        else if (mnem == "Temp") {
            return static_cast<uint32_t>(msg.ucTemp);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "TotalInst") {
     msg.ucTotalInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Voltage") {
     msg.uiVoltage = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "Current") {
     msg.uiCurrent = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "Temp") {
     msg.ucTemp = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "TotalInst") {
            return 1.0 * (long double)(msg.ucTotalInst + 0.0);
        }
        else if (mnem == "Voltage") {
            return 0.05000000074505806 * (long double)(msg.uiVoltage + 0.0);
        }
        else if (mnem == "Current") {
            return 0.05000000074505806 * (long double)(msg.uiCurrent + -32000.0);
        }
        else if (mnem == "Temp") {
            return 1.0 * (long double)(msg.ucTemp + -40.0);
        }
        return 0.0;
    }
} InvHvDcBusSts;

// Auto-generated class definition for RVC_tzPGN_INV_APS_STS
typedef struct InvApsSts : public MessageBase {
RVC_tzPGN_INV_APS_STS msg;
InvApsSts () {  memset(&msg, 0xFF, sizeof(msg));  };
InvApsSts (void * pvStruct) {  msg = *(RVC_tzPGN_INV_APS_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "TotalInst") {
            return (msg.ucTotalInst == 0xff) ? "No Data" : (msg.ucTotalInst == 0xfe) ? "Out of range" : (msg.ucTotalInst == 0xfd) ? "Reserved" : std::to_string(msg.ucTotalInst);
        }
        else if (mnem == "Voltage") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiVoltage + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiVoltage == 0xffff) ? "No Data" : (msg.uiVoltage == 0xfffe) ? "Out of range" : (msg.uiVoltage == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Current") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiCurrent + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiCurrent == 0xffff) ? "No Data" : (msg.uiCurrent == 0xfffe) ? "Out of range" : (msg.uiCurrent == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Temp") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucTemp + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucTemp == 0xff) ? "No Data" : (msg.ucTemp == 0xfe) ? "Out of range" : (msg.ucTemp == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvApsSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "TotalInst      : " << fnGetValue("TotalInst") << " (" << fnGetRawValue("TotalInst") << ")" << endl;
        cout << "Voltage      : " << fnGetValue("Voltage") << " (" << fnGetRawValue("Voltage") << ")" << endl;
        cout << "Current      : " << fnGetValue("Current") << " (" << fnGetRawValue("Current") << ")" << endl;
        cout << "Temp      : " << fnGetValue("Temp") << " (" << fnGetRawValue("Temp") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "TotalInst") {
            return static_cast<uint32_t>(msg.ucTotalInst);
        }
        else if (mnem == "Voltage") {
            return static_cast<uint32_t>(msg.uiVoltage);
        }
        else if (mnem == "Current") {
            return static_cast<uint32_t>(msg.uiCurrent);
        }
        else if (mnem == "Temp") {
            return static_cast<uint32_t>(msg.ucTemp);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "TotalInst") {
     msg.ucTotalInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Voltage") {
     msg.uiVoltage = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "Current") {
     msg.uiCurrent = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "Temp") {
     msg.ucTemp = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "TotalInst") {
            return 1.0 * (long double)(msg.ucTotalInst + 0.0);
        }
        else if (mnem == "Voltage") {
            return 0.05000000074505806 * (long double)(msg.uiVoltage + 0.0);
        }
        else if (mnem == "Current") {
            return 0.05000000074505806 * (long double)(msg.uiCurrent + -32000.0);
        }
        else if (mnem == "Temp") {
            return 1.0 * (long double)(msg.ucTemp + -40.0);
        }
        return 0.0;
    }
} InvApsSts;

// Auto-generated class definition for RVC_tzPGN_INV_STATS_STS
typedef struct InvStatsSts : public MessageBase {
RVC_tzPGN_INV_STATS_STS msg;
InvStatsSts () {  memset(&msg, 0xFF, sizeof(msg));  };
InvStatsSts (void * pvStruct) {  msg = *(RVC_tzPGN_INV_STATS_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "NumDcUvDetects") {
            return (msg.uiNumDcUvDetects == 0xffff) ? "No Data" : (msg.uiNumDcUvDetects == 0xfffe) ? "Out of range" : (msg.uiNumDcUvDetects == 0xfffd) ? "Reserved" : std::to_string(msg.uiNumDcUvDetects);
        }
        else if (mnem == "NumInvAcOutOvlds") {
            return (msg.uiNumInvAcOutOvlds == 0xffff) ? "No Data" : (msg.uiNumInvAcOutOvlds == 0xfffe) ? "Out of range" : (msg.uiNumInvAcOutOvlds == 0xfffd) ? "Reserved" : std::to_string(msg.uiNumInvAcOutOvlds);
        }
        else if (mnem == "NumLdSensEngage") {
            return (msg.uiNumLdSensEngage == 0xffff) ? "No Data" : (msg.uiNumLdSensEngage == 0xfffe) ? "Out of range" : (msg.uiNumLdSensEngage == 0xfffd) ? "Reserved" : std::to_string(msg.uiNumLdSensEngage);
        }
        else if (mnem == "LowestDcV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiLowestDcV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiLowestDcV == 0xffff) ? "No Data" : (msg.uiLowestDcV == 0xfffe) ? "Out of range" : (msg.uiLowestDcV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "HighestDcV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiHighestDcV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiHighestDcV == 0xffff) ? "No Data" : (msg.uiHighestDcV == 0xfffe) ? "Out of range" : (msg.uiHighestDcV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LowestAcVIn") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiLowestAcVIn + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiLowestAcVIn == 0xffff) ? "No Data" : (msg.uiLowestAcVIn == 0xfffe) ? "Out of range" : (msg.uiLowestAcVIn == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "HighestAcVIn") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiHighestAcVIn + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiHighestAcVIn == 0xffff) ? "No Data" : (msg.uiHighestAcVIn == 0xfffe) ? "Out of range" : (msg.uiHighestAcVIn == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LowestAcVOut") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiLowestAcVOut + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiLowestAcVOut == 0xffff) ? "No Data" : (msg.uiLowestAcVOut == 0xfffe) ? "Out of range" : (msg.uiLowestAcVOut == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "HighestAcVOut") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiHighestAcVOut + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiHighestAcVOut == 0xffff) ? "No Data" : (msg.uiHighestAcVOut == 0xfffe) ? "Out of range" : (msg.uiHighestAcVOut == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvStatsSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "NumDcUvDetects      : " << fnGetValue("NumDcUvDetects") << " (" << fnGetRawValue("NumDcUvDetects") << ")" << endl;
        cout << "NumInvAcOutOvlds      : " << fnGetValue("NumInvAcOutOvlds") << " (" << fnGetRawValue("NumInvAcOutOvlds") << ")" << endl;
        cout << "NumLdSensEngage      : " << fnGetValue("NumLdSensEngage") << " (" << fnGetRawValue("NumLdSensEngage") << ")" << endl;
        cout << "LowestDcV      : " << fnGetValue("LowestDcV") << " (" << fnGetRawValue("LowestDcV") << ")" << endl;
        cout << "HighestDcV      : " << fnGetValue("HighestDcV") << " (" << fnGetRawValue("HighestDcV") << ")" << endl;
        cout << "LowestAcVIn      : " << fnGetValue("LowestAcVIn") << " (" << fnGetRawValue("LowestAcVIn") << ")" << endl;
        cout << "HighestAcVIn      : " << fnGetValue("HighestAcVIn") << " (" << fnGetRawValue("HighestAcVIn") << ")" << endl;
        cout << "LowestAcVOut      : " << fnGetValue("LowestAcVOut") << " (" << fnGetRawValue("LowestAcVOut") << ")" << endl;
        cout << "HighestAcVOut      : " << fnGetValue("HighestAcVOut") << " (" << fnGetRawValue("HighestAcVOut") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "NumDcUvDetects") {
            return static_cast<uint32_t>(msg.uiNumDcUvDetects);
        }
        else if (mnem == "NumInvAcOutOvlds") {
            return static_cast<uint32_t>(msg.uiNumInvAcOutOvlds);
        }
        else if (mnem == "NumLdSensEngage") {
            return static_cast<uint32_t>(msg.uiNumLdSensEngage);
        }
        else if (mnem == "LowestDcV") {
            return static_cast<uint32_t>(msg.uiLowestDcV);
        }
        else if (mnem == "HighestDcV") {
            return static_cast<uint32_t>(msg.uiHighestDcV);
        }
        else if (mnem == "LowestAcVIn") {
            return static_cast<uint32_t>(msg.uiLowestAcVIn);
        }
        else if (mnem == "HighestAcVIn") {
            return static_cast<uint32_t>(msg.uiHighestAcVIn);
        }
        else if (mnem == "LowestAcVOut") {
            return static_cast<uint32_t>(msg.uiLowestAcVOut);
        }
        else if (mnem == "HighestAcVOut") {
            return static_cast<uint32_t>(msg.uiHighestAcVOut);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "NumDcUvDetects") {
     msg.uiNumDcUvDetects = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "NumInvAcOutOvlds") {
     msg.uiNumInvAcOutOvlds = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "NumLdSensEngage") {
     msg.uiNumLdSensEngage = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "LowestDcV") {
     msg.uiLowestDcV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "HighestDcV") {
     msg.uiHighestDcV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "LowestAcVIn") {
     msg.uiLowestAcVIn = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "HighestAcVIn") {
     msg.uiHighestAcVIn = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "LowestAcVOut") {
     msg.uiLowestAcVOut = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "HighestAcVOut") {
     msg.uiHighestAcVOut = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "NumDcUvDetects") {
            return 1.0 * (long double)(msg.uiNumDcUvDetects + 0.0);
        }
        else if (mnem == "NumInvAcOutOvlds") {
            return 1.0 * (long double)(msg.uiNumInvAcOutOvlds + 0.0);
        }
        else if (mnem == "NumLdSensEngage") {
            return 1.0 * (long double)(msg.uiNumLdSensEngage + 0.0);
        }
        else if (mnem == "LowestDcV") {
            return 0.05000000074505806 * (long double)(msg.uiLowestDcV + 0.0);
        }
        else if (mnem == "HighestDcV") {
            return 0.05000000074505806 * (long double)(msg.uiHighestDcV + 0.0);
        }
        else if (mnem == "LowestAcVIn") {
            return 0.05000000074505806 * (long double)(msg.uiLowestAcVIn + 0.0);
        }
        else if (mnem == "HighestAcVIn") {
            return 0.05000000074505806 * (long double)(msg.uiHighestAcVIn + 0.0);
        }
        else if (mnem == "LowestAcVOut") {
            return 0.05000000074505806 * (long double)(msg.uiLowestAcVOut + 0.0);
        }
        else if (mnem == "HighestAcVOut") {
            return 0.05000000074505806 * (long double)(msg.uiHighestAcVOut + 0.0);
        }
        return 0.0;
    }
} InvStatsSts;

// Auto-generated class definition for RVC_tzPGN_INV_CFG_CMD2
typedef struct InvCfgCmd2 : public MessageBase {
RVC_tzPGN_INV_CFG_CMD2 msg;
InvCfgCmd2 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvCfgCmd2 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_CFG_CMD2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "DcSrcSdVMax") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcSrcSdVMax + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcSrcSdVMax == 0xffff) ? "No Data" : (msg.uiDcSrcSdVMax == 0xfffe) ? "Out of range" : (msg.uiDcSrcSdVMax == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DcSrcWrnVMin") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcSrcWrnVMin + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcSrcWrnVMin == 0xffff) ? "No Data" : (msg.uiDcSrcWrnVMin == 0xfffe) ? "Out of range" : (msg.uiDcSrcWrnVMin == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DcSrcWrnVMax") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcSrcWrnVMax + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcSrcWrnVMax == 0xffff) ? "No Data" : (msg.uiDcSrcWrnVMax == 0xfffe) ? "Out of range" : (msg.uiDcSrcWrnVMax == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvCfgCmd2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DcSrcSdVMax      : " << fnGetValue("DcSrcSdVMax") << " (" << fnGetRawValue("DcSrcSdVMax") << ")" << endl;
        cout << "DcSrcWrnVMin      : " << fnGetValue("DcSrcWrnVMin") << " (" << fnGetRawValue("DcSrcWrnVMin") << ")" << endl;
        cout << "DcSrcWrnVMax      : " << fnGetValue("DcSrcWrnVMax") << " (" << fnGetRawValue("DcSrcWrnVMax") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "DcSrcSdVMax") {
            return static_cast<uint32_t>(msg.uiDcSrcSdVMax);
        }
        else if (mnem == "DcSrcWrnVMin") {
            return static_cast<uint32_t>(msg.uiDcSrcWrnVMin);
        }
        else if (mnem == "DcSrcWrnVMax") {
            return static_cast<uint32_t>(msg.uiDcSrcWrnVMax);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcSrcSdVMax") {
     msg.uiDcSrcSdVMax = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "DcSrcWrnVMin") {
     msg.uiDcSrcWrnVMin = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "DcSrcWrnVMax") {
     msg.uiDcSrcWrnVMax = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "DcSrcSdVMax") {
            return 0.05000000074505806 * (long double)(msg.uiDcSrcSdVMax + 0.0);
        }
        else if (mnem == "DcSrcWrnVMin") {
            return 0.05000000074505806 * (long double)(msg.uiDcSrcWrnVMin + 0.0);
        }
        else if (mnem == "DcSrcWrnVMax") {
            return 0.05000000074505806 * (long double)(msg.uiDcSrcWrnVMax + 0.0);
        }
        return 0.0;
    }
} InvCfgCmd2;

// Auto-generated class definition for RVC_tzPGN_INV_CFG_CMD1
typedef struct InvCfgCmd1 : public MessageBase {
RVC_tzPGN_INV_CFG_CMD1 msg;
InvCfgCmd1 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvCfgCmd1 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_CFG_CMD1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "LoadSensePwrThresh") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiLoadSensePwrThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "W");
            return (msg.uiLoadSensePwrThresh == 0xffff) ? "No Data" : (msg.uiLoadSensePwrThresh == 0xfffe) ? "Out of range" : (msg.uiLoadSensePwrThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LoadSenseIntvl") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.uiLoadSenseIntvl + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "s");
            return (msg.uiLoadSenseIntvl == 0xffff) ? "No Data" : (msg.uiLoadSenseIntvl == 0xfffe) ? "Out of range" : (msg.uiLoadSenseIntvl == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DcSrcSdVMin") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcSrcSdVMin + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcSrcSdVMin == 0xffff) ? "No Data" : (msg.uiDcSrcSdVMin == 0xfffe) ? "Out of range" : (msg.uiDcSrcSdVMin == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvCfgCmd1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "LoadSensePwrThresh      : " << fnGetValue("LoadSensePwrThresh") << " (" << fnGetRawValue("LoadSensePwrThresh") << ")" << endl;
        cout << "LoadSenseIntvl      : " << fnGetValue("LoadSenseIntvl") << " (" << fnGetRawValue("LoadSenseIntvl") << ")" << endl;
        cout << "DcSrcSdVMin      : " << fnGetValue("DcSrcSdVMin") << " (" << fnGetRawValue("DcSrcSdVMin") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "LoadSensePwrThresh") {
            return static_cast<uint32_t>(msg.uiLoadSensePwrThresh);
        }
        else if (mnem == "LoadSenseIntvl") {
            return static_cast<uint32_t>(msg.uiLoadSenseIntvl);
        }
        else if (mnem == "DcSrcSdVMin") {
            return static_cast<uint32_t>(msg.uiDcSrcSdVMin);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "LoadSensePwrThresh") {
     msg.uiLoadSensePwrThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "LoadSenseIntvl") {
     msg.uiLoadSenseIntvl = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.5, 0.0);
        }
        else if (mnem == "DcSrcSdVMin") {
     msg.uiDcSrcSdVMin = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "LoadSensePwrThresh") {
            return 1.0 * (long double)(msg.uiLoadSensePwrThresh + 0.0);
        }
        else if (mnem == "LoadSenseIntvl") {
            return 0.5 * (long double)(msg.uiLoadSenseIntvl + 0.0);
        }
        else if (mnem == "DcSrcSdVMin") {
            return 0.05000000074505806 * (long double)(msg.uiDcSrcSdVMin + 0.0);
        }
        return 0.0;
    }
} InvCfgCmd1;

// Auto-generated class definition for RVC_tzPGN_INV_CFG_STS2
typedef struct InvCfgSts2 : public MessageBase {
RVC_tzPGN_INV_CFG_STS2 msg;
InvCfgSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvCfgSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_CFG_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "DcSrcSdVMax") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcSrcSdVMax + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcSrcSdVMax == 0xffff) ? "No Data" : (msg.uiDcSrcSdVMax == 0xfffe) ? "Out of range" : (msg.uiDcSrcSdVMax == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DcSrcWrnVMin") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcSrcWrnVMin + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcSrcWrnVMin == 0xffff) ? "No Data" : (msg.uiDcSrcWrnVMin == 0xfffe) ? "Out of range" : (msg.uiDcSrcWrnVMin == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DcSrcWrnVMax") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcSrcWrnVMax + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcSrcWrnVMax == 0xffff) ? "No Data" : (msg.uiDcSrcWrnVMax == 0xfffe) ? "Out of range" : (msg.uiDcSrcWrnVMax == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvCfgSts2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DcSrcSdVMax      : " << fnGetValue("DcSrcSdVMax") << " (" << fnGetRawValue("DcSrcSdVMax") << ")" << endl;
        cout << "DcSrcWrnVMin      : " << fnGetValue("DcSrcWrnVMin") << " (" << fnGetRawValue("DcSrcWrnVMin") << ")" << endl;
        cout << "DcSrcWrnVMax      : " << fnGetValue("DcSrcWrnVMax") << " (" << fnGetRawValue("DcSrcWrnVMax") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "DcSrcSdVMax") {
            return static_cast<uint32_t>(msg.uiDcSrcSdVMax);
        }
        else if (mnem == "DcSrcWrnVMin") {
            return static_cast<uint32_t>(msg.uiDcSrcWrnVMin);
        }
        else if (mnem == "DcSrcWrnVMax") {
            return static_cast<uint32_t>(msg.uiDcSrcWrnVMax);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "DcSrcSdVMax") {
     msg.uiDcSrcSdVMax = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "DcSrcWrnVMin") {
     msg.uiDcSrcWrnVMin = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "DcSrcWrnVMax") {
     msg.uiDcSrcWrnVMax = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "DcSrcSdVMax") {
            return 0.05000000074505806 * (long double)(msg.uiDcSrcSdVMax + 0.0);
        }
        else if (mnem == "DcSrcWrnVMin") {
            return 0.05000000074505806 * (long double)(msg.uiDcSrcWrnVMin + 0.0);
        }
        else if (mnem == "DcSrcWrnVMax") {
            return 0.05000000074505806 * (long double)(msg.uiDcSrcWrnVMax + 0.0);
        }
        return 0.0;
    }
} InvCfgSts2;

// Auto-generated class definition for RVC_tzPGN_INV_CFG_STS1
typedef struct InvCfgSts1 : public MessageBase {
RVC_tzPGN_INV_CFG_STS1 msg;
InvCfgSts1 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvCfgSts1 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_CFG_STS1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "LoadSensePwrThresh") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiLoadSensePwrThresh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "W");
            return (msg.uiLoadSensePwrThresh == 0xffff) ? "No Data" : (msg.uiLoadSensePwrThresh == 0xfffe) ? "Out of range" : (msg.uiLoadSensePwrThresh == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "LoadSenseIntvl") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.uiLoadSenseIntvl + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "s");
            return (msg.uiLoadSenseIntvl == 0xffff) ? "No Data" : (msg.uiLoadSenseIntvl == 0xfffe) ? "Out of range" : (msg.uiLoadSenseIntvl == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DcSrcSdVMin") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcSrcSdVMin + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcSrcSdVMin == 0xffff) ? "No Data" : (msg.uiDcSrcSdVMin == 0xfffe) ? "Out of range" : (msg.uiDcSrcSdVMin == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "InvEnOnStartUp") {
            if (ENUMLOOKUP[9066].find(msg.teInvEnOnStartUp) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInvEnOnStartUp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teInvEnOnStartUp];
              }
        }
        else if (mnem == "LdSenseEnOnStartUp") {
            if (ENUMLOOKUP[9066].find(msg.teLdSenseEnOnStartUp) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLdSenseEnOnStartUp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teLdSenseEnOnStartUp];
              }
        }
        else if (mnem == "AcPassThruEnOnStartUp") {
            if (ENUMLOOKUP[9066].find(msg.teAcPassThruEnOnStartUp) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAcPassThruEnOnStartUp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teAcPassThruEnOnStartUp];
              }
        }
        else if (mnem == "GenSupportEnOnStartUp") {
            if (ENUMLOOKUP[9066].find(msg.teGenSupportEnOnStartUp) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teGenSupportEnOnStartUp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teGenSupportEnOnStartUp];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvCfgSts1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "LoadSensePwrThresh      : " << fnGetValue("LoadSensePwrThresh") << " (" << fnGetRawValue("LoadSensePwrThresh") << ")" << endl;
        cout << "LoadSenseIntvl      : " << fnGetValue("LoadSenseIntvl") << " (" << fnGetRawValue("LoadSenseIntvl") << ")" << endl;
        cout << "DcSrcSdVMin      : " << fnGetValue("DcSrcSdVMin") << " (" << fnGetRawValue("DcSrcSdVMin") << ")" << endl;
        cout << "InvEnOnStartUp      : " << fnGetValue("InvEnOnStartUp") << " (" << fnGetRawValue("InvEnOnStartUp") << ")" << endl;
        cout << "LdSenseEnOnStartUp      : " << fnGetValue("LdSenseEnOnStartUp") << " (" << fnGetRawValue("LdSenseEnOnStartUp") << ")" << endl;
        cout << "AcPassThruEnOnStartUp      : " << fnGetValue("AcPassThruEnOnStartUp") << " (" << fnGetRawValue("AcPassThruEnOnStartUp") << ")" << endl;
        cout << "GenSupportEnOnStartUp      : " << fnGetValue("GenSupportEnOnStartUp") << " (" << fnGetRawValue("GenSupportEnOnStartUp") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "LoadSensePwrThresh") {
            return static_cast<uint32_t>(msg.uiLoadSensePwrThresh);
        }
        else if (mnem == "LoadSenseIntvl") {
            return static_cast<uint32_t>(msg.uiLoadSenseIntvl);
        }
        else if (mnem == "DcSrcSdVMin") {
            return static_cast<uint32_t>(msg.uiDcSrcSdVMin);
        }
        else if (mnem == "InvEnOnStartUp") {
            return static_cast<uint32_t>(msg.teInvEnOnStartUp);
        }
        else if (mnem == "LdSenseEnOnStartUp") {
            return static_cast<uint32_t>(msg.teLdSenseEnOnStartUp);
        }
        else if (mnem == "AcPassThruEnOnStartUp") {
            return static_cast<uint32_t>(msg.teAcPassThruEnOnStartUp);
        }
        else if (mnem == "GenSupportEnOnStartUp") {
            return static_cast<uint32_t>(msg.teGenSupportEnOnStartUp);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "LoadSensePwrThresh") {
     msg.uiLoadSensePwrThresh = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "LoadSenseIntvl") {
     msg.uiLoadSenseIntvl = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.5, 0.0);
        }
        else if (mnem == "DcSrcSdVMin") {
     msg.uiDcSrcSdVMin = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "InvEnOnStartUp") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teInvEnOnStartUp = static_cast<decltype(msg.teInvEnOnStartUp)>(enumValue);
     else msg.teInvEnOnStartUp = static_cast<decltype(msg.teInvEnOnStartUp)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LdSenseEnOnStartUp") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teLdSenseEnOnStartUp = static_cast<decltype(msg.teLdSenseEnOnStartUp)>(enumValue);
     else msg.teLdSenseEnOnStartUp = static_cast<decltype(msg.teLdSenseEnOnStartUp)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AcPassThruEnOnStartUp") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teAcPassThruEnOnStartUp = static_cast<decltype(msg.teAcPassThruEnOnStartUp)>(enumValue);
     else msg.teAcPassThruEnOnStartUp = static_cast<decltype(msg.teAcPassThruEnOnStartUp)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "GenSupportEnOnStartUp") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teGenSupportEnOnStartUp = static_cast<decltype(msg.teGenSupportEnOnStartUp)>(enumValue);
     else msg.teGenSupportEnOnStartUp = static_cast<decltype(msg.teGenSupportEnOnStartUp)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "LoadSensePwrThresh") {
            return 1.0 * (long double)(msg.uiLoadSensePwrThresh + 0.0);
        }
        else if (mnem == "LoadSenseIntvl") {
            return 0.5 * (long double)(msg.uiLoadSenseIntvl + 0.0);
        }
        else if (mnem == "DcSrcSdVMin") {
            return 0.05000000074505806 * (long double)(msg.uiDcSrcSdVMin + 0.0);
        }
        else if (mnem == "InvEnOnStartUp") {
            return 1.0 * (long double)(msg.teInvEnOnStartUp + 0.0);
        }
        else if (mnem == "LdSenseEnOnStartUp") {
            return 1.0 * (long double)(msg.teLdSenseEnOnStartUp + 0.0);
        }
        else if (mnem == "AcPassThruEnOnStartUp") {
            return 1.0 * (long double)(msg.teAcPassThruEnOnStartUp + 0.0);
        }
        else if (mnem == "GenSupportEnOnStartUp") {
            return 1.0 * (long double)(msg.teGenSupportEnOnStartUp + 0.0);
        }
        return 0.0;
    }
} InvCfgSts1;

// Auto-generated class definition for RVC_tzPGN_INV_CMD
typedef struct InvCmd : public MessageBase {
RVC_tzPGN_INV_CMD msg;
InvCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
InvCmd (void * pvStruct) {  msg = *(RVC_tzPGN_INV_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "InvEn") {
            if (ENUMLOOKUP[9066].find(msg.teInvEn) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInvEn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teInvEn];
              }
        }
        else if (mnem == "LoadSenseEn") {
            if (ENUMLOOKUP[9066].find(msg.teLoadSenseEn) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLoadSenseEn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teLoadSenseEn];
              }
        }
        else if (mnem == "PassThruEn") {
            if (ENUMLOOKUP[9066].find(msg.tePassThruEn) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.tePassThruEn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.tePassThruEn];
              }
        }
        else if (mnem == "GenSupportEn") {
            if (ENUMLOOKUP[9066].find(msg.teGenSupportEn) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teGenSupportEn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teGenSupportEn];
              }
        }
        else if (mnem == "InvEnOnStartUp") {
            if (ENUMLOOKUP[9066].find(msg.teInvEnOnStartUp) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInvEnOnStartUp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teInvEnOnStartUp];
              }
        }
        else if (mnem == "LdSenseEnOnStartUp") {
            if (ENUMLOOKUP[9066].find(msg.teLdSenseEnOnStartUp) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLdSenseEnOnStartUp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teLdSenseEnOnStartUp];
              }
        }
        else if (mnem == "AcPassThruEnOnStartUp") {
            if (ENUMLOOKUP[9066].find(msg.teAcPassThruEnOnStartUp) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teAcPassThruEnOnStartUp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teAcPassThruEnOnStartUp];
              }
        }
        else if (mnem == "GenSupportOnStartUp") {
            if (ENUMLOOKUP[9066].find(msg.teGenSupportOnStartUp) == ENUMLOOKUP[9066].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teGenSupportOnStartUp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9066][msg.teGenSupportOnStartUp];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvCmd" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "InvEn      : " << fnGetValue("InvEn") << " (" << fnGetRawValue("InvEn") << ")" << endl;
        cout << "LoadSenseEn      : " << fnGetValue("LoadSenseEn") << " (" << fnGetRawValue("LoadSenseEn") << ")" << endl;
        cout << "PassThruEn      : " << fnGetValue("PassThruEn") << " (" << fnGetRawValue("PassThruEn") << ")" << endl;
        cout << "GenSupportEn      : " << fnGetValue("GenSupportEn") << " (" << fnGetRawValue("GenSupportEn") << ")" << endl;
        cout << "InvEnOnStartUp      : " << fnGetValue("InvEnOnStartUp") << " (" << fnGetRawValue("InvEnOnStartUp") << ")" << endl;
        cout << "LdSenseEnOnStartUp      : " << fnGetValue("LdSenseEnOnStartUp") << " (" << fnGetRawValue("LdSenseEnOnStartUp") << ")" << endl;
        cout << "AcPassThruEnOnStartUp      : " << fnGetValue("AcPassThruEnOnStartUp") << " (" << fnGetRawValue("AcPassThruEnOnStartUp") << ")" << endl;
        cout << "GenSupportOnStartUp      : " << fnGetValue("GenSupportOnStartUp") << " (" << fnGetRawValue("GenSupportOnStartUp") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "InvEn") {
            return static_cast<uint32_t>(msg.teInvEn);
        }
        else if (mnem == "LoadSenseEn") {
            return static_cast<uint32_t>(msg.teLoadSenseEn);
        }
        else if (mnem == "PassThruEn") {
            return static_cast<uint32_t>(msg.tePassThruEn);
        }
        else if (mnem == "GenSupportEn") {
            return static_cast<uint32_t>(msg.teGenSupportEn);
        }
        else if (mnem == "InvEnOnStartUp") {
            return static_cast<uint32_t>(msg.teInvEnOnStartUp);
        }
        else if (mnem == "LdSenseEnOnStartUp") {
            return static_cast<uint32_t>(msg.teLdSenseEnOnStartUp);
        }
        else if (mnem == "AcPassThruEnOnStartUp") {
            return static_cast<uint32_t>(msg.teAcPassThruEnOnStartUp);
        }
        else if (mnem == "GenSupportOnStartUp") {
            return static_cast<uint32_t>(msg.teGenSupportOnStartUp);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "InvEn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teInvEn = static_cast<decltype(msg.teInvEn)>(enumValue);
     else msg.teInvEn = static_cast<decltype(msg.teInvEn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LoadSenseEn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teLoadSenseEn = static_cast<decltype(msg.teLoadSenseEn)>(enumValue);
     else msg.teLoadSenseEn = static_cast<decltype(msg.teLoadSenseEn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PassThruEn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.tePassThruEn = static_cast<decltype(msg.tePassThruEn)>(enumValue);
     else msg.tePassThruEn = static_cast<decltype(msg.tePassThruEn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "GenSupportEn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teGenSupportEn = static_cast<decltype(msg.teGenSupportEn)>(enumValue);
     else msg.teGenSupportEn = static_cast<decltype(msg.teGenSupportEn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InvEnOnStartUp") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teInvEnOnStartUp = static_cast<decltype(msg.teInvEnOnStartUp)>(enumValue);
     else msg.teInvEnOnStartUp = static_cast<decltype(msg.teInvEnOnStartUp)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LdSenseEnOnStartUp") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teLdSenseEnOnStartUp = static_cast<decltype(msg.teLdSenseEnOnStartUp)>(enumValue);
     else msg.teLdSenseEnOnStartUp = static_cast<decltype(msg.teLdSenseEnOnStartUp)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "AcPassThruEnOnStartUp") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teAcPassThruEnOnStartUp = static_cast<decltype(msg.teAcPassThruEnOnStartUp)>(enumValue);
     else msg.teAcPassThruEnOnStartUp = static_cast<decltype(msg.teAcPassThruEnOnStartUp)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "GenSupportOnStartUp") {
     int enumValue = findEnumValue(ENUMLOOKUP[9066], value);
     if (enumValue != -1) msg.teGenSupportOnStartUp = static_cast<decltype(msg.teGenSupportOnStartUp)>(enumValue);
     else msg.teGenSupportOnStartUp = static_cast<decltype(msg.teGenSupportOnStartUp)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "InvEn") {
            return 1.0 * (long double)(msg.teInvEn + 0.0);
        }
        else if (mnem == "LoadSenseEn") {
            return 1.0 * (long double)(msg.teLoadSenseEn + 0.0);
        }
        else if (mnem == "PassThruEn") {
            return 1.0 * (long double)(msg.tePassThruEn + 0.0);
        }
        else if (mnem == "GenSupportEn") {
            return 1.0 * (long double)(msg.teGenSupportEn + 0.0);
        }
        else if (mnem == "InvEnOnStartUp") {
            return 1.0 * (long double)(msg.teInvEnOnStartUp + 0.0);
        }
        else if (mnem == "LdSenseEnOnStartUp") {
            return 1.0 * (long double)(msg.teLdSenseEnOnStartUp + 0.0);
        }
        else if (mnem == "AcPassThruEnOnStartUp") {
            return 1.0 * (long double)(msg.teAcPassThruEnOnStartUp + 0.0);
        }
        else if (mnem == "GenSupportOnStartUp") {
            return 1.0 * (long double)(msg.teGenSupportOnStartUp + 0.0);
        }
        return 0.0;
    }
} InvCmd;

// Auto-generated class definition for RVC_tzPGN_INV_STS
typedef struct InvSts : public MessageBase {
RVC_tzPGN_INV_STS msg;
InvSts () {  memset(&msg, 0xFF, sizeof(msg));  };
InvSts (void * pvStruct) {  msg = *(RVC_tzPGN_INV_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return (msg.ucInst == 0xff) ? "No Data" : (msg.ucInst == 0xfe) ? "Out of range" : (msg.ucInst == 0xfd) ? "Reserved" : std::to_string(msg.ucInst);
        }
        else if (mnem == "Sts") {
            if (ENUMLOOKUP[9404].find(msg.teSts) == ENUMLOOKUP[9404].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9404][msg.teSts];
              }
        }
        else if (mnem == "BattTempSensPres") {
            if (ENUMLOOKUP[9075].find(msg.teBattTempSensPres) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teBattTempSensPres);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teBattTempSensPres];
              }
        }
        else if (mnem == "LoadSenseEn") {
            if (ENUMLOOKUP[9075].find(msg.teLoadSenseEn) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLoadSenseEn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teLoadSenseEn];
              }
        }
        else if (mnem == "InverterEn") {
            if (ENUMLOOKUP[9075].find(msg.teInverterEn) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInverterEn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInverterEn];
              }
        }
        else if (mnem == "PassthruEn") {
            if (ENUMLOOKUP[9075].find(msg.tePassthruEn) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.tePassthruEn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.tePassthruEn];
              }
        }
        else if (mnem == "GenSupportEn") {
            if (ENUMLOOKUP[9075].find(msg.teGenSupportEn) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teGenSupportEn);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teGenSupportEn];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvSts" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Sts      : " << fnGetValue("Sts") << " (" << fnGetRawValue("Sts") << ")" << endl;
        cout << "BattTempSensPres      : " << fnGetValue("BattTempSensPres") << " (" << fnGetRawValue("BattTempSensPres") << ")" << endl;
        cout << "LoadSenseEn      : " << fnGetValue("LoadSenseEn") << " (" << fnGetRawValue("LoadSenseEn") << ")" << endl;
        cout << "InverterEn      : " << fnGetValue("InverterEn") << " (" << fnGetRawValue("InverterEn") << ")" << endl;
        cout << "PassthruEn      : " << fnGetValue("PassthruEn") << " (" << fnGetRawValue("PassthruEn") << ")" << endl;
        cout << "GenSupportEn      : " << fnGetValue("GenSupportEn") << " (" << fnGetRawValue("GenSupportEn") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Sts") {
            return static_cast<uint32_t>(msg.teSts);
        }
        else if (mnem == "BattTempSensPres") {
            return static_cast<uint32_t>(msg.teBattTempSensPres);
        }
        else if (mnem == "LoadSenseEn") {
            return static_cast<uint32_t>(msg.teLoadSenseEn);
        }
        else if (mnem == "InverterEn") {
            return static_cast<uint32_t>(msg.teInverterEn);
        }
        else if (mnem == "PassthruEn") {
            return static_cast<uint32_t>(msg.tePassthruEn);
        }
        else if (mnem == "GenSupportEn") {
            return static_cast<uint32_t>(msg.teGenSupportEn);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Sts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9404], value);
     if (enumValue != -1) msg.teSts = static_cast<decltype(msg.teSts)>(enumValue);
     else msg.teSts = static_cast<decltype(msg.teSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "BattTempSensPres") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teBattTempSensPres = static_cast<decltype(msg.teBattTempSensPres)>(enumValue);
     else msg.teBattTempSensPres = static_cast<decltype(msg.teBattTempSensPres)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "LoadSenseEn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teLoadSenseEn = static_cast<decltype(msg.teLoadSenseEn)>(enumValue);
     else msg.teLoadSenseEn = static_cast<decltype(msg.teLoadSenseEn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InverterEn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInverterEn = static_cast<decltype(msg.teInverterEn)>(enumValue);
     else msg.teInverterEn = static_cast<decltype(msg.teInverterEn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PassthruEn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.tePassthruEn = static_cast<decltype(msg.tePassthruEn)>(enumValue);
     else msg.tePassthruEn = static_cast<decltype(msg.tePassthruEn)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "GenSupportEn") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teGenSupportEn = static_cast<decltype(msg.teGenSupportEn)>(enumValue);
     else msg.teGenSupportEn = static_cast<decltype(msg.teGenSupportEn)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
#include "translate_functions.h"

    string fnTranslate(string func, const string param_value="") const override {
        if (func == "fnInvSts2InvEnDis") return fnInvSts2InvEnDis(param_value);
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Sts") {
            return 1.0 * (long double)(msg.teSts + 0.0);
        }
        else if (mnem == "BattTempSensPres") {
            return 1.0 * (long double)(msg.teBattTempSensPres + 0.0);
        }
        else if (mnem == "LoadSenseEn") {
            return 1.0 * (long double)(msg.teLoadSenseEn + 0.0);
        }
        else if (mnem == "InverterEn") {
            return 1.0 * (long double)(msg.teInverterEn + 0.0);
        }
        else if (mnem == "PassthruEn") {
            return 1.0 * (long double)(msg.tePassthruEn + 0.0);
        }
        else if (mnem == "GenSupportEn") {
            return 1.0 * (long double)(msg.teGenSupportEn + 0.0);
        }
        return 0.0;
    }
} InvSts;

// Auto-generated class definition for RVC_tzPGN_INV_AC_STS3
typedef struct InvAcSts3 : public MessageBase {
RVC_tzPGN_INV_AC_STS3 msg;
InvAcSts3 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvAcSts3 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_AC_STS3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[2056474510].find(msg.teLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "Waveform") {
            if (ENUMLOOKUP[1484338823].find(msg.teWaveform) == ENUMLOOKUP[1484338823].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teWaveform);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1484338823][msg.teWaveform];
              }
        }
        else if (mnem == "PhsSts") {
            if (ENUMLOOKUP[9421].find(msg.tePhsSts) == ENUMLOOKUP[9421].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.tePhsSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9421][msg.tePhsSts];
              }
        }
        else if (mnem == "RealPwr") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiRealPwr + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "W");
            return (msg.uiRealPwr == 0xffff) ? "No Data" : (msg.uiRealPwr == 0xfffe) ? "Out of range" : (msg.uiRealPwr == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "ReactivePwr") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiReactivePwr + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "VAR");
            return (msg.uiReactivePwr == 0xffff) ? "No Data" : (msg.uiReactivePwr == 0xfffe) ? "Out of range" : (msg.uiReactivePwr == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "HarmonicDist") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucHarmonicDist + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucHarmonicDist == 0xff) ? "No Data" : (msg.ucHarmonicDist == 0xfe) ? "Out of range" : (msg.ucHarmonicDist == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "CompLeg") {
            return std::to_string(msg.ucCompLeg);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvAcSts3" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "Waveform      : " << fnGetValue("Waveform") << " (" << fnGetRawValue("Waveform") << ")" << endl;
        cout << "PhsSts      : " << fnGetValue("PhsSts") << " (" << fnGetRawValue("PhsSts") << ")" << endl;
        cout << "RealPwr      : " << fnGetValue("RealPwr") << " (" << fnGetRawValue("RealPwr") << ")" << endl;
        cout << "ReactivePwr      : " << fnGetValue("ReactivePwr") << " (" << fnGetRawValue("ReactivePwr") << ")" << endl;
        cout << "HarmonicDist      : " << fnGetValue("HarmonicDist") << " (" << fnGetRawValue("HarmonicDist") << ")" << endl;
        cout << "CompLeg      : " << fnGetValue("CompLeg") << " (" << fnGetRawValue("CompLeg") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "Waveform") {
            return static_cast<uint32_t>(msg.teWaveform);
        }
        else if (mnem == "PhsSts") {
            return static_cast<uint32_t>(msg.tePhsSts);
        }
        else if (mnem == "RealPwr") {
            return static_cast<uint32_t>(msg.uiRealPwr);
        }
        else if (mnem == "ReactivePwr") {
            return static_cast<uint32_t>(msg.uiReactivePwr);
        }
        else if (mnem == "HarmonicDist") {
            return static_cast<uint32_t>(msg.ucHarmonicDist);
        }
        else if (mnem == "CompLeg") {
            return static_cast<uint32_t>(msg.ucCompLeg);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Waveform") {
     int enumValue = findEnumValue(ENUMLOOKUP[1484338823], value);
     if (enumValue != -1) msg.teWaveform = static_cast<decltype(msg.teWaveform)>(enumValue);
     else msg.teWaveform = static_cast<decltype(msg.teWaveform)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PhsSts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9421], value);
     if (enumValue != -1) msg.tePhsSts = static_cast<decltype(msg.tePhsSts)>(enumValue);
     else msg.tePhsSts = static_cast<decltype(msg.tePhsSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RealPwr") {
     msg.uiRealPwr = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "ReactivePwr") {
     msg.uiReactivePwr = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, -32000.0);
        }
        else if (mnem == "HarmonicDist") {
     msg.ucHarmonicDist = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "CompLeg") {
     msg.ucCompLeg = stringToInt(value, 0, 0, 0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "Waveform") {
            return 1.0 * (long double)(msg.teWaveform + 0.0);
        }
        else if (mnem == "PhsSts") {
            return 1.0 * (long double)(msg.tePhsSts + 0.0);
        }
        else if (mnem == "RealPwr") {
            return 1.0 * (long double)(msg.uiRealPwr + 0.0);
        }
        else if (mnem == "ReactivePwr") {
            return 1.0 * (long double)(msg.uiReactivePwr + -32000.0);
        }
        else if (mnem == "HarmonicDist") {
            return 0.5 * (long double)(msg.ucHarmonicDist + 0.0);
        }
        else if (mnem == "CompLeg") {
            return 1.0 * (long double)(msg.ucCompLeg + 0.0);
        }
        return 0.0;
    }
} InvAcSts3;

// Auto-generated class definition for RVC_tzPGN_INV_AC_STS2
typedef struct InvAcSts2 : public MessageBase {
RVC_tzPGN_INV_AC_STS2 msg;
InvAcSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvAcSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_AC_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[2056474510].find(msg.teLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "PkV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiPkV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiPkV == 0xffff) ? "No Data" : (msg.uiPkV == 0xfffe) ? "Out of range" : (msg.uiPkV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "PkI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiPkI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiPkI == 0xffff) ? "No Data" : (msg.uiPkI == 0xfffe) ? "Out of range" : (msg.uiPkI == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "GndI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiGndI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiGndI == 0xffff) ? "No Data" : (msg.uiGndI == 0xfffe) ? "Out of range" : (msg.uiGndI == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Cap") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucCap + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "A");
            return (msg.ucCap == 0xff) ? "No Data" : (msg.ucCap == 0xfe) ? "Out of range" : (msg.ucCap == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvAcSts2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "PkV      : " << fnGetValue("PkV") << " (" << fnGetRawValue("PkV") << ")" << endl;
        cout << "PkI      : " << fnGetValue("PkI") << " (" << fnGetRawValue("PkI") << ")" << endl;
        cout << "GndI      : " << fnGetValue("GndI") << " (" << fnGetRawValue("GndI") << ")" << endl;
        cout << "Cap      : " << fnGetValue("Cap") << " (" << fnGetRawValue("Cap") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "PkV") {
            return static_cast<uint32_t>(msg.uiPkV);
        }
        else if (mnem == "PkI") {
            return static_cast<uint32_t>(msg.uiPkI);
        }
        else if (mnem == "GndI") {
            return static_cast<uint32_t>(msg.uiGndI);
        }
        else if (mnem == "Cap") {
            return static_cast<uint32_t>(msg.ucCap);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "PkV") {
     msg.uiPkV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "PkI") {
     msg.uiPkI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "GndI") {
     msg.uiGndI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "Cap") {
     msg.ucCap = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "PkV") {
            return 0.05000000074505806 * (long double)(msg.uiPkV + 0.0);
        }
        else if (mnem == "PkI") {
            return 0.05000000074505806 * (long double)(msg.uiPkI + -32000.0);
        }
        else if (mnem == "GndI") {
            return 0.05000000074505806 * (long double)(msg.uiGndI + -32000.0);
        }
        else if (mnem == "Cap") {
            return 1.0 * (long double)(msg.ucCap + 0.0);
        }
        return 0.0;
    }
} InvAcSts2;

// Auto-generated class definition for RVC_tzPGN_INV_AC_STS1
typedef struct InvAcSts1 : public MessageBase {
RVC_tzPGN_INV_AC_STS1 msg;
InvAcSts1 () {  memset(&msg, 0xFF, sizeof(msg));  };
InvAcSts1 (void * pvStruct) {  msg = *(RVC_tzPGN_INV_AC_STS1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return std::to_string(msg.ucInst);
        }
        else if (mnem == "Line") {
            if (ENUMLOOKUP[2056474510].find(msg.teLine) == ENUMLOOKUP[2056474510].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teLine);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[2056474510][msg.teLine];
              }
        }
        else if (mnem == "InOut") {
            if (ENUMLOOKUP[9075].find(msg.teInOut) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInOut);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teInOut];
              }
        }
        else if (mnem == "RmsV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiRmsV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiRmsV == 0xffff) ? "No Data" : (msg.uiRmsV == 0xfffe) ? "Out of range" : (msg.uiRmsV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "RmsI") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiRmsI + -32000.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "A");
            return (msg.uiRmsI == 0xffff) ? "No Data" : (msg.uiRmsI == 0xfffe) ? "Out of range" : (msg.uiRmsI == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Freq") {
            char buffer[50];
            auto engval = 0.0078125 * (long double) (msg.uiFreq + 0.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "Hz");
            return (msg.uiFreq == 0xffff) ? "No Data" : (msg.uiFreq == 0xfffe) ? "Out of range" : (msg.uiFreq == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "FltOpnGnd") {
            if (ENUMLOOKUP[9075].find(msg.teFltOpnGnd) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltOpnGnd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltOpnGnd];
              }
        }
        else if (mnem == "FltOpnNeutral") {
            if (ENUMLOOKUP[9075].find(msg.teFltOpnNeutral) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltOpnNeutral);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltOpnNeutral];
              }
        }
        else if (mnem == "FltRevPolarity") {
            if (ENUMLOOKUP[9075].find(msg.teFltRevPolarity) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltRevPolarity);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltRevPolarity];
              }
        }
        else if (mnem == "FltGndFlt") {
            if (ENUMLOOKUP[9075].find(msg.teFltGndFlt) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teFltGndFlt);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teFltGndFlt];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: InvAcSts1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "Line      : " << fnGetValue("Line") << " (" << fnGetRawValue("Line") << ")" << endl;
        cout << "InOut      : " << fnGetValue("InOut") << " (" << fnGetRawValue("InOut") << ")" << endl;
        cout << "RmsV      : " << fnGetValue("RmsV") << " (" << fnGetRawValue("RmsV") << ")" << endl;
        cout << "RmsI      : " << fnGetValue("RmsI") << " (" << fnGetRawValue("RmsI") << ")" << endl;
        cout << "Freq      : " << fnGetValue("Freq") << " (" << fnGetRawValue("Freq") << ")" << endl;
        cout << "FltOpnGnd      : " << fnGetValue("FltOpnGnd") << " (" << fnGetRawValue("FltOpnGnd") << ")" << endl;
        cout << "FltOpnNeutral      : " << fnGetValue("FltOpnNeutral") << " (" << fnGetRawValue("FltOpnNeutral") << ")" << endl;
        cout << "FltRevPolarity      : " << fnGetValue("FltRevPolarity") << " (" << fnGetRawValue("FltRevPolarity") << ")" << endl;
        cout << "FltGndFlt      : " << fnGetValue("FltGndFlt") << " (" << fnGetRawValue("FltGndFlt") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.ucInst);
        }
        else if (mnem == "Line") {
            return static_cast<uint32_t>(msg.teLine);
        }
        else if (mnem == "InOut") {
            return static_cast<uint32_t>(msg.teInOut);
        }
        else if (mnem == "RmsV") {
            return static_cast<uint32_t>(msg.uiRmsV);
        }
        else if (mnem == "RmsI") {
            return static_cast<uint32_t>(msg.uiRmsI);
        }
        else if (mnem == "Freq") {
            return static_cast<uint32_t>(msg.uiFreq);
        }
        else if (mnem == "FltOpnGnd") {
            return static_cast<uint32_t>(msg.teFltOpnGnd);
        }
        else if (mnem == "FltOpnNeutral") {
            return static_cast<uint32_t>(msg.teFltOpnNeutral);
        }
        else if (mnem == "FltRevPolarity") {
            return static_cast<uint32_t>(msg.teFltRevPolarity);
        }
        else if (mnem == "FltGndFlt") {
            return static_cast<uint32_t>(msg.teFltGndFlt);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     msg.ucInst = stringToInt(value, 0, 0, 0);
        }
        else if (mnem == "Line") {
     int enumValue = findEnumValue(ENUMLOOKUP[2056474510], value);
     if (enumValue != -1) msg.teLine = static_cast<decltype(msg.teLine)>(enumValue);
     else msg.teLine = static_cast<decltype(msg.teLine)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "InOut") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teInOut = static_cast<decltype(msg.teInOut)>(enumValue);
     else msg.teInOut = static_cast<decltype(msg.teInOut)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "RmsV") {
     msg.uiRmsV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "RmsI") {
     msg.uiRmsI = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, -32000.0);
        }
        else if (mnem == "Freq") {
     msg.uiFreq = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.0078125, 0.0);
        }
        else if (mnem == "FltOpnGnd") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltOpnGnd = static_cast<decltype(msg.teFltOpnGnd)>(enumValue);
     else msg.teFltOpnGnd = static_cast<decltype(msg.teFltOpnGnd)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "FltOpnNeutral") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltOpnNeutral = static_cast<decltype(msg.teFltOpnNeutral)>(enumValue);
     else msg.teFltOpnNeutral = static_cast<decltype(msg.teFltOpnNeutral)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "FltRevPolarity") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltRevPolarity = static_cast<decltype(msg.teFltRevPolarity)>(enumValue);
     else msg.teFltRevPolarity = static_cast<decltype(msg.teFltRevPolarity)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "FltGndFlt") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teFltGndFlt = static_cast<decltype(msg.teFltGndFlt)>(enumValue);
     else msg.teFltGndFlt = static_cast<decltype(msg.teFltGndFlt)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.ucInst + 0.0);
        }
        else if (mnem == "Line") {
            return 1.0 * (long double)(msg.teLine + 0.0);
        }
        else if (mnem == "InOut") {
            return 1.0 * (long double)(msg.teInOut + 0.0);
        }
        else if (mnem == "RmsV") {
            return 0.05000000074505806 * (long double)(msg.uiRmsV + 0.0);
        }
        else if (mnem == "RmsI") {
            return 0.05000000074505806 * (long double)(msg.uiRmsI + -32000.0);
        }
        else if (mnem == "Freq") {
            return 0.0078125 * (long double)(msg.uiFreq + 0.0);
        }
        else if (mnem == "FltOpnGnd") {
            return 1.0 * (long double)(msg.teFltOpnGnd + 0.0);
        }
        else if (mnem == "FltOpnNeutral") {
            return 1.0 * (long double)(msg.teFltOpnNeutral + 0.0);
        }
        else if (mnem == "FltRevPolarity") {
            return 1.0 * (long double)(msg.teFltRevPolarity + 0.0);
        }
        else if (mnem == "FltGndFlt") {
            return 1.0 * (long double)(msg.teFltGndFlt + 0.0);
        }
        return 0.0;
    }
} InvAcSts1;

// Auto-generated class definition for RVC_tzPGN_GEN_START_CFG_CMD
typedef struct GenStartCfgCmd : public MessageBase {
RVC_tzPGN_GEN_START_CFG_CMD msg;
GenStartCfgCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
GenStartCfgCmd (void * pvStruct) {  msg = *(RVC_tzPGN_GEN_START_CFG_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "GenType") {
            if (ENUMLOOKUP[9417].find(msg.teGenType) == ENUMLOOKUP[9417].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teGenType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9417][msg.teGenType];
              }
        }
        else if (mnem == "GenPrecrankTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucGenPrecrankTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucGenPrecrankTime == 0xff) ? "No Data" : (msg.ucGenPrecrankTime == 0xfe) ? "Out of range" : (msg.ucGenPrecrankTime == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "GenMaxCrankTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucGenMaxCrankTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucGenMaxCrankTime == 0xff) ? "No Data" : (msg.ucGenMaxCrankTime == 0xfe) ? "Out of range" : (msg.ucGenMaxCrankTime == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "GenStopTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucGenStopTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucGenStopTime == 0xff) ? "No Data" : (msg.ucGenStopTime == 0xfe) ? "Out of range" : (msg.ucGenStopTime == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: GenStartCfgCmd" << std::endl;
        cout << "GenType      : " << fnGetValue("GenType") << " (" << fnGetRawValue("GenType") << ")" << endl;
        cout << "GenPrecrankTime      : " << fnGetValue("GenPrecrankTime") << " (" << fnGetRawValue("GenPrecrankTime") << ")" << endl;
        cout << "GenMaxCrankTime      : " << fnGetValue("GenMaxCrankTime") << " (" << fnGetRawValue("GenMaxCrankTime") << ")" << endl;
        cout << "GenStopTime      : " << fnGetValue("GenStopTime") << " (" << fnGetRawValue("GenStopTime") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "GenType") {
            return static_cast<uint32_t>(msg.teGenType);
        }
        else if (mnem == "GenPrecrankTime") {
            return static_cast<uint32_t>(msg.ucGenPrecrankTime);
        }
        else if (mnem == "GenMaxCrankTime") {
            return static_cast<uint32_t>(msg.ucGenMaxCrankTime);
        }
        else if (mnem == "GenStopTime") {
            return static_cast<uint32_t>(msg.ucGenStopTime);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "GenType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9417], value);
     if (enumValue != -1) msg.teGenType = static_cast<decltype(msg.teGenType)>(enumValue);
     else msg.teGenType = static_cast<decltype(msg.teGenType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "GenPrecrankTime") {
     msg.ucGenPrecrankTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "GenMaxCrankTime") {
     msg.ucGenMaxCrankTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "GenStopTime") {
     msg.ucGenStopTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "GenType") {
            return 1.0 * (long double)(msg.teGenType + 0.0);
        }
        else if (mnem == "GenPrecrankTime") {
            return 1.0 * (long double)(msg.ucGenPrecrankTime + 0.0);
        }
        else if (mnem == "GenMaxCrankTime") {
            return 1.0 * (long double)(msg.ucGenMaxCrankTime + 0.0);
        }
        else if (mnem == "GenStopTime") {
            return 1.0 * (long double)(msg.ucGenStopTime + 0.0);
        }
        return 0.0;
    }
} GenStartCfgCmd;

// Auto-generated class definition for RVC_tzPGN_GEN_START_CFG_STS
typedef struct GenStartCfgSts : public MessageBase {
RVC_tzPGN_GEN_START_CFG_STS msg;
GenStartCfgSts () {  memset(&msg, 0xFF, sizeof(msg));  };
GenStartCfgSts (void * pvStruct) {  msg = *(RVC_tzPGN_GEN_START_CFG_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "GenType") {
            if (ENUMLOOKUP[9417].find(msg.teGenType) == ENUMLOOKUP[9417].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teGenType);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9417][msg.teGenType];
              }
        }
        else if (mnem == "GenPrecrankTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucGenPrecrankTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucGenPrecrankTime == 0xff) ? "No Data" : (msg.ucGenPrecrankTime == 0xfe) ? "Out of range" : (msg.ucGenPrecrankTime == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "GenMaxCrankTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucGenMaxCrankTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucGenMaxCrankTime == 0xff) ? "No Data" : (msg.ucGenMaxCrankTime == 0xfe) ? "Out of range" : (msg.ucGenMaxCrankTime == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "GenStopTime") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucGenStopTime + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "s");
            return (msg.ucGenStopTime == 0xff) ? "No Data" : (msg.ucGenStopTime == 0xfe) ? "Out of range" : (msg.ucGenStopTime == 0xfd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: GenStartCfgSts" << std::endl;
        cout << "GenType      : " << fnGetValue("GenType") << " (" << fnGetRawValue("GenType") << ")" << endl;
        cout << "GenPrecrankTime      : " << fnGetValue("GenPrecrankTime") << " (" << fnGetRawValue("GenPrecrankTime") << ")" << endl;
        cout << "GenMaxCrankTime      : " << fnGetValue("GenMaxCrankTime") << " (" << fnGetRawValue("GenMaxCrankTime") << ")" << endl;
        cout << "GenStopTime      : " << fnGetValue("GenStopTime") << " (" << fnGetRawValue("GenStopTime") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "GenType") {
            return static_cast<uint32_t>(msg.teGenType);
        }
        else if (mnem == "GenPrecrankTime") {
            return static_cast<uint32_t>(msg.ucGenPrecrankTime);
        }
        else if (mnem == "GenMaxCrankTime") {
            return static_cast<uint32_t>(msg.ucGenMaxCrankTime);
        }
        else if (mnem == "GenStopTime") {
            return static_cast<uint32_t>(msg.ucGenStopTime);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "GenType") {
     int enumValue = findEnumValue(ENUMLOOKUP[9417], value);
     if (enumValue != -1) msg.teGenType = static_cast<decltype(msg.teGenType)>(enumValue);
     else msg.teGenType = static_cast<decltype(msg.teGenType)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "GenPrecrankTime") {
     msg.ucGenPrecrankTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "GenMaxCrankTime") {
     msg.ucGenMaxCrankTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
        else if (mnem == "GenStopTime") {
     msg.ucGenStopTime = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "GenType") {
            return 1.0 * (long double)(msg.teGenType + 0.0);
        }
        else if (mnem == "GenPrecrankTime") {
            return 1.0 * (long double)(msg.ucGenPrecrankTime + 0.0);
        }
        else if (mnem == "GenMaxCrankTime") {
            return 1.0 * (long double)(msg.ucGenMaxCrankTime + 0.0);
        }
        else if (mnem == "GenStopTime") {
            return 1.0 * (long double)(msg.ucGenStopTime + 0.0);
        }
        return 0.0;
    }
} GenStartCfgSts;

// Auto-generated class definition for RVC_tzPGN_GEN_CMD
typedef struct GenCmd : public MessageBase {
RVC_tzPGN_GEN_CMD msg;
GenCmd () {  memset(&msg, 0xFF, sizeof(msg));  };
GenCmd (void * pvStruct) {  msg = *(RVC_tzPGN_GEN_CMD *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Cmd") {
            if (ENUMLOOKUP[9415].find(msg.teCmd) == ENUMLOOKUP[9415].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCmd);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9415][msg.teCmd];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: GenCmd" << std::endl;
        cout << "Cmd      : " << fnGetValue("Cmd") << " (" << fnGetRawValue("Cmd") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Cmd") {
            return static_cast<uint32_t>(msg.teCmd);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Cmd") {
     int enumValue = findEnumValue(ENUMLOOKUP[9415], value);
     if (enumValue != -1) msg.teCmd = static_cast<decltype(msg.teCmd)>(enumValue);
     else msg.teCmd = static_cast<decltype(msg.teCmd)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Cmd") {
            return 1.0 * (long double)(msg.teCmd + 0.0);
        }
        return 0.0;
    }
} GenCmd;

// Auto-generated class definition for RVC_tzPGN_GEN_STS2
typedef struct GenSts2 : public MessageBase {
RVC_tzPGN_GEN_STS2 msg;
GenSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
GenSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_GEN_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "TempSdSw") {
            if (ENUMLOOKUP[9075].find(msg.teTempSdSw) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teTempSdSw);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teTempSdSw];
              }
        }
        else if (mnem == "OilPresSdSw") {
            if (ENUMLOOKUP[9075].find(msg.teOilPresSdSw) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOilPresSdSw);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teOilPresSdSw];
              }
        }
        else if (mnem == "OilLvlSw") {
            if (ENUMLOOKUP[9075].find(msg.teOilLvlSw) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teOilLvlSw);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teOilLvlSw];
              }
        }
        else if (mnem == "CautionLight") {
            if (ENUMLOOKUP[9075].find(msg.teCautionLight) == ENUMLOOKUP[9075].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teCautionLight);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9075][msg.teCautionLight];
              }
        }
        else if (mnem == "EngCoolantTemp") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.ucEngCoolantTemp + -40.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "deg C");
            return (msg.ucEngCoolantTemp == 0xff) ? "No Data" : (msg.ucEngCoolantTemp == 0xfe) ? "Out of range" : (msg.ucEngCoolantTemp == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "EngOilPress") {
            char buffer[50];
            auto engval = 4.0 * (long double) (msg.ucEngOilPress + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "kPa");
            return (msg.ucEngOilPress == 0xff) ? "No Data" : (msg.ucEngOilPress == 0xfe) ? "Out of range" : (msg.ucEngOilPress == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "EngRpm") {
            return (msg.uiEngRpm == 0xffff) ? "No Data" : (msg.uiEngRpm == 0xfffe) ? "Out of range" : (msg.uiEngRpm == 0xfffd) ? "Reserved" : std::to_string(msg.uiEngRpm);
        }
        else if (mnem == "FuelRate") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiFuelRate + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "lph");
            return (msg.uiFuelRate == 0xffff) ? "No Data" : (msg.uiFuelRate == 0xfffe) ? "Out of range" : (msg.uiFuelRate == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: GenSts2" << std::endl;
        cout << "TempSdSw      : " << fnGetValue("TempSdSw") << " (" << fnGetRawValue("TempSdSw") << ")" << endl;
        cout << "OilPresSdSw      : " << fnGetValue("OilPresSdSw") << " (" << fnGetRawValue("OilPresSdSw") << ")" << endl;
        cout << "OilLvlSw      : " << fnGetValue("OilLvlSw") << " (" << fnGetRawValue("OilLvlSw") << ")" << endl;
        cout << "CautionLight      : " << fnGetValue("CautionLight") << " (" << fnGetRawValue("CautionLight") << ")" << endl;
        cout << "EngCoolantTemp      : " << fnGetValue("EngCoolantTemp") << " (" << fnGetRawValue("EngCoolantTemp") << ")" << endl;
        cout << "EngOilPress      : " << fnGetValue("EngOilPress") << " (" << fnGetRawValue("EngOilPress") << ")" << endl;
        cout << "EngRpm      : " << fnGetValue("EngRpm") << " (" << fnGetRawValue("EngRpm") << ")" << endl;
        cout << "FuelRate      : " << fnGetValue("FuelRate") << " (" << fnGetRawValue("FuelRate") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "TempSdSw") {
            return static_cast<uint32_t>(msg.teTempSdSw);
        }
        else if (mnem == "OilPresSdSw") {
            return static_cast<uint32_t>(msg.teOilPresSdSw);
        }
        else if (mnem == "OilLvlSw") {
            return static_cast<uint32_t>(msg.teOilLvlSw);
        }
        else if (mnem == "CautionLight") {
            return static_cast<uint32_t>(msg.teCautionLight);
        }
        else if (mnem == "EngCoolantTemp") {
            return static_cast<uint32_t>(msg.ucEngCoolantTemp);
        }
        else if (mnem == "EngOilPress") {
            return static_cast<uint32_t>(msg.ucEngOilPress);
        }
        else if (mnem == "EngRpm") {
            return static_cast<uint32_t>(msg.uiEngRpm);
        }
        else if (mnem == "FuelRate") {
            return static_cast<uint32_t>(msg.uiFuelRate);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "TempSdSw") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teTempSdSw = static_cast<decltype(msg.teTempSdSw)>(enumValue);
     else msg.teTempSdSw = static_cast<decltype(msg.teTempSdSw)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OilPresSdSw") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teOilPresSdSw = static_cast<decltype(msg.teOilPresSdSw)>(enumValue);
     else msg.teOilPresSdSw = static_cast<decltype(msg.teOilPresSdSw)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "OilLvlSw") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teOilLvlSw = static_cast<decltype(msg.teOilLvlSw)>(enumValue);
     else msg.teOilLvlSw = static_cast<decltype(msg.teOilLvlSw)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "CautionLight") {
     int enumValue = findEnumValue(ENUMLOOKUP[9075], value);
     if (enumValue != -1) msg.teCautionLight = static_cast<decltype(msg.teCautionLight)>(enumValue);
     else msg.teCautionLight = static_cast<decltype(msg.teCautionLight)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "EngCoolantTemp") {
     msg.ucEngCoolantTemp = stringToInt(value, 0xff, 0xfe, 0xfd, 1.0, -40.0);
        }
        else if (mnem == "EngOilPress") {
     msg.ucEngOilPress = stringToInt(value, 0xff, 0xfe, 0xfd, 4.0, 0.0);
        }
        else if (mnem == "EngRpm") {
     msg.uiEngRpm = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "FuelRate") {
     msg.uiFuelRate = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "TempSdSw") {
            return 1.0 * (long double)(msg.teTempSdSw + 0.0);
        }
        else if (mnem == "OilPresSdSw") {
            return 1.0 * (long double)(msg.teOilPresSdSw + 0.0);
        }
        else if (mnem == "OilLvlSw") {
            return 1.0 * (long double)(msg.teOilLvlSw + 0.0);
        }
        else if (mnem == "CautionLight") {
            return 1.0 * (long double)(msg.teCautionLight + 0.0);
        }
        else if (mnem == "EngCoolantTemp") {
            return 1.0 * (long double)(msg.ucEngCoolantTemp + -40.0);
        }
        else if (mnem == "EngOilPress") {
            return 4.0 * (long double)(msg.ucEngOilPress + 0.0);
        }
        else if (mnem == "EngRpm") {
            return 1.0 * (long double)(msg.uiEngRpm + 0.0);
        }
        else if (mnem == "FuelRate") {
            return 0.05000000074505806 * (long double)(msg.uiFuelRate + 0.0);
        }
        return 0.0;
    }
} GenSts2;

// Auto-generated class definition for RVC_tzPGN_GEN_STS1
typedef struct GenSts1 : public MessageBase {
RVC_tzPGN_GEN_STS1 msg;
GenSts1 () {  memset(&msg, 0xFF, sizeof(msg));  };
GenSts1 (void * pvStruct) {  msg = *(RVC_tzPGN_GEN_STS1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Sts") {
            if (ENUMLOOKUP[9404].find(msg.teSts) == ENUMLOOKUP[9404].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teSts);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[9404][msg.teSts];
              }
        }
        else if (mnem == "EngRunTime") {
            return (msg.ulEngRunTime == 0xffffffff) ? "No Data" : (msg.ulEngRunTime == 0xfffffffe) ? "Out of range" : (msg.ulEngRunTime == 0xfffffffd) ? "Reserved" : std::to_string(msg.ulEngRunTime);
        }
        else if (mnem == "EngLoad") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucEngLoad + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucEngLoad == 0xff) ? "No Data" : (msg.ucEngLoad == 0xfe) ? "Out of range" : (msg.ucEngLoad == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "StartBattV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiStartBattV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiStartBattV == 0xffff) ? "No Data" : (msg.uiStartBattV == 0xfffe) ? "Out of range" : (msg.uiStartBattV == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: GenSts1" << std::endl;
        cout << "Sts      : " << fnGetValue("Sts") << " (" << fnGetRawValue("Sts") << ")" << endl;
        cout << "EngRunTime      : " << fnGetValue("EngRunTime") << " (" << fnGetRawValue("EngRunTime") << ")" << endl;
        cout << "EngLoad      : " << fnGetValue("EngLoad") << " (" << fnGetRawValue("EngLoad") << ")" << endl;
        cout << "StartBattV      : " << fnGetValue("StartBattV") << " (" << fnGetRawValue("StartBattV") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Sts") {
            return static_cast<uint32_t>(msg.teSts);
        }
        else if (mnem == "EngRunTime") {
            return static_cast<uint32_t>(msg.ulEngRunTime);
        }
        else if (mnem == "EngLoad") {
            return static_cast<uint32_t>(msg.ucEngLoad);
        }
        else if (mnem == "StartBattV") {
            return static_cast<uint32_t>(msg.uiStartBattV);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Sts") {
     int enumValue = findEnumValue(ENUMLOOKUP[9404], value);
     if (enumValue != -1) msg.teSts = static_cast<decltype(msg.teSts)>(enumValue);
     else msg.teSts = static_cast<decltype(msg.teSts)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "EngRunTime") {
     msg.ulEngRunTime = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd);
        }
        else if (mnem == "EngLoad") {
     msg.ucEngLoad = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "StartBattV") {
     msg.uiStartBattV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Sts") {
            return 1.0 * (long double)(msg.teSts + 0.0);
        }
        else if (mnem == "EngRunTime") {
            return 1.0 * (long double)(msg.ulEngRunTime + 0.0);
        }
        else if (mnem == "EngLoad") {
            return 0.5 * (long double)(msg.ucEngLoad + 0.0);
        }
        else if (mnem == "StartBattV") {
            return 0.05000000074505806 * (long double)(msg.uiStartBattV + 0.0);
        }
        return 0.0;
    }
} GenSts1;

// Auto-generated class definition for RVC_tzPGN_COMM_STS3
typedef struct CommSts3 : public MessageBase {
RVC_tzPGN_COMM_STS3 msg;
CommSts3 () {  memset(&msg, 0xFF, sizeof(msg));  };
CommSts3 (void * pvStruct) {  msg = *(RVC_tzPGN_COMM_STS3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "BusOffErrCnt") {
            return (msg.uiBusOffErrCnt == 0xffff) ? "No Data" : (msg.uiBusOffErrCnt == 0xfffe) ? "Out of range" : (msg.uiBusOffErrCnt == 0xfffd) ? "Reserved" : std::to_string(msg.uiBusOffErrCnt);
        }
        else if (mnem == "RxFrameDropCnt") {
            return (msg.uiRxFrameDropCnt == 0xffff) ? "No Data" : (msg.uiRxFrameDropCnt == 0xfffe) ? "Out of range" : (msg.uiRxFrameDropCnt == 0xfffd) ? "Reserved" : std::to_string(msg.uiRxFrameDropCnt);
        }
        else if (mnem == "TxFrameDropCnt") {
            return (msg.uiTxFrameDropCnt == 0xffff) ? "No Data" : (msg.uiTxFrameDropCnt == 0xfffe) ? "Out of range" : (msg.uiTxFrameDropCnt == 0xfffd) ? "Reserved" : std::to_string(msg.uiTxFrameDropCnt);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: CommSts3" << std::endl;
        cout << "BusOffErrCnt      : " << fnGetValue("BusOffErrCnt") << " (" << fnGetRawValue("BusOffErrCnt") << ")" << endl;
        cout << "RxFrameDropCnt      : " << fnGetValue("RxFrameDropCnt") << " (" << fnGetRawValue("RxFrameDropCnt") << ")" << endl;
        cout << "TxFrameDropCnt      : " << fnGetValue("TxFrameDropCnt") << " (" << fnGetRawValue("TxFrameDropCnt") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "BusOffErrCnt") {
            return static_cast<uint32_t>(msg.uiBusOffErrCnt);
        }
        else if (mnem == "RxFrameDropCnt") {
            return static_cast<uint32_t>(msg.uiRxFrameDropCnt);
        }
        else if (mnem == "TxFrameDropCnt") {
            return static_cast<uint32_t>(msg.uiTxFrameDropCnt);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "BusOffErrCnt") {
     msg.uiBusOffErrCnt = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "RxFrameDropCnt") {
     msg.uiRxFrameDropCnt = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "TxFrameDropCnt") {
     msg.uiTxFrameDropCnt = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "BusOffErrCnt") {
            return 1.0 * (long double)(msg.uiBusOffErrCnt + 0.0);
        }
        else if (mnem == "RxFrameDropCnt") {
            return 1.0 * (long double)(msg.uiRxFrameDropCnt + 0.0);
        }
        else if (mnem == "TxFrameDropCnt") {
            return 1.0 * (long double)(msg.uiTxFrameDropCnt + 0.0);
        }
        return 0.0;
    }
} CommSts3;

// Auto-generated class definition for RVC_tzPGN_COMM_STS2
typedef struct CommSts2 : public MessageBase {
RVC_tzPGN_COMM_STS2 msg;
CommSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
CommSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_COMM_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "TxFramesCnt") {
            return (msg.ulTxFramesCnt == 0xffffffff) ? "No Data" : (msg.ulTxFramesCnt == 0xfffffffe) ? "Out of range" : (msg.ulTxFramesCnt == 0xfffffffd) ? "Reserved" : std::to_string(msg.ulTxFramesCnt);
        }
        else if (mnem == "RxFramesCnt") {
            return (msg.ulRxFramesCnt == 0xffffffff) ? "No Data" : (msg.ulRxFramesCnt == 0xfffffffe) ? "Out of range" : (msg.ulRxFramesCnt == 0xfffffffd) ? "Reserved" : std::to_string(msg.ulRxFramesCnt);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: CommSts2" << std::endl;
        cout << "TxFramesCnt      : " << fnGetValue("TxFramesCnt") << " (" << fnGetRawValue("TxFramesCnt") << ")" << endl;
        cout << "RxFramesCnt      : " << fnGetValue("RxFramesCnt") << " (" << fnGetRawValue("RxFramesCnt") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "TxFramesCnt") {
            return static_cast<uint32_t>(msg.ulTxFramesCnt);
        }
        else if (mnem == "RxFramesCnt") {
            return static_cast<uint32_t>(msg.ulRxFramesCnt);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "TxFramesCnt") {
     msg.ulTxFramesCnt = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd);
        }
        else if (mnem == "RxFramesCnt") {
     msg.ulRxFramesCnt = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "TxFramesCnt") {
            return 1.0 * (long double)(msg.ulTxFramesCnt + 0.0);
        }
        else if (mnem == "RxFramesCnt") {
            return 1.0 * (long double)(msg.ulRxFramesCnt + 0.0);
        }
        return 0.0;
    }
} CommSts2;

// Auto-generated class definition for RVC_tzPGN_COMM_STS1
typedef struct CommSts1 : public MessageBase {
RVC_tzPGN_COMM_STS1 msg;
CommSts1 () {  memset(&msg, 0xFF, sizeof(msg));  };
CommSts1 (void * pvStruct) {  msg = *(RVC_tzPGN_COMM_STS1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "TmrCnt") {
            return (msg.ulTmrCnt == 0xffffffff) ? "No Data" : (msg.ulTmrCnt == 0xfffffffe) ? "Out of range" : (msg.ulTmrCnt == 0xfffffffd) ? "Reserved" : std::to_string(msg.ulTmrCnt);
        }
        else if (mnem == "RxErrCnt") {
            return (msg.uiRxErrCnt == 0xffff) ? "No Data" : (msg.uiRxErrCnt == 0xfffe) ? "Out of range" : (msg.uiRxErrCnt == 0xfffd) ? "Reserved" : std::to_string(msg.uiRxErrCnt);
        }
        else if (mnem == "TxErrCnt") {
            return (msg.uiTxErrCnt == 0xffff) ? "No Data" : (msg.uiTxErrCnt == 0xfffe) ? "Out of range" : (msg.uiTxErrCnt == 0xfffd) ? "Reserved" : std::to_string(msg.uiTxErrCnt);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: CommSts1" << std::endl;
        cout << "TmrCnt      : " << fnGetValue("TmrCnt") << " (" << fnGetRawValue("TmrCnt") << ")" << endl;
        cout << "RxErrCnt      : " << fnGetValue("RxErrCnt") << " (" << fnGetRawValue("RxErrCnt") << ")" << endl;
        cout << "TxErrCnt      : " << fnGetValue("TxErrCnt") << " (" << fnGetRawValue("TxErrCnt") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "TmrCnt") {
            return static_cast<uint32_t>(msg.ulTmrCnt);
        }
        else if (mnem == "RxErrCnt") {
            return static_cast<uint32_t>(msg.uiRxErrCnt);
        }
        else if (mnem == "TxErrCnt") {
            return static_cast<uint32_t>(msg.uiTxErrCnt);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "TmrCnt") {
     msg.ulTmrCnt = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd);
        }
        else if (mnem == "RxErrCnt") {
     msg.uiRxErrCnt = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
        else if (mnem == "TxErrCnt") {
     msg.uiTxErrCnt = stringToInt(value, 0xffff, 0xfffe, 0xfffd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "TmrCnt") {
            return 1.0 * (long double)(msg.ulTmrCnt + 0.0);
        }
        else if (mnem == "RxErrCnt") {
            return 1.0 * (long double)(msg.uiRxErrCnt + 0.0);
        }
        else if (mnem == "TxErrCnt") {
            return 1.0 * (long double)(msg.uiTxErrCnt + 0.0);
        }
        return 0.0;
    }
} CommSts1;

// Auto-generated class definition for RVC_tzPGN_DC_SRC_STS3
typedef struct DcSrcSts3 : public MessageBase {
RVC_tzPGN_DC_SRC_STS3 msg;
DcSrcSts3 () {  memset(&msg, 0xFF, sizeof(msg));  };
DcSrcSts3 (void * pvStruct) {  msg = *(RVC_tzPGN_DC_SRC_STS3 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            if (ENUMLOOKUP[421711928].find(msg.teInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teInst];
              }
        }
        else if (mnem == "DevPri") {
            if (ENUMLOOKUP[1486082168].find(msg.teDevPri) == ENUMLOOKUP[1486082168].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDevPri);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1486082168][msg.teDevPri];
              }
        }
        else if (mnem == "Soh") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucSoh + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucSoh == 0xff) ? "No Data" : (msg.ucSoh == 0xfe) ? "Out of range" : (msg.ucSoh == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "CapRemain") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiCapRemain + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "AH");
            return (msg.uiCapRemain == 0xffff) ? "No Data" : (msg.uiCapRemain == 0xfffe) ? "Out of range" : (msg.uiCapRemain == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "RelCap") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucRelCap + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucRelCap == 0xff) ? "No Data" : (msg.ucRelCap == 0xfe) ? "Out of range" : (msg.ucRelCap == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "AcRmsRipple") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiAcRmsRipple + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "mV");
            return (msg.uiAcRmsRipple == 0xffff) ? "No Data" : (msg.uiAcRmsRipple == 0xfffe) ? "Out of range" : (msg.uiAcRmsRipple == 0xfffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: DcSrcSts3" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DevPri      : " << fnGetValue("DevPri") << " (" << fnGetRawValue("DevPri") << ")" << endl;
        cout << "Soh      : " << fnGetValue("Soh") << " (" << fnGetRawValue("Soh") << ")" << endl;
        cout << "CapRemain      : " << fnGetValue("CapRemain") << " (" << fnGetRawValue("CapRemain") << ")" << endl;
        cout << "RelCap      : " << fnGetValue("RelCap") << " (" << fnGetRawValue("RelCap") << ")" << endl;
        cout << "AcRmsRipple      : " << fnGetValue("AcRmsRipple") << " (" << fnGetRawValue("AcRmsRipple") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.teInst);
        }
        else if (mnem == "DevPri") {
            return static_cast<uint32_t>(msg.teDevPri);
        }
        else if (mnem == "Soh") {
            return static_cast<uint32_t>(msg.ucSoh);
        }
        else if (mnem == "CapRemain") {
            return static_cast<uint32_t>(msg.uiCapRemain);
        }
        else if (mnem == "RelCap") {
            return static_cast<uint32_t>(msg.ucRelCap);
        }
        else if (mnem == "AcRmsRipple") {
            return static_cast<uint32_t>(msg.uiAcRmsRipple);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teInst = static_cast<decltype(msg.teInst)>(enumValue);
     else msg.teInst = static_cast<decltype(msg.teInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DevPri") {
     int enumValue = findEnumValue(ENUMLOOKUP[1486082168], value);
     if (enumValue != -1) msg.teDevPri = static_cast<decltype(msg.teDevPri)>(enumValue);
     else msg.teDevPri = static_cast<decltype(msg.teDevPri)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "Soh") {
     msg.ucSoh = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "CapRemain") {
     msg.uiCapRemain = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "RelCap") {
     msg.ucRelCap = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "AcRmsRipple") {
     msg.uiAcRmsRipple = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.teInst + 0.0);
        }
        else if (mnem == "DevPri") {
            return 1.0 * (long double)(msg.teDevPri + 0.0);
        }
        else if (mnem == "Soh") {
            return 0.5 * (long double)(msg.ucSoh + 0.0);
        }
        else if (mnem == "CapRemain") {
            return 1.0 * (long double)(msg.uiCapRemain + 0.0);
        }
        else if (mnem == "RelCap") {
            return 0.5 * (long double)(msg.ucRelCap + 0.0);
        }
        else if (mnem == "AcRmsRipple") {
            return 1.0 * (long double)(msg.uiAcRmsRipple + 0.0);
        }
        return 0.0;
    }
} DcSrcSts3;

// Auto-generated class definition for RVC_tzPGN_DC_SRC_STS2
typedef struct DcSrcSts2 : public MessageBase {
RVC_tzPGN_DC_SRC_STS2 msg;
DcSrcSts2 () {  memset(&msg, 0xFF, sizeof(msg));  };
DcSrcSts2 (void * pvStruct) {  msg = *(RVC_tzPGN_DC_SRC_STS2 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            if (ENUMLOOKUP[421711928].find(msg.teInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teInst];
              }
        }
        else if (mnem == "DevPri") {
            if (ENUMLOOKUP[1486082168].find(msg.teDevPri) == ENUMLOOKUP[1486082168].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDevPri);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1486082168][msg.teDevPri];
              }
        }
        else if (mnem == "SrcTemp") {
            char buffer[50];
            auto engval = 0.03125 * (long double) (msg.uiSrcTemp + -8736.0);
            snprintf(buffer, sizeof(buffer), "%.2f %s", engval, "deg C");
            return (msg.uiSrcTemp == 0xffff) ? "No Data" : (msg.uiSrcTemp == 0xfffe) ? "Out of range" : (msg.uiSrcTemp == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "Soc") {
            char buffer[50];
            auto engval = 0.5 * (long double) (msg.ucSoc + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "%");
            return (msg.ucSoc == 0xff) ? "No Data" : (msg.ucSoc == 0xfe) ? "Out of range" : (msg.ucSoc == 0xfd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeRemain") {
            char buffer[50];
            auto engval = 1.0 * (long double) (msg.uiTimeRemain + 0.0);
            snprintf(buffer, sizeof(buffer), "%.0f %s", engval, "Min");
            return (msg.uiTimeRemain == 0xffff) ? "No Data" : (msg.uiTimeRemain == 0xfffe) ? "Out of range" : (msg.uiTimeRemain == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "TimeRemainInterp") {
            if (ENUMLOOKUP[972277822].find(msg.teTimeRemainInterp) == ENUMLOOKUP[972277822].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teTimeRemainInterp);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[972277822][msg.teTimeRemainInterp];
              }
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: DcSrcSts2" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DevPri      : " << fnGetValue("DevPri") << " (" << fnGetRawValue("DevPri") << ")" << endl;
        cout << "SrcTemp      : " << fnGetValue("SrcTemp") << " (" << fnGetRawValue("SrcTemp") << ")" << endl;
        cout << "Soc      : " << fnGetValue("Soc") << " (" << fnGetRawValue("Soc") << ")" << endl;
        cout << "TimeRemain      : " << fnGetValue("TimeRemain") << " (" << fnGetRawValue("TimeRemain") << ")" << endl;
        cout << "TimeRemainInterp      : " << fnGetValue("TimeRemainInterp") << " (" << fnGetRawValue("TimeRemainInterp") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.teInst);
        }
        else if (mnem == "DevPri") {
            return static_cast<uint32_t>(msg.teDevPri);
        }
        else if (mnem == "SrcTemp") {
            return static_cast<uint32_t>(msg.uiSrcTemp);
        }
        else if (mnem == "Soc") {
            return static_cast<uint32_t>(msg.ucSoc);
        }
        else if (mnem == "TimeRemain") {
            return static_cast<uint32_t>(msg.uiTimeRemain);
        }
        else if (mnem == "TimeRemainInterp") {
            return static_cast<uint32_t>(msg.teTimeRemainInterp);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teInst = static_cast<decltype(msg.teInst)>(enumValue);
     else msg.teInst = static_cast<decltype(msg.teInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DevPri") {
     int enumValue = findEnumValue(ENUMLOOKUP[1486082168], value);
     if (enumValue != -1) msg.teDevPri = static_cast<decltype(msg.teDevPri)>(enumValue);
     else msg.teDevPri = static_cast<decltype(msg.teDevPri)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "SrcTemp") {
     msg.uiSrcTemp = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.03125, -8736.0);
        }
        else if (mnem == "Soc") {
     msg.ucSoc = stringToInt(value, 0xff, 0xfe, 0xfd, 0.5, 0.0);
        }
        else if (mnem == "TimeRemain") {
     msg.uiTimeRemain = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 1.0, 0.0);
        }
        else if (mnem == "TimeRemainInterp") {
     int enumValue = findEnumValue(ENUMLOOKUP[972277822], value);
     if (enumValue != -1) msg.teTimeRemainInterp = static_cast<decltype(msg.teTimeRemainInterp)>(enumValue);
     else msg.teTimeRemainInterp = static_cast<decltype(msg.teTimeRemainInterp)>(stringToInt(value, 0, 0, 0));
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.teInst + 0.0);
        }
        else if (mnem == "DevPri") {
            return 1.0 * (long double)(msg.teDevPri + 0.0);
        }
        else if (mnem == "SrcTemp") {
            return 0.03125 * (long double)(msg.uiSrcTemp + -8736.0);
        }
        else if (mnem == "Soc") {
            return 0.5 * (long double)(msg.ucSoc + 0.0);
        }
        else if (mnem == "TimeRemain") {
            return 1.0 * (long double)(msg.uiTimeRemain + 0.0);
        }
        else if (mnem == "TimeRemainInterp") {
            return 1.0 * (long double)(msg.teTimeRemainInterp + 0.0);
        }
        return 0.0;
    }
} DcSrcSts2;

// Auto-generated class definition for RVC_tzPGN_DC_SRC_STS1
typedef struct DcSrcSts1 : public MessageBase {
RVC_tzPGN_DC_SRC_STS1 msg;
DcSrcSts1 () {  memset(&msg, 0xFF, sizeof(msg));  };
DcSrcSts1 (void * pvStruct) {  msg = *(RVC_tzPGN_DC_SRC_STS1 *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            if (ENUMLOOKUP[421711928].find(msg.teInst) == ENUMLOOKUP[421711928].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teInst);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[421711928][msg.teInst];
              }
        }
        else if (mnem == "DevPri") {
            if (ENUMLOOKUP[1486082168].find(msg.teDevPri) == ENUMLOOKUP[1486082168].end()) {
                 char buffer[50];
                 snprintf(buffer, sizeof(buffer), "??%d??", msg.teDevPri);
                 return (buffer);
            } else {
                 return ENUMLOOKUP[1486082168][msg.teDevPri];
              }
        }
        else if (mnem == "DcV") {
            char buffer[50];
            auto engval = 0.05000000074505806 * (long double) (msg.uiDcV + 0.0);
            snprintf(buffer, sizeof(buffer), "%.1f %s", engval, "V");
            return (msg.uiDcV == 0xffff) ? "No Data" : (msg.uiDcV == 0xfffe) ? "Out of range" : (msg.uiDcV == 0xfffd) ? "Reserved" : (buffer);
        }
        else if (mnem == "DcI") {
            char buffer[50];
            auto engval = 0.0010000000474974513 * (long double) (msg.ulDcI + -2000000000.0);
            snprintf(buffer, sizeof(buffer), "%.3f %s", engval, "A");
            return (msg.ulDcI == 0xffffffff) ? "No Data" : (msg.ulDcI == 0xfffffffe) ? "Out of range" : (msg.ulDcI == 0xfffffffd) ? "Reserved" : (buffer);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: DcSrcSts1" << std::endl;
        cout << "Inst      : " << fnGetValue("Inst") << " (" << fnGetRawValue("Inst") << ")" << endl;
        cout << "DevPri      : " << fnGetValue("DevPri") << " (" << fnGetRawValue("DevPri") << ")" << endl;
        cout << "DcV      : " << fnGetValue("DcV") << " (" << fnGetRawValue("DcV") << ")" << endl;
        cout << "DcI      : " << fnGetValue("DcI") << " (" << fnGetRawValue("DcI") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return static_cast<uint32_t>(msg.teInst);
        }
        else if (mnem == "DevPri") {
            return static_cast<uint32_t>(msg.teDevPri);
        }
        else if (mnem == "DcV") {
            return static_cast<uint32_t>(msg.uiDcV);
        }
        else if (mnem == "DcI") {
            return static_cast<uint32_t>(msg.ulDcI);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Inst") {
     int enumValue = findEnumValue(ENUMLOOKUP[421711928], value);
     if (enumValue != -1) msg.teInst = static_cast<decltype(msg.teInst)>(enumValue);
     else msg.teInst = static_cast<decltype(msg.teInst)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DevPri") {
     int enumValue = findEnumValue(ENUMLOOKUP[1486082168], value);
     if (enumValue != -1) msg.teDevPri = static_cast<decltype(msg.teDevPri)>(enumValue);
     else msg.teDevPri = static_cast<decltype(msg.teDevPri)>(stringToInt(value, 0, 0, 0));
        }
        else if (mnem == "DcV") {
     msg.uiDcV = stringToInt(value, 0xffff, 0xfffe, 0xfffd, 0.05000000074505806, 0.0);
        }
        else if (mnem == "DcI") {
     msg.ulDcI = stringToInt(value, 0xffffffff, 0xfffffffe, 0xfffffffd, 0.0010000000474974513, -2000000000.0);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Inst") {
            return 1.0 * (long double)(msg.teInst + 0.0);
        }
        else if (mnem == "DevPri") {
            return 1.0 * (long double)(msg.teDevPri + 0.0);
        }
        else if (mnem == "DcV") {
            return 0.05000000074505806 * (long double)(msg.uiDcV + 0.0);
        }
        else if (mnem == "DcI") {
            return 0.0010000000474974513 * (long double)(msg.ulDcI + -2000000000.0);
        }
        return 0.0;
    }
} DcSrcSts1;

// Auto-generated class definition for RVC_tzPGN_SET_SYS_DATE_TIME
typedef struct SetSysDateTime : public MessageBase {
RVC_tzPGN_SET_SYS_DATE_TIME msg;
SetSysDateTime () {  memset(&msg, 0xFF, sizeof(msg));  };
SetSysDateTime (void * pvStruct) {  msg = *(RVC_tzPGN_SET_SYS_DATE_TIME *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Yr") {
            return (msg.ucYr == 0xff) ? "No Data" : (msg.ucYr == 0xfe) ? "Out of range" : (msg.ucYr == 0xfd) ? "Reserved" : std::to_string(msg.ucYr);
        }
        else if (mnem == "Mn") {
            return (msg.ucMn == 0xff) ? "No Data" : (msg.ucMn == 0xfe) ? "Out of range" : (msg.ucMn == 0xfd) ? "Reserved" : std::to_string(msg.ucMn);
        }
        else if (mnem == "Date") {
            return (msg.ucDate == 0xff) ? "No Data" : (msg.ucDate == 0xfe) ? "Out of range" : (msg.ucDate == 0xfd) ? "Reserved" : std::to_string(msg.ucDate);
        }
        else if (mnem == "Dow") {
            return (msg.ucDow == 0xff) ? "No Data" : (msg.ucDow == 0xfe) ? "Out of range" : (msg.ucDow == 0xfd) ? "Reserved" : std::to_string(msg.ucDow);
        }
        else if (mnem == "Hr") {
            return (msg.ucHr == 0xff) ? "No Data" : (msg.ucHr == 0xfe) ? "Out of range" : (msg.ucHr == 0xfd) ? "Reserved" : std::to_string(msg.ucHr);
        }
        else if (mnem == "Min") {
            return (msg.ucMin == 0xff) ? "No Data" : (msg.ucMin == 0xfe) ? "Out of range" : (msg.ucMin == 0xfd) ? "Reserved" : std::to_string(msg.ucMin);
        }
        else if (mnem == "Sec") {
            return (msg.ucSec == 0xff) ? "No Data" : (msg.ucSec == 0xfe) ? "Out of range" : (msg.ucSec == 0xfd) ? "Reserved" : std::to_string(msg.ucSec);
        }
        else if (mnem == "Tz") {
            return (msg.ucTz == 0xff) ? "No Data" : (msg.ucTz == 0xfe) ? "Out of range" : (msg.ucTz == 0xfd) ? "Reserved" : std::to_string(msg.ucTz);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SetSysDateTime" << std::endl;
        cout << "Yr      : " << fnGetValue("Yr") << " (" << fnGetRawValue("Yr") << ")" << endl;
        cout << "Mn      : " << fnGetValue("Mn") << " (" << fnGetRawValue("Mn") << ")" << endl;
        cout << "Date      : " << fnGetValue("Date") << " (" << fnGetRawValue("Date") << ")" << endl;
        cout << "Dow      : " << fnGetValue("Dow") << " (" << fnGetRawValue("Dow") << ")" << endl;
        cout << "Hr      : " << fnGetValue("Hr") << " (" << fnGetRawValue("Hr") << ")" << endl;
        cout << "Min      : " << fnGetValue("Min") << " (" << fnGetRawValue("Min") << ")" << endl;
        cout << "Sec      : " << fnGetValue("Sec") << " (" << fnGetRawValue("Sec") << ")" << endl;
        cout << "Tz      : " << fnGetValue("Tz") << " (" << fnGetRawValue("Tz") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Yr") {
            return static_cast<uint32_t>(msg.ucYr);
        }
        else if (mnem == "Mn") {
            return static_cast<uint32_t>(msg.ucMn);
        }
        else if (mnem == "Date") {
            return static_cast<uint32_t>(msg.ucDate);
        }
        else if (mnem == "Dow") {
            return static_cast<uint32_t>(msg.ucDow);
        }
        else if (mnem == "Hr") {
            return static_cast<uint32_t>(msg.ucHr);
        }
        else if (mnem == "Min") {
            return static_cast<uint32_t>(msg.ucMin);
        }
        else if (mnem == "Sec") {
            return static_cast<uint32_t>(msg.ucSec);
        }
        else if (mnem == "Tz") {
            return static_cast<uint32_t>(msg.ucTz);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Yr") {
     msg.ucYr = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Mn") {
     msg.ucMn = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Date") {
     msg.ucDate = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Dow") {
     msg.ucDow = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Hr") {
     msg.ucHr = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Min") {
     msg.ucMin = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Sec") {
     msg.ucSec = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Tz") {
     msg.ucTz = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Yr") {
            return 1.0 * (long double)(msg.ucYr + 0.0);
        }
        else if (mnem == "Mn") {
            return 1.0 * (long double)(msg.ucMn + 0.0);
        }
        else if (mnem == "Date") {
            return 1.0 * (long double)(msg.ucDate + 0.0);
        }
        else if (mnem == "Dow") {
            return 1.0 * (long double)(msg.ucDow + 0.0);
        }
        else if (mnem == "Hr") {
            return 1.0 * (long double)(msg.ucHr + 0.0);
        }
        else if (mnem == "Min") {
            return 1.0 * (long double)(msg.ucMin + 0.0);
        }
        else if (mnem == "Sec") {
            return 1.0 * (long double)(msg.ucSec + 0.0);
        }
        else if (mnem == "Tz") {
            return 1.0 * (long double)(msg.ucTz + 0.0);
        }
        return 0.0;
    }
} SetSysDateTime;

// Auto-generated class definition for RVC_tzPGN_SYS_DATE_TIME_STS
typedef struct SysDateTimeSts : public MessageBase {
RVC_tzPGN_SYS_DATE_TIME_STS msg;
SysDateTimeSts () {  memset(&msg, 0xFF, sizeof(msg));  };
SysDateTimeSts (void * pvStruct) {  msg = *(RVC_tzPGN_SYS_DATE_TIME_STS *)pvStruct;  };
    std::string fnGetValue(const std::string mnem) const override {
        if (mnem == "Yr") {
            return (msg.ucYr == 0xff) ? "No Data" : (msg.ucYr == 0xfe) ? "Out of range" : (msg.ucYr == 0xfd) ? "Reserved" : std::to_string(msg.ucYr);
        }
        else if (mnem == "Mn") {
            return (msg.ucMn == 0xff) ? "No Data" : (msg.ucMn == 0xfe) ? "Out of range" : (msg.ucMn == 0xfd) ? "Reserved" : std::to_string(msg.ucMn);
        }
        else if (mnem == "Date") {
            return (msg.ucDate == 0xff) ? "No Data" : (msg.ucDate == 0xfe) ? "Out of range" : (msg.ucDate == 0xfd) ? "Reserved" : std::to_string(msg.ucDate);
        }
        else if (mnem == "Dow") {
            return (msg.ucDow == 0xff) ? "No Data" : (msg.ucDow == 0xfe) ? "Out of range" : (msg.ucDow == 0xfd) ? "Reserved" : std::to_string(msg.ucDow);
        }
        else if (mnem == "Hr") {
            return (msg.ucHr == 0xff) ? "No Data" : (msg.ucHr == 0xfe) ? "Out of range" : (msg.ucHr == 0xfd) ? "Reserved" : std::to_string(msg.ucHr);
        }
        else if (mnem == "Min") {
            return (msg.ucMin == 0xff) ? "No Data" : (msg.ucMin == 0xfe) ? "Out of range" : (msg.ucMin == 0xfd) ? "Reserved" : std::to_string(msg.ucMin);
        }
        else if (mnem == "Sec") {
            return (msg.ucSec == 0xff) ? "No Data" : (msg.ucSec == 0xfe) ? "Out of range" : (msg.ucSec == 0xfd) ? "Reserved" : std::to_string(msg.ucSec);
        }
        else if (mnem == "Tz") {
            return (msg.ucTz == 0xff) ? "No Data" : (msg.ucTz == 0xfe) ? "Out of range" : (msg.ucTz == 0xfd) ? "Reserved" : std::to_string(msg.ucTz);
        }
        else return "no pgn";
    }
    void Print() const override {
        std::cout << "PGN: SysDateTimeSts" << std::endl;
        cout << "Yr      : " << fnGetValue("Yr") << " (" << fnGetRawValue("Yr") << ")" << endl;
        cout << "Mn      : " << fnGetValue("Mn") << " (" << fnGetRawValue("Mn") << ")" << endl;
        cout << "Date      : " << fnGetValue("Date") << " (" << fnGetRawValue("Date") << ")" << endl;
        cout << "Dow      : " << fnGetValue("Dow") << " (" << fnGetRawValue("Dow") << ")" << endl;
        cout << "Hr      : " << fnGetValue("Hr") << " (" << fnGetRawValue("Hr") << ")" << endl;
        cout << "Min      : " << fnGetValue("Min") << " (" << fnGetRawValue("Min") << ")" << endl;
        cout << "Sec      : " << fnGetValue("Sec") << " (" << fnGetRawValue("Sec") << ")" << endl;
        cout << "Tz      : " << fnGetValue("Tz") << " (" << fnGetRawValue("Tz") << ")" << endl;
    }
    bool fnQualPasses(std::vector<std::tuple<std::string, std::string>> qual) const override {
        for (const auto& qualtup : qual) {
           std::string sig = std::get<0>(qualtup);
          std::string testval = std::get<1>(qualtup);
         std::string val = fnGetValue(sig);
    
            if (testval != val) {
              // Failed one of the clauses
               return false;
            }
        }
       // No clauses indicated this wasn't our message
       return true;
    }
    uint32 fnGetRawValue(const std::string mnem) const override {
        if (mnem == "Yr") {
            return static_cast<uint32_t>(msg.ucYr);
        }
        else if (mnem == "Mn") {
            return static_cast<uint32_t>(msg.ucMn);
        }
        else if (mnem == "Date") {
            return static_cast<uint32_t>(msg.ucDate);
        }
        else if (mnem == "Dow") {
            return static_cast<uint32_t>(msg.ucDow);
        }
        else if (mnem == "Hr") {
            return static_cast<uint32_t>(msg.ucHr);
        }
        else if (mnem == "Min") {
            return static_cast<uint32_t>(msg.ucMin);
        }
        else if (mnem == "Sec") {
            return static_cast<uint32_t>(msg.ucSec);
        }
        else if (mnem == "Tz") {
            return static_cast<uint32_t>(msg.ucTz);
        }
        return UINT32_MAX;
    }
    void fnSetValue(const std::string mnem, const std::string value) override {
        if (mnem == "Yr") {
     msg.ucYr = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Mn") {
     msg.ucMn = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Date") {
     msg.ucDate = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Dow") {
     msg.ucDow = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Hr") {
     msg.ucHr = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Min") {
     msg.ucMin = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Sec") {
     msg.ucSec = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
        else if (mnem == "Tz") {
     msg.ucTz = stringToInt(value, 0xff, 0xfe, 0xfd);
        }
    }
    void fnSend(uint32 pgn, int grpfunc, int addr) override {
        XBMSG_fnSendEx( pgn, grpfunc, &msg, sizeof( msg ), addr );
    }
    string fnTranslate(string func, const string param_value="") const override {
 return "";     };
    long double fnGetFloatValue(const std::string mnem) const override {
        if (mnem == "Yr") {
            return 1.0 * (long double)(msg.ucYr + 0.0);
        }
        else if (mnem == "Mn") {
            return 1.0 * (long double)(msg.ucMn + 0.0);
        }
        else if (mnem == "Date") {
            return 1.0 * (long double)(msg.ucDate + 0.0);
        }
        else if (mnem == "Dow") {
            return 1.0 * (long double)(msg.ucDow + 0.0);
        }
        else if (mnem == "Hr") {
            return 1.0 * (long double)(msg.ucHr + 0.0);
        }
        else if (mnem == "Min") {
            return 1.0 * (long double)(msg.ucMin + 0.0);
        }
        else if (mnem == "Sec") {
            return 1.0 * (long double)(msg.ucSec + 0.0);
        }
        else if (mnem == "Tz") {
            return 1.0 * (long double)(msg.ucTz + 0.0);
        }
        return 0.0;
    }
} SysDateTimeSts;

std::unordered_map<std::string, std::function<std::unique_ptr<MessageBase>(void *)>> message_types = {
{"ProdIdent", [](void * rcv) { return std::make_unique<ProdIdent>(rcv); } },
{"FileDnldBlk", [](void * rcv) { return std::make_unique<FileDnldBlk>(rcv); } },
{"SwVerSts", [](void * rcv) { return std::make_unique<SwVerSts>(rcv); } },
{"DiagMsg1", [](void * rcv) { return std::make_unique<DiagMsg1>(rcv); } },
{"IsoAck", [](void * rcv) { return std::make_unique<IsoAck>(rcv); } },
{"PmParamDevMdCfg", [](void * rcv) { return std::make_unique<PmParamDevMdCfg>(rcv); } },
{"PmParamAssocCfg", [](void * rcv) { return std::make_unique<PmParamAssocCfg>(rcv); } },
{"PmParamAuxCfg", [](void * rcv) { return std::make_unique<PmParamAuxCfg>(rcv); } },
{"PmParamAuxCfgTrigLvl", [](void * rcv) { return std::make_unique<PmParamAuxCfgTrigLvl>(rcv); } },
{"PmParamAuxCfgTrigDly", [](void * rcv) { return std::make_unique<PmParamAuxCfgTrigDly>(rcv); } },
{"PmParamAuxSts", [](void * rcv) { return std::make_unique<PmParamAuxSts>(rcv); } },
{"IsoReq", [](void * rcv) { return std::make_unique<IsoReq>(rcv); } },
{"IsoTpXfer", [](void * rcv) { return std::make_unique<IsoTpXfer>(rcv); } },
{"IsoTpConnManRts", [](void * rcv) { return std::make_unique<IsoTpConnManRts>(rcv); } },
{"IsoTpConnManCts", [](void * rcv) { return std::make_unique<IsoTpConnManCts>(rcv); } },
{"IsoTpConnManEom", [](void * rcv) { return std::make_unique<IsoTpConnManEom>(rcv); } },
{"IsoTpConnManBam", [](void * rcv) { return std::make_unique<IsoTpConnManBam>(rcv); } },
{"IsoTpConnManAbort", [](void * rcv) { return std::make_unique<IsoTpConnManAbort>(rcv); } },
{"IsoAddrClaim", [](void * rcv) { return std::make_unique<IsoAddrClaim>(rcv); } },
{"PmAssocCfg", [](void * rcv) { return std::make_unique<PmAssocCfg>(rcv); } },
{"PmReq", [](void * rcv) { return std::make_unique<PmReq>(rcv); } },
{"PmAssocSts", [](void * rcv) { return std::make_unique<PmAssocSts>(rcv); } },
{"PmDevMdCfg", [](void * rcv) { return std::make_unique<PmDevMdCfg>(rcv); } },
{"PmFXCCCfgCmd", [](void * rcv) { return std::make_unique<PmFxccCfgCmd>(rcv); } },
{"PmDevMdSts", [](void * rcv) { return std::make_unique<PmDevMdSts>(rcv); } },
{"PmFXCCCfgSts", [](void * rcv) { return std::make_unique<PmFxccCfgSts>(rcv); } },
{"PmSwVerSts", [](void * rcv) { return std::make_unique<PmSwVerSts>(rcv); } },
{"PmRpcCmd", [](void * rcv) { return std::make_unique<PmRpcCmd>(rcv); } },
{"PmInvLdShSts", [](void * rcv) { return std::make_unique<PmInvLdShSts>(rcv); } },
{"PmInvSts", [](void * rcv) { return std::make_unique<PmInvSts>(rcv); } },
{"PmChgSts", [](void * rcv) { return std::make_unique<PmChgSts>(rcv); } },
{"PmInvCtrlCmd", [](void * rcv) { return std::make_unique<PmInvCtrlCmd>(rcv); } },
{"PmAcStsRms", [](void * rcv) { return std::make_unique<PmAcStsRms>(rcv); } },
{"PmAcXferSwSts", [](void * rcv) { return std::make_unique<PmAcXferSwSts>(rcv); } },
{"PmGetConfigParam", [](void * rcv) { return std::make_unique<PmGetConfigParam>(rcv); } },
{"PmSetConfigParam", [](void * rcv) { return std::make_unique<PmSetConfigParam>(rcv); } },
{"PmGetStatusParam", [](void * rcv) { return std::make_unique<PmGetStatusParam>(rcv); } },
{"PmPpnSessionCmd", [](void * rcv) { return std::make_unique<PmPpnSessionCmd>(rcv); } },
{"PmPpnSessionRsp", [](void * rcv) { return std::make_unique<PmPpnSessionRsp>(rcv); } },
{"PmPpnReadCmd", [](void * rcv) { return std::make_unique<PmPpnReadCmd>(rcv); } },
{"PmPpnReadRsp", [](void * rcv) { return std::make_unique<PmPpnReadRsp>(rcv); } },
{"PmPpnWriteCmd", [](void * rcv) { return std::make_unique<PmPpnWriteCmd>(rcv); } },
{"PmPpnWriteRsp", [](void * rcv) { return std::make_unique<PmPpnWriteRsp>(rcv); } },
{"PmPpnNakRsp", [](void * rcv) { return std::make_unique<PmPpnNakRsp>(rcv); } },
{"PmLithionicsCmd", [](void * rcv) { return std::make_unique<PmLithionicsCmd>(rcv); } },
{"PmLithionicsSts", [](void * rcv) { return std::make_unique<PmLithionicsSts>(rcv); } },
{"IsoCmdAddr", [](void * rcv) { return std::make_unique<IsoCmdAddr>(rcv); } },
{"XbResetCmd", [](void * rcv) { return std::make_unique<XbResetCmd>(rcv); } },
{"FileDnldInf", [](void * rcv) { return std::make_unique<FileDnldInf>(rcv); } },
{"SimpleCalibCfg", [](void * rcv) { return std::make_unique<SimpleCalibCfg>(rcv); } },
{"FileDnldSts", [](void * rcv) { return std::make_unique<FileDnldSts>(rcv); } },
{"InstSts", [](void * rcv) { return std::make_unique<InstSts>(rcv); } },
{"InstAssign", [](void * rcv) { return std::make_unique<InstAssign>(rcv); } },
{"VirtualTerminal", [](void * rcv) { return std::make_unique<VirtualTerminal>(rcv); } },
{"GenRst", [](void * rcv) { return std::make_unique<GenRst>(rcv); } },
{"ProdInfoSts", [](void * rcv) { return std::make_unique<ProdInfoSts>(rcv); } },
{"ChgSts3", [](void * rcv) { return std::make_unique<ChgSts3>(rcv); } },
{"InvTempSts2", [](void * rcv) { return std::make_unique<InvTempSts2>(rcv); } },
{"SccCfgCmd5", [](void * rcv) { return std::make_unique<SccCfgCmd5>(rcv); } },
{"SccCfgSts5", [](void * rcv) { return std::make_unique<SccCfgSts5>(rcv); } },
{"DcSrcConnSts", [](void * rcv) { return std::make_unique<DcSrcConnSts>(rcv); } },
{"DeviceStateSync", [](void * rcv) { return std::make_unique<DeviceStateSync>(rcv); } },
{"DcSrcCfgCmd3", [](void * rcv) { return std::make_unique<DcSrcCfgCmd3>(rcv); } },
{"BattSumm", [](void * rcv) { return std::make_unique<BattSumm>(rcv); } },
{"SccCfgCmd4", [](void * rcv) { return std::make_unique<SccCfgCmd4>(rcv); } },
{"SccCfgSts4", [](void * rcv) { return std::make_unique<SccCfgSts4>(rcv); } },
{"SccCfgCmd3", [](void * rcv) { return std::make_unique<SccCfgCmd3>(rcv); } },
{"SccCfgSts3", [](void * rcv) { return std::make_unique<SccCfgSts3>(rcv); } },
{"SccCfgCmd2", [](void * rcv) { return std::make_unique<SccCfgCmd2>(rcv); } },
{"SccCfgSts2", [](void * rcv) { return std::make_unique<SccCfgSts2>(rcv); } },
{"SccArraySts", [](void * rcv) { return std::make_unique<SccArraySts>(rcv); } },
{"SccBattSts", [](void * rcv) { return std::make_unique<SccBattSts>(rcv); } },
{"SccSts6", [](void * rcv) { return std::make_unique<SccSts6>(rcv); } },
{"SccSts5", [](void * rcv) { return std::make_unique<SccSts5>(rcv); } },
{"SccSts4", [](void * rcv) { return std::make_unique<SccSts4>(rcv); } },
{"SccSts3", [](void * rcv) { return std::make_unique<SccSts3>(rcv); } },
{"SccSts2", [](void * rcv) { return std::make_unique<SccSts2>(rcv); } },
{"BattCmd", [](void * rcv) { return std::make_unique<BattCmd>(rcv); } },
{"BattSts11", [](void * rcv) { return std::make_unique<BattSts11>(rcv); } },
{"BattSts6", [](void * rcv) { return std::make_unique<BattSts6>(rcv); } },
{"BattSts4", [](void * rcv) { return std::make_unique<BattSts4>(rcv); } },
{"BattSts3", [](void * rcv) { return std::make_unique<BattSts3>(rcv); } },
{"BattSts2", [](void * rcv) { return std::make_unique<BattSts2>(rcv); } },
{"BattSts1", [](void * rcv) { return std::make_unique<BattSts1>(rcv); } },
{"InvCfgCmd4", [](void * rcv) { return std::make_unique<InvCfgCmd4>(rcv); } },
{"InvCfgSts4", [](void * rcv) { return std::make_unique<InvCfgSts4>(rcv); } },
{"AlarmCmd", [](void * rcv) { return std::make_unique<AlarmCmd>(rcv); } },
{"AlarmSts", [](void * rcv) { return std::make_unique<AlarmSts>(rcv); } },
{"ChgSts2", [](void * rcv) { return std::make_unique<ChgSts2>(rcv); } },
{"DcSrcCmd", [](void * rcv) { return std::make_unique<DcSrcCmd>(rcv); } },
{"DcSrcSts11", [](void * rcv) { return std::make_unique<DcSrcSts11>(rcv); } },
{"SccEqlzCfgCmd", [](void * rcv) { return std::make_unique<SccEqlzCfgCmd>(rcv); } },
{"SccEqlzCfgSts", [](void * rcv) { return std::make_unique<SccEqlzCfgSts>(rcv); } },
{"SccEqlzSts", [](void * rcv) { return std::make_unique<SccEqlzSts>(rcv); } },
{"SccCfgCmd", [](void * rcv) { return std::make_unique<SccCfgCmd>(rcv); } },
{"SccCmd", [](void * rcv) { return std::make_unique<SccCmd>(rcv); } },
{"SccCfgSts", [](void * rcv) { return std::make_unique<SccCfgSts>(rcv); } },
{"SccSts", [](void * rcv) { return std::make_unique<SccSts>(rcv); } },
{"InvTempSts", [](void * rcv) { return std::make_unique<InvTempSts>(rcv); } },
{"ChgCfgCmd4", [](void * rcv) { return std::make_unique<ChgCfgCmd4>(rcv); } },
{"ChgCfgSts4", [](void * rcv) { return std::make_unique<ChgCfgSts4>(rcv); } },
{"DcSrcSts6", [](void * rcv) { return std::make_unique<DcSrcSts6>(rcv); } },
{"DCSrcSts4", [](void * rcv) { return std::make_unique<DcSrcSts4>(rcv); } },
{"ChgCfgCmd3", [](void * rcv) { return std::make_unique<ChgCfgCmd3>(rcv); } },
{"ChgCfgSts3", [](void * rcv) { return std::make_unique<ChgCfgSts3>(rcv); } },
{"InvCfgCmd3", [](void * rcv) { return std::make_unique<InvCfgCmd3>(rcv); } },
{"InvCfgSts3", [](void * rcv) { return std::make_unique<InvCfgSts3>(rcv); } },
{"InvDcSts", [](void * rcv) { return std::make_unique<InvDcSts>(rcv); } },
{"ChgAcFltCfgCmd2", [](void * rcv) { return std::make_unique<ChgAcFltCfgCmd2>(rcv); } },
{"ChgAcFltCfgCmd1", [](void * rcv) { return std::make_unique<ChgAcFltCfgCmd1>(rcv); } },
{"ChgAcFltCfgSts2", [](void * rcv) { return std::make_unique<ChgAcFltCfgSts2>(rcv); } },
{"ChgAcFltCfgSts1", [](void * rcv) { return std::make_unique<ChgAcFltCfgSts1>(rcv); } },
{"ChgAcSts4", [](void * rcv) { return std::make_unique<ChgAcSts4>(rcv); } },
{"InvAcFltCfgCmd1", [](void * rcv) { return std::make_unique<InvAcFltCfgCmd1>(rcv); } },
{"InvAcFltCfgSts1", [](void * rcv) { return std::make_unique<InvAcFltCfgSts1>(rcv); } },
{"InvAcSts4", [](void * rcv) { return std::make_unique<InvAcSts4>(rcv); } },
{"ChgCfgCmd2", [](void * rcv) { return std::make_unique<ChgCfgCmd2>(rcv); } },
{"ChgCfgSts2", [](void * rcv) { return std::make_unique<ChgCfgSts2>(rcv); } },
{"ChgEqlzCfgCmd", [](void * rcv) { return std::make_unique<ChgEqlzCfgCmd>(rcv); } },
{"ChgEqlzCfgSts", [](void * rcv) { return std::make_unique<ChgEqlzCfgSts>(rcv); } },
{"ChgEqlzSts", [](void * rcv) { return std::make_unique<ChgEqlzSts>(rcv); } },
{"AcFltCtrlCfgCmd2", [](void * rcv) { return std::make_unique<AcFltCtrlCfgCmd2>(rcv); } },
{"AcFltCtrlCfgCmd1", [](void * rcv) { return std::make_unique<AcFltCtrlCfgCmd1>(rcv); } },
{"AcFltCtrlCfgSts2", [](void * rcv) { return std::make_unique<AcFltCtrlCfgSts2>(rcv); } },
{"AcFltCtrlCfgSts1", [](void * rcv) { return std::make_unique<AcFltCtrlCfgSts1>(rcv); } },
{"AGSCritCmdDcSoc", [](void * rcv) { return std::make_unique<AgsCritCmdDcSoc>(rcv); } },
{"AGSCritCmdDcV", [](void * rcv) { return std::make_unique<AgsCritCmdDcV>(rcv); } },
{"AGSCritCmdAmbTemp", [](void * rcv) { return std::make_unique<AgsCritCmdAmbTemp>(rcv); } },
{"AGSCritCmdDcI", [](void * rcv) { return std::make_unique<AgsCritCmdDcI>(rcv); } },
{"AGSCritStsAmbTemp", [](void * rcv) { return std::make_unique<AgsCritStsAmbTemp>(rcv); } },
{"AGSCritStsDcV", [](void * rcv) { return std::make_unique<AgsCritStsDcV>(rcv); } },
{"AGSCritStsDcSoc", [](void * rcv) { return std::make_unique<AgsCritStsDcSoc>(rcv); } },
{"AGSCritStsDcI", [](void * rcv) { return std::make_unique<AgsCritStsDcI>(rcv); } },
{"AGSCritStsXferAcV", [](void * rcv) { return std::make_unique<AgsCritStsXferAcV>(rcv); } },
{"GenDemandCmd", [](void * rcv) { return std::make_unique<GenDemandCmd>(rcv); } },
{"GenDemandSts", [](void * rcv) { return std::make_unique<GenDemandSts>(rcv); } },
{"ChgStatsSts", [](void * rcv) { return std::make_unique<ChgStatsSts>(rcv); } },
{"ChgCfgCmd1", [](void * rcv) { return std::make_unique<ChgCfgCmd1>(rcv); } },
{"ChgCmd", [](void * rcv) { return std::make_unique<ChgCmd>(rcv); } },
{"ChgCfgSts1", [](void * rcv) { return std::make_unique<ChgCfgSts1>(rcv); } },
{"ChgSts", [](void * rcv) { return std::make_unique<ChgSts>(rcv); } },
{"ChgAcSts3", [](void * rcv) { return std::make_unique<ChgAcSts3>(rcv); } },
{"ChgAcSts2", [](void * rcv) { return std::make_unique<ChgAcSts2>(rcv); } },
{"ChgAcSts1", [](void * rcv) { return std::make_unique<ChgAcSts1>(rcv); } },
{"InvOpsSts", [](void * rcv) { return std::make_unique<InvOpsSts>(rcv); } },
{"InvHvDcBusSts", [](void * rcv) { return std::make_unique<InvHvDcBusSts>(rcv); } },
{"InvApsSts", [](void * rcv) { return std::make_unique<InvApsSts>(rcv); } },
{"InvStatsSts", [](void * rcv) { return std::make_unique<InvStatsSts>(rcv); } },
{"InvCfgCmd2", [](void * rcv) { return std::make_unique<InvCfgCmd2>(rcv); } },
{"InvCfgCmd1", [](void * rcv) { return std::make_unique<InvCfgCmd1>(rcv); } },
{"InvCfgSts2", [](void * rcv) { return std::make_unique<InvCfgSts2>(rcv); } },
{"InvCfgSts1", [](void * rcv) { return std::make_unique<InvCfgSts1>(rcv); } },
{"InvCmd", [](void * rcv) { return std::make_unique<InvCmd>(rcv); } },
{"InvSts", [](void * rcv) { return std::make_unique<InvSts>(rcv); } },
{"InvAcSts3", [](void * rcv) { return std::make_unique<InvAcSts3>(rcv); } },
{"InvAcSts2", [](void * rcv) { return std::make_unique<InvAcSts2>(rcv); } },
{"InvAcSts1", [](void * rcv) { return std::make_unique<InvAcSts1>(rcv); } },
{"GenStartCfgCmd", [](void * rcv) { return std::make_unique<GenStartCfgCmd>(rcv); } },
{"GenStartCfgSts", [](void * rcv) { return std::make_unique<GenStartCfgSts>(rcv); } },
{"GenCmd", [](void * rcv) { return std::make_unique<GenCmd>(rcv); } },
{"GenSts2", [](void * rcv) { return std::make_unique<GenSts2>(rcv); } },
{"GenSts1", [](void * rcv) { return std::make_unique<GenSts1>(rcv); } },
{"CommSts3", [](void * rcv) { return std::make_unique<CommSts3>(rcv); } },
{"CommSts2", [](void * rcv) { return std::make_unique<CommSts2>(rcv); } },
{"CommSts1", [](void * rcv) { return std::make_unique<CommSts1>(rcv); } },
{"DCSrcSts3", [](void * rcv) { return std::make_unique<DcSrcSts3>(rcv); } },
{"DCSrcSts2", [](void * rcv) { return std::make_unique<DcSrcSts2>(rcv); } },
{"DCSrcSts1", [](void * rcv) { return std::make_unique<DcSrcSts1>(rcv); } },
{"SetSysDateTime", [](void * rcv) { return std::make_unique<SetSysDateTime>(rcv); } },
{"SysDateTimeSts", [](void * rcv) { return std::make_unique<SysDateTimeSts>(rcv); } },
};
std::unordered_map<std::string, std::function<std::unique_ptr<MessageBase>()>> message_types_def = {
{"ProdIdent", []() { return std::make_unique<ProdIdent>(); } },
{"FileDnldBlk", []() { return std::make_unique<FileDnldBlk>(); } },
{"SwVerSts", []() { return std::make_unique<SwVerSts>(); } },
{"DiagMsg1", []() { return std::make_unique<DiagMsg1>(); } },
{"IsoAck", []() { return std::make_unique<IsoAck>(); } },
{"PmParamDevMdCfg", []() { return std::make_unique<PmParamDevMdCfg>(); } },
{"PmParamAssocCfg", []() { return std::make_unique<PmParamAssocCfg>(); } },
{"PmParamAuxCfg", []() { return std::make_unique<PmParamAuxCfg>(); } },
{"PmParamAuxCfgTrigLvl", []() { return std::make_unique<PmParamAuxCfgTrigLvl>(); } },
{"PmParamAuxCfgTrigDly", []() { return std::make_unique<PmParamAuxCfgTrigDly>(); } },
{"PmParamAuxSts", []() { return std::make_unique<PmParamAuxSts>(); } },
{"IsoReq", []() { return std::make_unique<IsoReq>(); } },
{"IsoTpXfer", []() { return std::make_unique<IsoTpXfer>(); } },
{"IsoTpConnManRts", []() { return std::make_unique<IsoTpConnManRts>(); } },
{"IsoTpConnManCts", []() { return std::make_unique<IsoTpConnManCts>(); } },
{"IsoTpConnManEom", []() { return std::make_unique<IsoTpConnManEom>(); } },
{"IsoTpConnManBam", []() { return std::make_unique<IsoTpConnManBam>(); } },
{"IsoTpConnManAbort", []() { return std::make_unique<IsoTpConnManAbort>(); } },
{"IsoAddrClaim", []() { return std::make_unique<IsoAddrClaim>(); } },
{"PmAssocCfg", []() { return std::make_unique<PmAssocCfg>(); } },
{"PmReq", []() { return std::make_unique<PmReq>(); } },
{"PmAssocSts", []() { return std::make_unique<PmAssocSts>(); } },
{"PmDevMdCfg", []() { return std::make_unique<PmDevMdCfg>(); } },
{"PmFXCCCfgCmd", []() { return std::make_unique<PmFxccCfgCmd>(); } },
{"PmDevMdSts", []() { return std::make_unique<PmDevMdSts>(); } },
{"PmFXCCCfgSts", []() { return std::make_unique<PmFxccCfgSts>(); } },
{"PmSwVerSts", []() { return std::make_unique<PmSwVerSts>(); } },
{"PmRpcCmd", []() { return std::make_unique<PmRpcCmd>(); } },
{"PmInvLdShSts", []() { return std::make_unique<PmInvLdShSts>(); } },
{"PmInvSts", []() { return std::make_unique<PmInvSts>(); } },
{"PmChgSts", []() { return std::make_unique<PmChgSts>(); } },
{"PmInvCtrlCmd", []() { return std::make_unique<PmInvCtrlCmd>(); } },
{"PmAcStsRms", []() { return std::make_unique<PmAcStsRms>(); } },
{"PmAcXferSwSts", []() { return std::make_unique<PmAcXferSwSts>(); } },
{"PmGetConfigParam", []() { return std::make_unique<PmGetConfigParam>(); } },
{"PmSetConfigParam", []() { return std::make_unique<PmSetConfigParam>(); } },
{"PmGetStatusParam", []() { return std::make_unique<PmGetStatusParam>(); } },
{"PmPpnSessionCmd", []() { return std::make_unique<PmPpnSessionCmd>(); } },
{"PmPpnSessionRsp", []() { return std::make_unique<PmPpnSessionRsp>(); } },
{"PmPpnReadCmd", []() { return std::make_unique<PmPpnReadCmd>(); } },
{"PmPpnReadRsp", []() { return std::make_unique<PmPpnReadRsp>(); } },
{"PmPpnWriteCmd", []() { return std::make_unique<PmPpnWriteCmd>(); } },
{"PmPpnWriteRsp", []() { return std::make_unique<PmPpnWriteRsp>(); } },
{"PmPpnNakRsp", []() { return std::make_unique<PmPpnNakRsp>(); } },
{"PmLithionicsCmd", []() { return std::make_unique<PmLithionicsCmd>(); } },
{"PmLithionicsSts", []() { return std::make_unique<PmLithionicsSts>(); } },
{"IsoCmdAddr", []() { return std::make_unique<IsoCmdAddr>(); } },
{"XbResetCmd", []() { return std::make_unique<XbResetCmd>(); } },
{"FileDnldInf", []() { return std::make_unique<FileDnldInf>(); } },
{"SimpleCalibCfg", []() { return std::make_unique<SimpleCalibCfg>(); } },
{"FileDnldSts", []() { return std::make_unique<FileDnldSts>(); } },
{"InstSts", []() { return std::make_unique<InstSts>(); } },
{"InstAssign", []() { return std::make_unique<InstAssign>(); } },
{"VirtualTerminal", []() { return std::make_unique<VirtualTerminal>(); } },
{"GenRst", []() { return std::make_unique<GenRst>(); } },
{"ProdInfoSts", []() { return std::make_unique<ProdInfoSts>(); } },
{"ChgSts3", []() { return std::make_unique<ChgSts3>(); } },
{"InvTempSts2", []() { return std::make_unique<InvTempSts2>(); } },
{"SccCfgCmd5", []() { return std::make_unique<SccCfgCmd5>(); } },
{"SccCfgSts5", []() { return std::make_unique<SccCfgSts5>(); } },
{"DcSrcConnSts", []() { return std::make_unique<DcSrcConnSts>(); } },
{"DeviceStateSync", []() { return std::make_unique<DeviceStateSync>(); } },
{"DcSrcCfgCmd3", []() { return std::make_unique<DcSrcCfgCmd3>(); } },
{"BattSumm", []() { return std::make_unique<BattSumm>(); } },
{"SccCfgCmd4", []() { return std::make_unique<SccCfgCmd4>(); } },
{"SccCfgSts4", []() { return std::make_unique<SccCfgSts4>(); } },
{"SccCfgCmd3", []() { return std::make_unique<SccCfgCmd3>(); } },
{"SccCfgSts3", []() { return std::make_unique<SccCfgSts3>(); } },
{"SccCfgCmd2", []() { return std::make_unique<SccCfgCmd2>(); } },
{"SccCfgSts2", []() { return std::make_unique<SccCfgSts2>(); } },
{"SccArraySts", []() { return std::make_unique<SccArraySts>(); } },
{"SccBattSts", []() { return std::make_unique<SccBattSts>(); } },
{"SccSts6", []() { return std::make_unique<SccSts6>(); } },
{"SccSts5", []() { return std::make_unique<SccSts5>(); } },
{"SccSts4", []() { return std::make_unique<SccSts4>(); } },
{"SccSts3", []() { return std::make_unique<SccSts3>(); } },
{"SccSts2", []() { return std::make_unique<SccSts2>(); } },
{"BattCmd", []() { return std::make_unique<BattCmd>(); } },
{"BattSts11", []() { return std::make_unique<BattSts11>(); } },
{"BattSts6", []() { return std::make_unique<BattSts6>(); } },
{"BattSts4", []() { return std::make_unique<BattSts4>(); } },
{"BattSts3", []() { return std::make_unique<BattSts3>(); } },
{"BattSts2", []() { return std::make_unique<BattSts2>(); } },
{"BattSts1", []() { return std::make_unique<BattSts1>(); } },
{"InvCfgCmd4", []() { return std::make_unique<InvCfgCmd4>(); } },
{"InvCfgSts4", []() { return std::make_unique<InvCfgSts4>(); } },
{"AlarmCmd", []() { return std::make_unique<AlarmCmd>(); } },
{"AlarmSts", []() { return std::make_unique<AlarmSts>(); } },
{"ChgSts2", []() { return std::make_unique<ChgSts2>(); } },
{"DcSrcCmd", []() { return std::make_unique<DcSrcCmd>(); } },
{"DcSrcSts11", []() { return std::make_unique<DcSrcSts11>(); } },
{"SccEqlzCfgCmd", []() { return std::make_unique<SccEqlzCfgCmd>(); } },
{"SccEqlzCfgSts", []() { return std::make_unique<SccEqlzCfgSts>(); } },
{"SccEqlzSts", []() { return std::make_unique<SccEqlzSts>(); } },
{"SccCfgCmd", []() { return std::make_unique<SccCfgCmd>(); } },
{"SccCmd", []() { return std::make_unique<SccCmd>(); } },
{"SccCfgSts", []() { return std::make_unique<SccCfgSts>(); } },
{"SccSts", []() { return std::make_unique<SccSts>(); } },
{"InvTempSts", []() { return std::make_unique<InvTempSts>(); } },
{"ChgCfgCmd4", []() { return std::make_unique<ChgCfgCmd4>(); } },
{"ChgCfgSts4", []() { return std::make_unique<ChgCfgSts4>(); } },
{"DcSrcSts6", []() { return std::make_unique<DcSrcSts6>(); } },
{"DCSrcSts4", []() { return std::make_unique<DcSrcSts4>(); } },
{"ChgCfgCmd3", []() { return std::make_unique<ChgCfgCmd3>(); } },
{"ChgCfgSts3", []() { return std::make_unique<ChgCfgSts3>(); } },
{"InvCfgCmd3", []() { return std::make_unique<InvCfgCmd3>(); } },
{"InvCfgSts3", []() { return std::make_unique<InvCfgSts3>(); } },
{"InvDcSts", []() { return std::make_unique<InvDcSts>(); } },
{"ChgAcFltCfgCmd2", []() { return std::make_unique<ChgAcFltCfgCmd2>(); } },
{"ChgAcFltCfgCmd1", []() { return std::make_unique<ChgAcFltCfgCmd1>(); } },
{"ChgAcFltCfgSts2", []() { return std::make_unique<ChgAcFltCfgSts2>(); } },
{"ChgAcFltCfgSts1", []() { return std::make_unique<ChgAcFltCfgSts1>(); } },
{"ChgAcSts4", []() { return std::make_unique<ChgAcSts4>(); } },
{"InvAcFltCfgCmd1", []() { return std::make_unique<InvAcFltCfgCmd1>(); } },
{"InvAcFltCfgSts1", []() { return std::make_unique<InvAcFltCfgSts1>(); } },
{"InvAcSts4", []() { return std::make_unique<InvAcSts4>(); } },
{"ChgCfgCmd2", []() { return std::make_unique<ChgCfgCmd2>(); } },
{"ChgCfgSts2", []() { return std::make_unique<ChgCfgSts2>(); } },
{"ChgEqlzCfgCmd", []() { return std::make_unique<ChgEqlzCfgCmd>(); } },
{"ChgEqlzCfgSts", []() { return std::make_unique<ChgEqlzCfgSts>(); } },
{"ChgEqlzSts", []() { return std::make_unique<ChgEqlzSts>(); } },
{"AcFltCtrlCfgCmd2", []() { return std::make_unique<AcFltCtrlCfgCmd2>(); } },
{"AcFltCtrlCfgCmd1", []() { return std::make_unique<AcFltCtrlCfgCmd1>(); } },
{"AcFltCtrlCfgSts2", []() { return std::make_unique<AcFltCtrlCfgSts2>(); } },
{"AcFltCtrlCfgSts1", []() { return std::make_unique<AcFltCtrlCfgSts1>(); } },
{"AGSCritCmdDcSoc", []() { return std::make_unique<AgsCritCmdDcSoc>(); } },
{"AGSCritCmdDcV", []() { return std::make_unique<AgsCritCmdDcV>(); } },
{"AGSCritCmdAmbTemp", []() { return std::make_unique<AgsCritCmdAmbTemp>(); } },
{"AGSCritCmdDcI", []() { return std::make_unique<AgsCritCmdDcI>(); } },
{"AGSCritStsAmbTemp", []() { return std::make_unique<AgsCritStsAmbTemp>(); } },
{"AGSCritStsDcV", []() { return std::make_unique<AgsCritStsDcV>(); } },
{"AGSCritStsDcSoc", []() { return std::make_unique<AgsCritStsDcSoc>(); } },
{"AGSCritStsDcI", []() { return std::make_unique<AgsCritStsDcI>(); } },
{"AGSCritStsXferAcV", []() { return std::make_unique<AgsCritStsXferAcV>(); } },
{"GenDemandCmd", []() { return std::make_unique<GenDemandCmd>(); } },
{"GenDemandSts", []() { return std::make_unique<GenDemandSts>(); } },
{"ChgStatsSts", []() { return std::make_unique<ChgStatsSts>(); } },
{"ChgCfgCmd1", []() { return std::make_unique<ChgCfgCmd1>(); } },
{"ChgCmd", []() { return std::make_unique<ChgCmd>(); } },
{"ChgCfgSts1", []() { return std::make_unique<ChgCfgSts1>(); } },
{"ChgSts", []() { return std::make_unique<ChgSts>(); } },
{"ChgAcSts3", []() { return std::make_unique<ChgAcSts3>(); } },
{"ChgAcSts2", []() { return std::make_unique<ChgAcSts2>(); } },
{"ChgAcSts1", []() { return std::make_unique<ChgAcSts1>(); } },
{"InvOpsSts", []() { return std::make_unique<InvOpsSts>(); } },
{"InvHvDcBusSts", []() { return std::make_unique<InvHvDcBusSts>(); } },
{"InvApsSts", []() { return std::make_unique<InvApsSts>(); } },
{"InvStatsSts", []() { return std::make_unique<InvStatsSts>(); } },
{"InvCfgCmd2", []() { return std::make_unique<InvCfgCmd2>(); } },
{"InvCfgCmd1", []() { return std::make_unique<InvCfgCmd1>(); } },
{"InvCfgSts2", []() { return std::make_unique<InvCfgSts2>(); } },
{"InvCfgSts1", []() { return std::make_unique<InvCfgSts1>(); } },
{"InvCmd", []() { return std::make_unique<InvCmd>(); } },
{"InvSts", []() { return std::make_unique<InvSts>(); } },
{"InvAcSts3", []() { return std::make_unique<InvAcSts3>(); } },
{"InvAcSts2", []() { return std::make_unique<InvAcSts2>(); } },
{"InvAcSts1", []() { return std::make_unique<InvAcSts1>(); } },
{"GenStartCfgCmd", []() { return std::make_unique<GenStartCfgCmd>(); } },
{"GenStartCfgSts", []() { return std::make_unique<GenStartCfgSts>(); } },
{"GenCmd", []() { return std::make_unique<GenCmd>(); } },
{"GenSts2", []() { return std::make_unique<GenSts2>(); } },
{"GenSts1", []() { return std::make_unique<GenSts1>(); } },
{"CommSts3", []() { return std::make_unique<CommSts3>(); } },
{"CommSts2", []() { return std::make_unique<CommSts2>(); } },
{"CommSts1", []() { return std::make_unique<CommSts1>(); } },
{"DCSrcSts3", []() { return std::make_unique<DcSrcSts3>(); } },
{"DCSrcSts2", []() { return std::make_unique<DcSrcSts2>(); } },
{"DCSrcSts1", []() { return std::make_unique<DcSrcSts1>(); } },
{"SetSysDateTime", []() { return std::make_unique<SetSysDateTime>(); } },
{"SysDateTimeSts", []() { return std::make_unique<SysDateTimeSts>(); } },
};
std::map<std::tuple<int, int>, std::string> PGNTABLE = {
{ make_pair(59392, -1) , "IsoAck"},
{ make_pair(59648, 1) , "PmParamDevMdCfg"},
{ make_pair(59648, 2) , "PmParamAssocCfg"},
{ make_pair(59648, 3) , "PmParamAuxCfg"},
{ make_pair(59648, 4) , "PmParamAuxCfgTrigLvl"},
{ make_pair(59648, 5) , "PmParamAuxCfgTrigDly"},
{ make_pair(59648, 7) , "PmParamAuxSts"},
{ make_pair(59904, -1) , "IsoReq"},
{ make_pair(60160, -1) , "IsoTpXfer"},
{ make_pair(60416, 16) , "IsoTpConnManRts"},
{ make_pair(60416, 17) , "IsoTpConnManCts"},
{ make_pair(60416, 19) , "IsoTpConnManEom"},
{ make_pair(60416, 32) , "IsoTpConnManBam"},
{ make_pair(60416, 255) , "IsoTpConnManAbort"},
{ make_pair(60928, -1) , "IsoAddrClaim"},
{ make_pair(61184, 1) , "PmAssocCfg"},
{ make_pair(61184, 2) , "PmReq"},
{ make_pair(61184, 3) , "PmAssocSts"},
{ make_pair(61184, 4) , "PmDevMdCfg"},
{ make_pair(61184, 5) , "PmFXCCCfgCmd"},
{ make_pair(61184, 6) , "PmDevMdSts"},
{ make_pair(61184, 7) , "PmFXCCCfgSts"},
{ make_pair(61184, 8) , "PmSwVerSts"},
{ make_pair(61184, 9) , "PmRpcCmd"},
{ make_pair(61184, 10) , "PmInvLdShSts"},
{ make_pair(61184, 11) , "PmInvSts"},
{ make_pair(61184, 12) , "PmChgSts"},
{ make_pair(61184, 14) , "PmInvCtrlCmd"},
{ make_pair(61184, 15) , "PmAcStsRms"},
{ make_pair(61184, 16) , "PmAcXferSwSts"},
{ make_pair(61184, 17) , "PmGetConfigParam"},
{ make_pair(61184, 18) , "PmSetConfigParam"},
{ make_pair(61184, 19) , "PmGetStatusParam"},
{ make_pair(61184, 96) , "PmPpnSessionCmd"},
{ make_pair(61184, 97) , "PmPpnSessionRsp"},
{ make_pair(61184, 98) , "PmPpnReadCmd"},
{ make_pair(61184, 99) , "PmPpnReadRsp"},
{ make_pair(61184, 100) , "PmPpnWriteCmd"},
{ make_pair(61184, 101) , "PmPpnWriteRsp"},
{ make_pair(61184, 127) , "PmPpnNakRsp"},
{ make_pair(61184, 170) , "PmLithionicsCmd"},
{ make_pair(61184, 171) , "PmLithionicsSts"},
{ make_pair(65240, -1) , "IsoCmdAddr"},
{ make_pair(65259, -1) , "ProdIdent"},
{ make_pair(74752, -1) , "XbResetCmd"},
{ make_pair(78080, -1) , "FileDnldBlk"},
{ make_pair(78336, -1) , "FileDnldInf"},
{ make_pair(79872, -1) , "SimpleCalibCfg"},
{ make_pair(80640, -1) , "FileDnldSts"},
{ make_pair(97024, -1) , "InstSts"},
{ make_pair(97280, -1) , "InstAssign"},
{ make_pair(97792, -1) , "VirtualTerminal"},
{ make_pair(98048, -1) , "GenRst"},
{ make_pair(126996, -1) , "ProdInfoSts"},
{ make_pair(129038, -1) , "SwVerSts"},
{ make_pair(130506, -1) , "ChgSts3"},
{ make_pair(130507, -1) , "InvTempSts2"},
{ make_pair(130510, -1) , "SccCfgCmd5"},
{ make_pair(130511, -1) , "SccCfgSts5"},
{ make_pair(130512, -1) , "DcSrcConnSts"},
{ make_pair(130513, -1) , "DeviceStateSync"},
{ make_pair(130526, -1) , "DcSrcCfgCmd3"},
{ make_pair(130545, -1) , "BattSumm"},
{ make_pair(130553, -1) , "SccCfgCmd4"},
{ make_pair(130554, -1) , "SccCfgSts4"},
{ make_pair(130555, -1) , "SccCfgCmd3"},
{ make_pair(130556, -1) , "SccCfgSts3"},
{ make_pair(130557, -1) , "SccCfgCmd2"},
{ make_pair(130558, -1) , "SccCfgSts2"},
{ make_pair(130559, -1) , "SccArraySts"},
{ make_pair(130688, -1) , "SccBattSts"},
{ make_pair(130689, -1) , "SccSts6"},
{ make_pair(130690, -1) , "SccSts5"},
{ make_pair(130691, -1) , "SccSts4"},
{ make_pair(130692, -1) , "SccSts3"},
{ make_pair(130693, -1) , "SccSts2"},
{ make_pair(130698, -1) , "BattCmd"},
{ make_pair(130699, -1) , "BattSts11"},
{ make_pair(130704, -1) , "BattSts6"},
{ make_pair(130706, -1) , "BattSts4"},
{ make_pair(130707, -1) , "BattSts3"},
{ make_pair(130708, -1) , "BattSts2"},
{ make_pair(130709, -1) , "BattSts1"},
{ make_pair(130714, -1) , "InvCfgCmd4"},
{ make_pair(130715, -1) , "InvCfgSts4"},
{ make_pair(130718, -1) , "AlarmCmd"},
{ make_pair(130719, -1) , "AlarmSts"},
{ make_pair(130723, -1) , "ChgSts2"},
{ make_pair(130724, -1) , "DcSrcCmd"},
{ make_pair(130725, -1) , "DcSrcSts11"},
{ make_pair(130733, -1) , "SccEqlzCfgCmd"},
{ make_pair(130734, -1) , "SccEqlzCfgSts"},
{ make_pair(130735, -1) , "SccEqlzSts"},
{ make_pair(130736, -1) , "SccCfgCmd"},
{ make_pair(130737, -1) , "SccCmd"},
{ make_pair(130738, -1) , "SccCfgSts"},
{ make_pair(130739, -1) , "SccSts"},
{ make_pair(130749, -1) , "InvTempSts"},
{ make_pair(130750, -1) , "ChgCfgCmd4"},
{ make_pair(130751, -1) , "ChgCfgSts4"},
{ make_pair(130759, -1) , "DcSrcSts6"},
{ make_pair(130761, -1) , "DCSrcSts4"},
{ make_pair(130762, -1) , "DiagMsg1"},
{ make_pair(130763, -1) , "ChgCfgCmd3"},
{ make_pair(130764, -1) , "ChgCfgSts3"},
{ make_pair(130765, -1) , "InvCfgCmd3"},
{ make_pair(130766, -1) , "InvCfgSts3"},
{ make_pair(130792, -1) , "InvDcSts"},
{ make_pair(130950, -1) , "ChgAcFltCfgCmd2"},
{ make_pair(130951, -1) , "ChgAcFltCfgCmd1"},
{ make_pair(130952, -1) , "ChgAcFltCfgSts2"},
{ make_pair(130953, -1) , "ChgAcFltCfgSts1"},
{ make_pair(130954, -1) , "ChgAcSts4"},
{ make_pair(130956, -1) , "InvAcFltCfgCmd1"},
{ make_pair(130958, -1) , "InvAcFltCfgSts1"},
{ make_pair(130959, -1) , "InvAcSts4"},
{ make_pair(130965, -1) , "ChgCfgCmd2"},
{ make_pair(130966, -1) , "ChgCfgSts2"},
{ make_pair(130967, -1) , "ChgEqlzCfgCmd"},
{ make_pair(130968, -1) , "ChgEqlzCfgSts"},
{ make_pair(130969, -1) , "ChgEqlzSts"},
{ make_pair(130996, -1) , "AcFltCtrlCfgCmd2"},
{ make_pair(130997, -1) , "AcFltCtrlCfgCmd1"},
{ make_pair(130998, -1) , "AcFltCtrlCfgSts2"},
{ make_pair(130999, -1) , "AcFltCtrlCfgSts1"},
{ make_pair(131007, -1) , "AGSCritCmdDcI"},
{ make_pair(131008, 1) , "AGSCritStsDcSoc"},
{ make_pair(131009, -1) , "GenDemandCmd"},
{ make_pair(131010, -1) , "GenDemandSts"},
{ make_pair(131011, -1) , "ChgStatsSts"},
{ make_pair(131012, -1) , "ChgCfgCmd1"},
{ make_pair(131013, -1) , "ChgCmd"},
{ make_pair(131014, -1) , "ChgCfgSts1"},
{ make_pair(131015, -1) , "ChgSts"},
{ make_pair(131016, -1) , "ChgAcSts3"},
{ make_pair(131017, -1) , "ChgAcSts2"},
{ make_pair(131018, -1) , "ChgAcSts1"},
{ make_pair(131019, -1) , "InvOpsSts"},
{ make_pair(131020, -1) , "InvHvDcBusSts"},
{ make_pair(131021, -1) , "InvApsSts"},
{ make_pair(131022, -1) , "InvStatsSts"},
{ make_pair(131023, -1) , "InvCfgCmd2"},
{ make_pair(131024, -1) , "InvCfgCmd1"},
{ make_pair(131025, -1) , "InvCfgSts2"},
{ make_pair(131026, -1) , "InvCfgSts1"},
{ make_pair(131027, -1) , "InvCmd"},
{ make_pair(131028, -1) , "InvSts"},
{ make_pair(131029, -1) , "InvAcSts3"},
{ make_pair(131030, -1) , "InvAcSts2"},
{ make_pair(131031, -1) , "InvAcSts1"},
{ make_pair(131032, -1) , "GenStartCfgCmd"},
{ make_pair(131033, -1) , "GenStartCfgSts"},
{ make_pair(131034, -1) , "GenCmd"},
{ make_pair(131035, -1) , "GenSts2"},
{ make_pair(131036, -1) , "GenSts1"},
{ make_pair(131064, -1) , "CommSts3"},
{ make_pair(131065, -1) , "CommSts2"},
{ make_pair(131066, -1) , "CommSts1"},
{ make_pair(131067, -1) , "DCSrcSts3"},
{ make_pair(131068, -1) , "DCSrcSts2"},
{ make_pair(131069, -1) , "DCSrcSts1"},
{ make_pair(131070, -1) , "SetSysDateTime"},
{ make_pair(131071, -1) , "SysDateTimeSts"},
{ make_pair(131008, 2) , "AgsCritStsXferAcV"},
{ make_pair(131008, 3) , "AgsCritStsDcI"},
{ make_pair(131008, 4) , "AgsCritStsDcV"},
{ make_pair(131007, 1) , "AgsCritCmdAmbTemp"},
{ make_pair(131007, 2) , "AgsCritCmdDcV"},
{ make_pair(131007, 3) , "AgsCritCmdDcSoc"},
{ make_pair(131007, 4) , "AgsCritCmdXferAcV"},
{ make_pair(131008, 5) , "AgsCritStsAmbTemp"},
};

void printall(PGN_tzRECV_DATA *ptzRecv){
if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AcFltCtrlCfgCmd1") {
    const AcFltCtrlCfgCmd1 *msg = (const AcFltCtrlCfgCmd1 *)ptzRecv->pvStruct;
    msg->Print();
}
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AcFltCtrlCfgCmd2") {
        const AcFltCtrlCfgCmd2 *msg = (const AcFltCtrlCfgCmd2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AcFltCtrlCfgSts1") {
        const AcFltCtrlCfgSts1 *msg = (const AcFltCtrlCfgSts1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AcFltCtrlCfgSts2") {
        const AcFltCtrlCfgSts2 *msg = (const AcFltCtrlCfgSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AgsCritCmdAmbTemp") {
        const AgsCritCmdAmbTemp *msg = (const AgsCritCmdAmbTemp *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AgsCritCmdDcI") {
        const AgsCritCmdDcI *msg = (const AgsCritCmdDcI *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AgsCritCmdDcSoc") {
        const AgsCritCmdDcSoc *msg = (const AgsCritCmdDcSoc *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AgsCritCmdDcV") {
        const AgsCritCmdDcV *msg = (const AgsCritCmdDcV *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AgsCritCmdXferAcV") {
        const AgsCritCmdXferAcV *msg = (const AgsCritCmdXferAcV *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AgsCritStsAmbTemp") {
        const AgsCritStsAmbTemp *msg = (const AgsCritStsAmbTemp *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AgsCritStsDcI") {
        const AgsCritStsDcI *msg = (const AgsCritStsDcI *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AgsCritStsDcSoc") {
        const AgsCritStsDcSoc *msg = (const AgsCritStsDcSoc *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AgsCritStsDcV") {
        const AgsCritStsDcV *msg = (const AgsCritStsDcV *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AgsCritStsXferAcV") {
        const AgsCritStsXferAcV *msg = (const AgsCritStsXferAcV *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AlarmCmd") {
        const AlarmCmd *msg = (const AlarmCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "AlarmSts") {
        const AlarmSts *msg = (const AlarmSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "BattCmd") {
        const BattCmd *msg = (const BattCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "BattSts1") {
        const BattSts1 *msg = (const BattSts1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "BattSts11") {
        const BattSts11 *msg = (const BattSts11 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "BattSts2") {
        const BattSts2 *msg = (const BattSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "BattSts3") {
        const BattSts3 *msg = (const BattSts3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "BattSts4") {
        const BattSts4 *msg = (const BattSts4 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "BattSts6") {
        const BattSts6 *msg = (const BattSts6 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "BattSumm") {
        const BattSumm *msg = (const BattSumm *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgAcFltCfgCmd1") {
        const ChgAcFltCfgCmd1 *msg = (const ChgAcFltCfgCmd1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgAcFltCfgCmd2") {
        const ChgAcFltCfgCmd2 *msg = (const ChgAcFltCfgCmd2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgAcFltCfgSts1") {
        const ChgAcFltCfgSts1 *msg = (const ChgAcFltCfgSts1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgAcFltCfgSts2") {
        const ChgAcFltCfgSts2 *msg = (const ChgAcFltCfgSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgAcSts1") {
        const ChgAcSts1 *msg = (const ChgAcSts1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgAcSts2") {
        const ChgAcSts2 *msg = (const ChgAcSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgAcSts3") {
        const ChgAcSts3 *msg = (const ChgAcSts3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgAcSts4") {
        const ChgAcSts4 *msg = (const ChgAcSts4 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgCfgCmd1") {
        const ChgCfgCmd1 *msg = (const ChgCfgCmd1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgCfgCmd2") {
        const ChgCfgCmd2 *msg = (const ChgCfgCmd2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgCfgCmd3") {
        const ChgCfgCmd3 *msg = (const ChgCfgCmd3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgCfgCmd4") {
        const ChgCfgCmd4 *msg = (const ChgCfgCmd4 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgCfgSts1") {
        const ChgCfgSts1 *msg = (const ChgCfgSts1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgCfgSts2") {
        const ChgCfgSts2 *msg = (const ChgCfgSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgCfgSts3") {
        const ChgCfgSts3 *msg = (const ChgCfgSts3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgCfgSts4") {
        const ChgCfgSts4 *msg = (const ChgCfgSts4 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgCmd") {
        const ChgCmd *msg = (const ChgCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgEqlzCfgCmd") {
        const ChgEqlzCfgCmd *msg = (const ChgEqlzCfgCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgEqlzCfgSts") {
        const ChgEqlzCfgSts *msg = (const ChgEqlzCfgSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgEqlzSts") {
        const ChgEqlzSts *msg = (const ChgEqlzSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgStatsSts") {
        const ChgStatsSts *msg = (const ChgStatsSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgSts") {
        const ChgSts *msg = (const ChgSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgSts2") {
        const ChgSts2 *msg = (const ChgSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ChgSts3") {
        const ChgSts3 *msg = (const ChgSts3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "CommSts1") {
        const CommSts1 *msg = (const CommSts1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "CommSts2") {
        const CommSts2 *msg = (const CommSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "CommSts3") {
        const CommSts3 *msg = (const CommSts3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "DcSrcCfgCmd3") {
        const DcSrcCfgCmd3 *msg = (const DcSrcCfgCmd3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "DcSrcCmd") {
        const DcSrcCmd *msg = (const DcSrcCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "DcSrcConnSts") {
        const DcSrcConnSts *msg = (const DcSrcConnSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "DcSrcSts1") {
        const DcSrcSts1 *msg = (const DcSrcSts1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "DcSrcSts11") {
        const DcSrcSts11 *msg = (const DcSrcSts11 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "DcSrcSts2") {
        const DcSrcSts2 *msg = (const DcSrcSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "DcSrcSts3") {
        const DcSrcSts3 *msg = (const DcSrcSts3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "DcSrcSts4") {
        const DcSrcSts4 *msg = (const DcSrcSts4 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "DcSrcSts6") {
        const DcSrcSts6 *msg = (const DcSrcSts6 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "DeviceStateSync") {
        const DeviceStateSync *msg = (const DeviceStateSync *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "DiagMsg1") {
        const DiagMsg1 *msg = (const DiagMsg1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "FileDnldBlk") {
        const FileDnldBlk *msg = (const FileDnldBlk *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "FileDnldInf") {
        const FileDnldInf *msg = (const FileDnldInf *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "FileDnldSts") {
        const FileDnldSts *msg = (const FileDnldSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "GenCmd") {
        const GenCmd *msg = (const GenCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "GenDemandCmd") {
        const GenDemandCmd *msg = (const GenDemandCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "GenDemandSts") {
        const GenDemandSts *msg = (const GenDemandSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "GenRst") {
        const GenRst *msg = (const GenRst *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "GenStartCfgCmd") {
        const GenStartCfgCmd *msg = (const GenStartCfgCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "GenStartCfgSts") {
        const GenStartCfgSts *msg = (const GenStartCfgSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "GenSts1") {
        const GenSts1 *msg = (const GenSts1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "GenSts2") {
        const GenSts2 *msg = (const GenSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InstAssign") {
        const InstAssign *msg = (const InstAssign *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InstSts") {
        const InstSts *msg = (const InstSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvAcFltCfgCmd1") {
        const InvAcFltCfgCmd1 *msg = (const InvAcFltCfgCmd1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvAcFltCfgSts1") {
        const InvAcFltCfgSts1 *msg = (const InvAcFltCfgSts1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvAcSts1") {
        const InvAcSts1 *msg = (const InvAcSts1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvAcSts2") {
        const InvAcSts2 *msg = (const InvAcSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvAcSts3") {
        const InvAcSts3 *msg = (const InvAcSts3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvAcSts4") {
        const InvAcSts4 *msg = (const InvAcSts4 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvApsSts") {
        const InvApsSts *msg = (const InvApsSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvCfgCmd1") {
        const InvCfgCmd1 *msg = (const InvCfgCmd1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvCfgCmd2") {
        const InvCfgCmd2 *msg = (const InvCfgCmd2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvCfgCmd3") {
        const InvCfgCmd3 *msg = (const InvCfgCmd3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvCfgCmd4") {
        const InvCfgCmd4 *msg = (const InvCfgCmd4 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvCfgSts1") {
        const InvCfgSts1 *msg = (const InvCfgSts1 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvCfgSts2") {
        const InvCfgSts2 *msg = (const InvCfgSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvCfgSts3") {
        const InvCfgSts3 *msg = (const InvCfgSts3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvCfgSts4") {
        const InvCfgSts4 *msg = (const InvCfgSts4 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvCmd") {
        const InvCmd *msg = (const InvCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvDcSts") {
        const InvDcSts *msg = (const InvDcSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvHvDcBusSts") {
        const InvHvDcBusSts *msg = (const InvHvDcBusSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvOpsSts") {
        const InvOpsSts *msg = (const InvOpsSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvStatsSts") {
        const InvStatsSts *msg = (const InvStatsSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvSts") {
        const InvSts *msg = (const InvSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvTempSts") {
        const InvTempSts *msg = (const InvTempSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "InvTempSts2") {
        const InvTempSts2 *msg = (const InvTempSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "IsoAck") {
        const IsoAck *msg = (const IsoAck *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "IsoAddrClaim") {
        const IsoAddrClaim *msg = (const IsoAddrClaim *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "IsoCmdAddr") {
        const IsoCmdAddr *msg = (const IsoCmdAddr *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "IsoReq") {
        const IsoReq *msg = (const IsoReq *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "IsoTpConnManAbort") {
        const IsoTpConnManAbort *msg = (const IsoTpConnManAbort *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "IsoTpConnManBam") {
        const IsoTpConnManBam *msg = (const IsoTpConnManBam *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "IsoTpConnManCts") {
        const IsoTpConnManCts *msg = (const IsoTpConnManCts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "IsoTpConnManEom") {
        const IsoTpConnManEom *msg = (const IsoTpConnManEom *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "IsoTpConnManRts") {
        const IsoTpConnManRts *msg = (const IsoTpConnManRts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "IsoTpXfer") {
        const IsoTpXfer *msg = (const IsoTpXfer *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmAcStsRms") {
        const PmAcStsRms *msg = (const PmAcStsRms *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmAcXferSwSts") {
        const PmAcXferSwSts *msg = (const PmAcXferSwSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmAssocCfg") {
        const PmAssocCfg *msg = (const PmAssocCfg *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmAssocSts") {
        const PmAssocSts *msg = (const PmAssocSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmChgSts") {
        const PmChgSts *msg = (const PmChgSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmDevMdCfg") {
        const PmDevMdCfg *msg = (const PmDevMdCfg *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmDevMdSts") {
        const PmDevMdSts *msg = (const PmDevMdSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmFxccCfgCmd") {
        const PmFxccCfgCmd *msg = (const PmFxccCfgCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmFxccCfgSts") {
        const PmFxccCfgSts *msg = (const PmFxccCfgSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmGetConfigParam") {
        const PmGetConfigParam *msg = (const PmGetConfigParam *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmGetStatusParam") {
        const PmGetStatusParam *msg = (const PmGetStatusParam *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmInvCtrlCmd") {
        const PmInvCtrlCmd *msg = (const PmInvCtrlCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmInvLdShSts") {
        const PmInvLdShSts *msg = (const PmInvLdShSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmInvSts") {
        const PmInvSts *msg = (const PmInvSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmLithionicsCmd") {
        const PmLithionicsCmd *msg = (const PmLithionicsCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmLithionicsSts") {
        const PmLithionicsSts *msg = (const PmLithionicsSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmParamAssocCfg") {
        const PmParamAssocCfg *msg = (const PmParamAssocCfg *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmParamAuxCfg") {
        const PmParamAuxCfg *msg = (const PmParamAuxCfg *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmParamAuxCfgTrigDly") {
        const PmParamAuxCfgTrigDly *msg = (const PmParamAuxCfgTrigDly *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmParamAuxCfgTrigLvl") {
        const PmParamAuxCfgTrigLvl *msg = (const PmParamAuxCfgTrigLvl *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmParamAuxSts") {
        const PmParamAuxSts *msg = (const PmParamAuxSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmParamDevMdCfg") {
        const PmParamDevMdCfg *msg = (const PmParamDevMdCfg *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmPpnNakRsp") {
        const PmPpnNakRsp *msg = (const PmPpnNakRsp *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmPpnReadCmd") {
        const PmPpnReadCmd *msg = (const PmPpnReadCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmPpnReadRsp") {
        const PmPpnReadRsp *msg = (const PmPpnReadRsp *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmPpnSessionCmd") {
        const PmPpnSessionCmd *msg = (const PmPpnSessionCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmPpnSessionRsp") {
        const PmPpnSessionRsp *msg = (const PmPpnSessionRsp *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmPpnWriteCmd") {
        const PmPpnWriteCmd *msg = (const PmPpnWriteCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmPpnWriteRsp") {
        const PmPpnWriteRsp *msg = (const PmPpnWriteRsp *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmReq") {
        const PmReq *msg = (const PmReq *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmRpcCmd") {
        const PmRpcCmd *msg = (const PmRpcCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmSetConfigParam") {
        const PmSetConfigParam *msg = (const PmSetConfigParam *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "PmSwVerSts") {
        const PmSwVerSts *msg = (const PmSwVerSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ProdIdent") {
        const ProdIdent *msg = (const ProdIdent *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "ProdInfoSts") {
        const ProdInfoSts *msg = (const ProdInfoSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccArraySts") {
        const SccArraySts *msg = (const SccArraySts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccBattSts") {
        const SccBattSts *msg = (const SccBattSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccCfgCmd") {
        const SccCfgCmd *msg = (const SccCfgCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccCfgCmd2") {
        const SccCfgCmd2 *msg = (const SccCfgCmd2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccCfgCmd3") {
        const SccCfgCmd3 *msg = (const SccCfgCmd3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccCfgCmd4") {
        const SccCfgCmd4 *msg = (const SccCfgCmd4 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccCfgCmd5") {
        const SccCfgCmd5 *msg = (const SccCfgCmd5 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccCfgSts") {
        const SccCfgSts *msg = (const SccCfgSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccCfgSts2") {
        const SccCfgSts2 *msg = (const SccCfgSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccCfgSts3") {
        const SccCfgSts3 *msg = (const SccCfgSts3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccCfgSts4") {
        const SccCfgSts4 *msg = (const SccCfgSts4 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccCfgSts5") {
        const SccCfgSts5 *msg = (const SccCfgSts5 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccCmd") {
        const SccCmd *msg = (const SccCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccEqlzCfgCmd") {
        const SccEqlzCfgCmd *msg = (const SccEqlzCfgCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccEqlzCfgSts") {
        const SccEqlzCfgSts *msg = (const SccEqlzCfgSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccEqlzSts") {
        const SccEqlzSts *msg = (const SccEqlzSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccSts") {
        const SccSts *msg = (const SccSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccSts2") {
        const SccSts2 *msg = (const SccSts2 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccSts3") {
        const SccSts3 *msg = (const SccSts3 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccSts4") {
        const SccSts4 *msg = (const SccSts4 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccSts5") {
        const SccSts5 *msg = (const SccSts5 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SccSts6") {
        const SccSts6 *msg = (const SccSts6 *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SetSysDateTime") {
        const SetSysDateTime *msg = (const SetSysDateTime *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SimpleCalibCfg") {
        const SimpleCalibCfg *msg = (const SimpleCalibCfg *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SwVerSts") {
        const SwVerSts *msg = (const SwVerSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "SysDateTimeSts") {
        const SysDateTimeSts *msg = (const SysDateTimeSts *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "VirtualTerminal") {
        const VirtualTerminal *msg = (const VirtualTerminal *)ptzRecv->pvStruct;
        msg->Print();
    }
else if(PGNTABLE[make_pair(ptzRecv->ulPgn, ptzRecv->siGrpFunc)] == "XbResetCmd") {
        const XbResetCmd *msg = (const XbResetCmd *)ptzRecv->pvStruct;
        msg->Print();
    }
}

