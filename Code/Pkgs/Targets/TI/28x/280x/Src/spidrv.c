/*==============================================================================
Copyright © 2005 Xantrex International

This file is the property of Xantrex International and shall not be reproduced,
copied, or used as the basis for the manufacture or sale of equipment without
the express written permission of Xantrex International.

FILE NAME:  spidrv.c

PURPOSE:
    Provide SPI services.

FUNCTION(S):
    SPIDRV_fnCtor           - Configure and initialize the SPI to it's default
                              parameters.
    SPIDRV_fnSecondCtor     - Secondary constructor
    SPIDRV_fnDtor           - Destroy an instance of an SPI.
    SPIDRV_fnAcquireLock    - Acquire an exclusive lock to the SPI driver
    SPIDRV_fnCheckEvent     - provide SPI un-processed event
    SPIDRV_fnCreateHandle   - Create an SPI device handle
    SPIDRV_fnDeleteHandle   - Delete an SPI device handle
    SPIDRV_fnDisInt         - Disable the tx/rx interrupt.
    SPIDRV_fnDisOvrRunInt   - Disable the rx buffer overrun interrupt.
    SPIDRV_fnDisTx          - Disable the SPI transmission.    
    SPIDRV_fnEnInt          - Enable the tx/rx interrupt.
    SPIDRV_fnEnOvrRunInt    - Enable the rx buffer overrun interrupt.
    SPIDRV_fnEnTx           - Enable the SPI transmission.
    SPIDRV_fnGetCfg         - Get the current configuration of the SPI, the
                              parameters are placed into the locations
                              indicated by the pointers being passed.    
    SPIDRV_fnRead           - Read data from the SPI buffer. No actual
                              communications occurs.    
    SPIDRV_fnReleaseLock    - Release the exclusive lock to the SPI driver
    SPIDRV_fnReset          - Reset SPI module
    SPIDRV_fnRxIsr          - events generated by the SPI.
    SPIDRV_fnSetCfg         - Set the configuration of the SPI.
    SPIDRV_fnSetCharLength  - set communication character length
    SPIDRV_fnStart          - Start SPI module
    SPIDRV_fnWrite          - Write data to the SPI. Use this fnc if you don't
                              care what is received. If you do care, use the
                              spi_fnWriteAndRead function.
    SPIDRV_fnWriteAndRead   - Write data out and then read the rx buffer.

    local:
        spidrv_fnInit               - Fast initialization of the SPI
        spidrv_fnSendDataToTxBuffer - Send data to the transmit buffer.
        spidrv_fnSignalStartTxRx    - Signal that transmit or receive is about to start.
        spidrv_fnWaitForTxRxComplete - Wait for transmit or receive to complete
        
        

NOTES:
    Ported from the TI 281x

    The SPI Driver is only responsible for shifting bits into and out
    of the SPI hardware.  It does not concern itself with enabling/disabling
    external devices.

    The SPI Driver should never be called by the application layer directly,
    it should only be called by other device drivers to make use of its
    services.  For example, the EEPROM driver; IO Driver; and possibly others
    will make calls to the SPI driver.

    Any driver which makes use of the SPI driver must use the
    SPIDRV_fnCreateHandle function to obtain a "handle" to the SPI device.
    The handle is usually created in the Ctor function of the driver which
    is intending to use the SPI device.

    The handle encapsulates all of the settings of the SPI device, like
    bit rate, clock phase, interrupt enables, etc.  In this way, each
    user of the SPI driver can maintain their own settings.
    
    Before calling any function in the SPI driver, each device driver must
    lock the SPI device for exclusive access using the SPIDRV_fnAcquireLock
    function. When the driver has finished accessing the SPI driver, it MUST
    call the SPIDRV_fnReleaseLock function to make the SPI driver available
    to other drivers.

    The general mechanism for using the SPI driver is as follows:

    1. Create an SPI Handle (in the driver constructor function)

    2. Lock the SPI Driver for exclusive access

    3. Enable or select the external device to be addressed

    4. Read or write some data to the external device

    5. Disable the external device

    6. Release the SPI Driver lock    
    
    This module has function switch enables to not link in functions that
    aren't used.  If you don't want certain functions to be linked in, 
    declare the appropriate switch to be false in you project file.       

CHANGE HISTORY:
$Log: SpiDrv.c $

    ***********************************************
    Revision: SurveyorPfrmA_New_HueyD/1
    User: HueyD     Date: 02/23/06  Time: 11:59PM
    removed unused variable

    ***********************************************
    Revision: SurveyorPfrmA_JeffF/1
    User: JeffF     Date: 02/13/06  Time: 06:59PM
    Ran the copyright updater script to bring the copyright notice on all project
    files up to date.

    ***********************************************
    Revision: SurveyorPfrmA_HueyD/1
    User: HueyD     Date: 12/09/05  Time: 01:24AM
    Removed annoying compiler warning

    ***********************************************
    Revision: SurveyorPfrmA_JosephineT/4
    User: JosephineT     Date: 08/30/05  Time: 06:40PM
    - Disable a number of functions when in loader mode.

    ***********************************************
    Revision: SurveyorPfrmA_JosephineT/3
    User: JosephineT     Date: 08/03/05  Time: 07:35PM
    - Enable Level 6 SPI interrupts in fnCtor2(), copy data in receive buffer
    to configuration structure in fnWaitForTxRxComplete() so that it works
    the same way as the interrupt service routine.

    ***********************************************
    Revision: SurveyorPfrmA_JosephineT/2
    User: JosephineT     Date: 08/03/05  Time: 05:47PM
    - Added secondary constructor to enable interrupts, added spidrv_fnSignalStartTxRx()
    and spidrv_fnWaitForTxRxComplete().

    ***********************************************
    Revision: SurveyorPfrmA_JosephineT/1
    User: JosephineT     Date: 07/28/05  Time: 08:58PM
    - Added ISR to SPITXINTA


==============================================================================*/


/*==============================================================================
                              Includes
==============================================================================*/
#include <errno.h>          // driver level error codes
#include <limits.h>         // for CHAR_BIT
#include <stdlib.h>         // for malloc
#include <string.h>         // for memset
#include "spidrv.h"         // SPI driver defines

#include "Device.h"         // TI device headers
#include "devicemacro.h"    // macros to enable PIE
#include "spiclient.h"      // for spiclient interface (externs below)
#include "sysclk.h"         // for clock speed calcs
#include "xassert.h"        // allow the use of assert( n )

/*==============================================================================
                              Defines
==============================================================================*/

// The following MIN/MAX parameters are determined by the hardware. Do not
//  change these parameters unless you are absolutely sure the hardware will
//  accept them.
//
// define the min and max size of the data packet in # of bits.
#define SPI_MIN_DATA_LENGTH         ( 1 )
#define SPI_MAX_DATA_LENGTH         ( 16 )

// define the min and max baud rate divisor.
//
// The baud rate for the SPI = (CLKOUT)/(Baud Rate prescaler + 1 )
//  where (Baud Rate Divisor)=3..127
#define SPI_MIN_BAUD_RATE_DIVISOR   ( 3 )
#define SPI_MAX_BAUD_RATE_DIVISOR   ( 127 )

#define SPIDRV_MAX_LOOP_COUNT  ( 0xFFFF )      // maximum number of counts
                                               // for receive or transmit to 
                                               // complete


/*==============================================================================
                              Function Enable Switches
==============================================================================*/

// include code for getting the configuration
#ifndef SPIDRV_GET_CFG_ENABLE
#define SPIDRV_GET_CFG_ENABLE      ( TRUE )
#endif

// include code for disabling transmitter
#ifndef SPIDRV_DIS_TX_ENABLE
#ifdef LOADER
#define SPIDRV_DIS_TX_ENABLE      ( FALSE )
#else
#define SPIDRV_DIS_TX_ENABLE      ( TRUE )
#endif
#endif

// include code for disabline the interrupt
#ifndef SPIDRV_DIS_INT_ENABLE
#ifdef LOADER
#define SPIDRV_DIS_INT_ENABLE     ( FALSE )
#else
#define SPIDRV_DIS_INT_ENABLE     ( TRUE )
#endif
#endif

// include code for enabling overrun interrupt
#ifndef SPIDRV_EN_OVR_RUN_INT_ENABLE
#ifdef LOADER
#define SPIDRV_EN_OVR_RUN_INT_ENABLE ( FALSE )
#else
#define SPIDRV_EN_OVR_RUN_INT_ENABLE ( TRUE )
#endif
#endif

// include code of disabling overrun interrupt
#ifndef SPIDRV_DIS_OVR_RUN_INT_ENABLE
#ifdef LOADER
#define SPIDRV_DIS_OVR_RUN_INT_ENABLE ( FALSE )
#else
#define SPIDRV_DIS_OVR_RUN_INT_ENABLE ( TRUE )
#endif
#endif

// include code for reset
#ifndef SPIDRV_RESET_ENABLE
#ifdef LOADER
#define SPIDRV_RESET_ENABLE ( FALSE )
#else
#define SPIDRV_RESET_ENABLE ( TRUE )
#endif
#endif

// include code for start
#ifndef SPIDRV_START_ENABLE
#ifdef LOADER
#define SPIDRV_START_ENABLE ( FALSE )
#else
#define SPIDRV_START_ENABLE ( TRUE )
#endif
#endif

// include code for check event
#ifndef SPIDRV_CHECK_EVENT_ENABLE
#ifdef LOADER
#define SPIDRV_CHECK_EVENT_ENABLE ( FALSE )
#else
#define SPIDRV_CHECK_EVENT_ENABLE ( TRUE )
#endif
#endif

// include code for write and then read
#ifndef SPIDRV_WRITE_AND_READ_ENABLE
#ifdef LOADER
#define SPIDRV_WRITE_AND_READ_ENABLE ( FALSE )
#else
#define SPIDRV_WRITE_AND_READ_ENABLE ( TRUE )
#endif
#endif

// include code for delete handle
#ifndef SPIDRV_DELETE_HANDLE_ENABLE
#ifdef LOADER
#define SPIDRV_DELETE_HANDLE_ENABLE ( FALSE )
#else
#define SPIDRV_DELETE_HANDLE_ENABLE ( TRUE )
#endif
#endif


/*==============================================================================
                              Macros
==============================================================================*/
// Put the SPI into reset mode
#define spidrv_mRESET()    ( SpiaRegs.SPICCR.bit.SPISWRESET = 0 )

// Get out the SPI of reset mode.
#define spidrv_mSTART()    ( SpiaRegs.SPICCR.bit.SPISWRESET = 1 )

// Configure the appropriate port pins so the SPI can be used.
#define spidrv_mMODULE_INIT()   DEVICE_mACCESS_EN();\
                                GpioCtrlRegs.GPAMUX2.bit.GPIO16 = 1;\
                                GpioCtrlRegs.GPAMUX2.bit.GPIO17 = 1;\
                                GpioCtrlRegs.GPAMUX2.bit.GPIO18 = 1;\
                                GpioCtrlRegs.GPAMUX2.bit.GPIO19 = 1;\
                                DEVICE_mACCESS_DIS()

// Check the the SPITEA (SPI slave transmit enable) pin to see if enabel for TX
#define spidrv_mIs_SPISTEA_LOW()    ( GpioDataRegs.GPADAT.bit.GPIO19 == 0 )

// Enable the SPI clock
#define spidrv_mCLK_ENABLE()   DEVICE_mACCESS_EN();\
                               SysCtrlRegs.PCLKCR0.bit.SPIAENCLK = 1;\
                               DEVICE_mACCESS_DIS()

// Put SPI in slave/master mode
#define spidrv_mSET_SLAVE_MODE()    ( SpiaRegs.SPICTL.bit.MASTER_SLAVE = 0 )
#define spidrv_mSET_MASTER_MODE()   ( SpiaRegs.SPICTL.bit.MASTER_SLAVE = 1 )

// Set SPI to react to rising/falling clock edge
#define spidrv_mSET_RISING_EDGE()   ( SpiaRegs.SPICCR.bit.CLKPOLARITY = 0 )
#define spidrv_mSET_FALLING_EDGE()  ( SpiaRegs.SPICCR.bit.CLKPOLARITY = 1 )

// set SPI to tx & rx in/out of clock phase
#define spidrv_mCLK_PHASE_WITHOUT_DELAY() ( SpiaRegs.SPICTL.bit.CLK_PHASE = 0 )
#define spidrv_mCLK_PHASE_WITH_DELAY()    ( SpiaRegs.SPICTL.bit.CLK_PHASE = 1 )

// Set the baud rate divisor to Prescaler
#define spidrv_mSET_BAUD_RATE_DIV( Prescaler )  ( SpiaRegs.SPIBRR = Prescaler )

// Set the CCR register
#define spidrv_mSET_CCR( CCR ) ( SpiaRegs.SPICCR.all = CCR )

// Set the CTL register
#define spidrv_mSET_CTL( CTL ) ( SpiaRegs.SPICTL.all = CTL )

// Set the char length to Lengh.
#define spidrv_mSET_CHAR_LEN( Lengh )  ( SpiaRegs.SPICCR.bit.SPICHAR = Lengh )

// Dis/En-able the rx buffer overrun interrupt
#define spidrv_mRX_OVR_RUN_INT_EN()    ( SpiaRegs.SPICTL.bit.OVERRUNINTENA = 1 )
#define spidrv_mRX_OVR_RUN_INT_DIS()   ( SpiaRegs.SPICTL.bit.OVERRUNINTENA = 0 )

// Dis/En-able the SPI tx/rx interrupt.
#define spidrv_mINT_EN()               ( SpiaRegs.SPICTL.bit.SPIINTENA = 1 )
#define spidrv_mINT_DIS()              ( SpiaRegs.SPICTL.bit.SPIINTENA = 0 )

// Dis/En-able SPI transmissions
#define spidrv_mDIS_TX()               ( SpiaRegs.SPICTL.bit.TALK = 0 )
#define spidrv_mEN_TX()                ( SpiaRegs.SPICTL.bit.TALK = 1 )

// if transmission or receive has completed
#define spidrv_mTX_RX_BUSY( )  ( SpiaRegs.SPISTS.bit.INT_FLAG == 0 )

// Read received data
#define SPIDRV_mGET_RECEIVED_DATA( ReceiveData ) ( ReceiveData = SpiaRegs.SPIRXBUF )


/*==============================================================================
                                Enums
==============================================================================*/


/*=============================================================================
                              Structures
==============================================================================*/


/*=============================================================================
                              Types
==============================================================================*/
typedef struct spidrv_zSettings
{
    SPIDRV_teCTRL_MODE      CtrlMode;
    SPIDRV_teCLK_POL        ClkPol;
    SPIDRV_teCLK_PHS        ClkPhs;
    uint16                  Length;
    uint16                  ReceiveData;
    uint16                  SPICCR;
    uint16                  SPICTL;
    uint16                  SPIBRR;
} spidrv_tzConfig;


/*==============================================================================
                           Local/Private Constants
==============================================================================*/


/*==============================================================================
                           Local/Private Variables
==============================================================================*/

// used to prevent unauthorized access
static SpiDrvHandle ActiveHandle;

// variable indication that interrupts should be used
static tucBOOL UseInterrupts = FALSE;

/*==============================================================================
                        Local/Private Function Protoypes
==============================================================================*/
static void spidrv_fnSendDataToTxBuffer( spidrv_tzConfig *ptzConfig, uint16 );
inline void spidrv_fnInit( SpiDrvHandle hSPI );
extern void ISR_fnSPIRXINTA( void );
static tuiSTATUS spidrv_fnSignalStartTxRx( void );
static tuiSTATUS spidrv_fnWaitForTxRxComplete( spidrv_tzConfig *ptzConfig );


/*==============================================================================
                           Function Definitions
==============================================================================*/

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnCtor

PURPOSE:
    constructor and Configuration.

INPUTS:
    None

OUTPUTS:
    tuiSTATUS - eSTATUS_OK : SPI driver created successfully
                eSTATUS_ERR : an error occurred creating the SPI driver

NOTES:
    None

VERSION HISTORY:

Version: 1.00  Date: Sept. 13, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: FEB-17-2005  By: Horst Maurer
    - moved EALLOW/EDIS pairs into macro defn's
    - code review changes

Version: 1.20  Date: FEB-17-2005  By: Horst Maurer
    - moved setting of SpiCreated to prevent failure on assert in setCfg fn

Version: 1.30  Date: Mar-10-2005  By: Trevor Monk
    - major architecture changes to support SPI Handles

Version: 1.40  Date: Mar-21-2005  By: John Bellini
    - Added initialization of ISR to the vector table.

Version: 1.41  Date: Mar-23-2005  By: Trevor Monk
    - updated initialization of PieVectTable

Version: 1.50  Date: May-30-2005  By: Wayland Yu
    - Customized for the Surveryor project

Version: 1.51  Date: Jul-28-2005  By: Josephine Tsen
    - Added ISR to SPITXINTA
Version: 1.52  Date: Aug-03-2005  By: Josephine Tsen
    - Do not disable SPI interrupts in this constructor. It is done in the
      the secondary constructor so that polling is used during startup.
    
*******************************************************************************/
tuiSTATUS SPIDRV_fnCtor( void )
{
    // initialize the active handle
    ActiveHandle = NULL;

    // force the SPI to the reset state before configuring it.
    spidrv_mRESET();

    // cfg the port pins to SPI functions
    spidrv_mMODULE_INIT();

    // enable the spi clock
    spidrv_mCLK_ENABLE();

    // setup the tx/rx signal synchronization
    if( SPICLIENT_fnCtor() != eSTATUS_OK )
    {
        // the SPI could not be setup so there is a serious error.
        assert( 0 );
        return( eSTATUS_ERR );
    }

    // Initialize interrupt vectors
    //
    DEVICE_mACCESS_EN();
    PieVectTable.SPIRXINTA = &ISR_fnSPIRXINTA;
    PieVectTable.SPITXINTA = &ISR_fnSPIRXINTA;
    DEVICE_mACCESS_DIS();

    // all the parameters were set without any problems so get out of reset
    // mode.
    spidrv_mSTART();

    // ensure the SPI int can be enabled.
    PieCtrlRegs.PIEIER6.bit.INTx1 = 1;      // Enable PIE Group 6, INT 1


    // Do not enable Interrupts until all CTORs have been called
    //DEVICE_mINT6_EN();

    return( eSTATUS_OK );
} // SPIDRV_fnCtor

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnCtor2

PURPOSE:
    Secondary constructor for the SPI. This function enables the SPI interrupt
    so that from now onwards, interrupts will be used to signal the completion
    of a write access via the SPI. Otherwise polling will be used.

    This function must be called after the Global Interrupts have been enabled.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS - eSTATUS_OK : SPI driver was destroyed successfully
              - eSTATUS_ERR : the SPI driver could not be destroyed

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Aug 2, 2005  By: Josephine Tsen
    - Created.
Version: 1.01  Date: Aug 2, 2005  By: Josephine Tsen
    - Enable Level 6 interrupts for all SPIs.

*******************************************************************************/
tuiSTATUS SPIDRV_fnCtor2( SpiDrvHandle hSPI )
{
    // Set Flag to indicate interrupts should be used
    UseInterrupts = TRUE;

    // Enable Level 6 interrupts for SPI
    DEVICE_mINT6_EN();

    // enable SPI interrupts
    return( SPIDRV_fnEnInt( hSPI ));

    
} // SPIDRV_fnCtor2

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnDtor

PURPOSE:
    Destroy an instance of an SPI.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS - eSTATUS_OK : SPI driver was destroyed successfully
              - eSTATUS_ERR : the SPI driver could not be destroyed

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 13, 2004  By: Yingran Duan
    - Created.

Version: 1.01  Date: Mar 11, 2005    By: Trevor Monk
    - updated comments

*******************************************************************************/
#ifdef GLBL_DTOR_EN
tuiSTATUS SPIDRV_fnDtor( void )
{
    if( SPICLIENT_fnDtor() == eSTATUS_OK )
    {
        // disable everything.
        spidrv_mRX_OVR_RUN_INT_DIS();
        spidrv_mDIS_TX();
        spidrv_mINT_DIS();
        spidrv_mRESET();

        return( eSTATUS_OK );
    }

    return( eSTATUS_ERR );
} // SPIDRV_fnDtor
#endif


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnAcquireLock

PURPOSE:
    Acquire exclusive access to the SPI driver

INPUTS:
    hSPI:      handle to the SPI instance acquiring exclusive access
    siWaitTicks: number if ticks to wait for exclusive access (see notes)

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - an exclusive lock was acquired
               eSTATUS_ERR - exclusive access to the SPI is unavailable

NOTES:
    If siWaitTicks is negative, this function will try to obtain a lock
    without blocking and return immediately if an exclusive lock is unavailable.

    If siWaitTicks is zero, this function will wait forever until a lock
    is available

    If siWaitTicks is positive, this represents the maximum number of
    system ticks to wait for exclusive access

VERSION HISTORY:

Version: 1.00  Date: Mar. 07, 2005  By: Trevor Monk
    - Created.

Version: 1.10  Date: Mar 18, 2005   By: Trevor Monk
    - Added runtime check for valid SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnAcquireLock( SpiDrvHandle hSPI,
                                sint16 siWaitTicks )
{
    assert( hSPI );

    if( hSPI == NULL )
    {
        return( eSTATUS_ERR );
    }

    // ask the SPICLIENT to handle exclusive access for us
    if( SPICLIENT_fnAcquireLock( siWaitTicks ) == eSTATUS_OK )
    {
        ActiveHandle = hSPI;

        // since we have just got a lock, lets assume that the SPI needs to be
        // initialized with our settings
        spidrv_fnInit( hSPI );

        return eSTATUS_OK;
    }

    // we were unable to lock the SPIDRV for exclusive access
    return eSTATUS_ERR;
} // SPIDRV_fnAcquireLock


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnCheckEvent

PURPOSE:
    provide SPI un-processed event

INPUTS:
    hSPI:   handle to the SPI instance to be queried

OUTPUTS:
    SPIDRV_teEVENT: one of:
        SPIDRV_eNONE - no event has occurred
        SPIDRV_eRX_OVERRUN - a received overrun event has occurred
        SPIDRV_eRX_FULL - an RX buffer full event has occurred
        SPIDRV_eTX_FULL - a TX buffer full event has occurred

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 20, 2004   By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005     By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
#if ( SPIDRV_CHECK_EVENT_ENABLE == TRUE )
SPIDRV_teEVENT SPIDRV_fnCheckEvent( SpiDrvHandle hSPI )
{
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( SPIDRV_eNONE );
    }

    //check whether there is an receiver overrun
    if( SpiaRegs.SPISTS.bit.OVERRUN_FLAG == 1 )
    {
        return( SPIDRV_eRX_OVERRUN );
    }

    //check whether there is an Receiving message
    else if( SpiaRegs.SPISTS.bit.INT_FLAG == 1 )
    {
        return( SPIDRV_eRX_FULL );
    }

    //check whether there is an transmission message need to send
    else if( SpiaRegs.SPISTS.bit.BUFFULL_FLAG == 1 )
    {
        return( SPIDRV_eTX_FULL );
    }

    //no other cases
    else
    {
        return( SPIDRV_eNONE );
    }
} // SPIDRV_fnCheckEvent
#endif // #if ( SPIDRV_CHECK_EVENT_ENABLE == TRUE )


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnCreateHandle()

PURPOSE:
    Creates a new SPI driver handle.

INPUTS:
    none

OUTPUTS:
    SpiDrvHandle - a newly created SPI driver handle

NOTES:
    This function is used to generate an SPI handle which must be used to
    gain access any other function in this module (with the exception of the
    creator and destructor functions).

    It is the callers responsibility to release the heap memory used by the
    handle by calling SPIDRV_fnDeleteHandle when they are finished with the
    handle.

    If a memory allocation failure occurs, this function will return NULL

VERSION HISTORY:

Version: 1.00  Date: Mar. 07, 2005  By: Trevor Monk
    - Created.

*******************************************************************************/
SpiDrvHandle SPIDRV_fnCreateHandle()
{
#ifdef LOADER
static    spidrv_tzConfig tzEedrv_Config;
#endif
          spidrv_tzConfig *ptzConfig;

#ifdef LOADER
    ptzConfig = &tzEedrv_Config;
#else
    // allocate an SPI driver structure from the heap
    ptzConfig = (spidrv_tzConfig *)malloc(sizeof(spidrv_tzConfig));
    if (ptzConfig == NULL)
    {
        return NULL;
    }
#endif
    // clear the SPI structure to zero
    memset(ptzConfig, 0, sizeof(spidrv_tzConfig));

    return (SpiDrvHandle)ptzConfig;
} // SPIDRV_fnCreateHandle


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnDeleteHandle()

PURPOSE:
    Deletes an SPI driver handle

INPUTS:
    hSPI: the SPI handle to delete

OUTPUTS:
    tuiSTATUS : eSTATUS_OK - hSPI deleted successfully
                eSTATUS_ERR - invalid handle specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Mar. 08, 2005  By: Trevor Monk
    - Created.

*******************************************************************************/
#if ( SPIDRV_DELETE_HANDLE_ENABLE == TRUE )
tuiSTATUS SPIDRV_fnDeleteHandle( SpiDrvHandle hSPI )
{
    if( hSPI != NULL )
    {
        free( hSPI );
        return( eSTATUS_OK );
    }

    return( eSTATUS_ERR );
} // SPIDRV_fnDeleteHandle
#endif // #if ( SPIDRV_DELETE_HANDLE_ENABLE == TRUE )


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnDisInt

PURPOSE:
    Disable the SPI interrupt.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI interrupt was disabled successfully
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
#if ( SPIDRV_DIS_INT_ENABLE == TRUE )
tuiSTATUS SPIDRV_fnDisInt( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mINT_DIS();

    // store the updated SPICTL register
    ptzConfig->SPICTL = SpiaRegs.SPICTL.all;

    return eSTATUS_OK;
} // SPIDRV_fnDisInt
#endif // #if ( SPIDRV_DIS_INT_ENABLE == TRUE )


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnDisOvrRunInt

PURPOSE:
    Disable the SPI receive overrun interrupt.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI overrun interrupt was disabled successfully
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
#if ( SPIDRV_DIS_OVR_RUN_INT_ENABLE == TRUE )
tuiSTATUS SPIDRV_fnDisOvrRunInt( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mRX_OVR_RUN_INT_DIS();

    // store the updated SPICTL register
    ptzConfig->SPICTL = SpiaRegs.SPICTL.all;

    return( eSTATUS_OK );
} // SPIDRV_fnDisOvrRunInt
#endif 


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnDisTx

PURPOSE:
    Disable the SPI tx.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI transmitter was disabled successfully
               eSTATUS_ERR - an invalid handle was specified
NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
#if ( SPIDRV_DIS_TX_ENABLE == TRUE )
tuiSTATUS SPIDRV_fnDisTx( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mDIS_TX();

    // store the updated SPICTL register
    ptzConfig->SPICTL = SpiaRegs.SPICTL.all;

    return( eSTATUS_OK );
} // SPIDRV_fnDisTx
#endif // #if ( SPIDRV_DIS_TX_ENABLE == TRUE )


/*******************************************************************************

FUNCTION NAME:
    SPI_fnEnInt

PURPOSE:
    Enable the SPI interrupt.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI interrupt was enabled successfully
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnEnInt( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mINT_EN();

    // store the updated SPICTL register
    ptzConfig->SPICTL = SpiaRegs.SPICTL.all;

    return( eSTATUS_OK );
} // SPIDRV_fnEnInt


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnEnOvrRunInt

PURPOSE:
    Enable the SPI receive overrun interrupt.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI overrun interrupt was enabled successfully
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
#if ( SPIDRV_EN_OVR_RUN_INT_ENABLE == TRUE )
tuiSTATUS SPIDRV_fnEnOvrRunInt( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mRX_OVR_RUN_INT_EN();

    // store the updated SPICTL register
    ptzConfig->SPICTL = SpiaRegs.SPICTL.all;

    return eSTATUS_OK;
} // SPIDRV_fnEnOvrRunInt
#endif // #if ( SPIDRV_EN_OVR_RUN_INT_ENABLE == TRUE )


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnEnTx

PURPOSE:
    Enable the SPI Tx.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI transmitter was enabled successfully
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnEnTx( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mEN_TX();

    // store the updated SPICTL register
    ptzConfig->SPICTL = SpiaRegs.SPICTL.all;

    return( eSTATUS_OK );
} // SPIDRV_fnEnTx


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnGetCfg

PURPOSE:
    Get the current configuration of the SPI, the parameters are placed into the
    locations indicated by the pointers being passed.

INPUTS:
    hSPI:    handle to the SPI instance to be queried
    *CtrlMode: slave or master mode
    *ClkPol:   clock polarity
    *ClkPhs:   clock phase
    *puiBitRate: SPI bit rate (bits/sec)
    *puiLength:  Character length

OUTPUTS:
    None.

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 14, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
#if( SPIDRV_GET_CFG_ENABLE == TRUE )
void SPIDRV_fnGetCfg( SpiDrvHandle hSPI,
                      SPIDRV_teCTRL_MODE *CtrlMode,
                      SPIDRV_teCLK_POL   *ClkPol,
                      SPIDRV_teCLK_PHS   *ClkPhs,
                      uint32             *puiBitRate,
                      uint16             *puiLength )
{
    spidrv_tzConfig *ptzConfig = ( spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( hSPI );
    assert( CtrlMode );
    assert( ClkPol );
    assert( ClkPhs );
    assert( puiBitRate );
    assert( puiLength );

    *CtrlMode = ptzConfig->CtrlMode;
    *ClkPol = ptzConfig->ClkPol;
    *ClkPhs = ptzConfig->ClkPhs;
    *puiBitRate = SYSCLK_fnGetLoSpeedPeriphClk() / ( ptzConfig->SPIBRR + 1 );
    *puiLength = ptzConfig->Length;

} // SPIDRV_fnGetCfg
#endif


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnRead

PURPOSE:
    Read data from the SPI buffer. Transmits 0x0000

INPUTS:
    hSPI:   handle to the SPI instance to be queried
    puiRxData: a pointer to a buffer where the received data will be stored

OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 14, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: FEB-17-2005  By: Horst Maurer
    - removed local variable for tuiSTATUS return value
    - code review changes

Version: 1.11  Date: FEB-17-2005  By: Horst Maurer
    - restored local variable for tuiSTATUS to allow macros to work

Version: 1.20  Date: Mar 08, 2005 By: Trevor Monk
    - modified to use SPI handle
    - fixed return status OK bug

Version: 1.21  Date: Aug 3, 2005  By: Josephine Tsen
    - Pass in configuration pointer to spidrv_fnWaitForTxRxComplete() so that
      the receive data can be copied from to the SPI receive buffer into this
      structure.
*******************************************************************************/
tuiSTATUS SPIDRV_fnRead( SpiDrvHandle hSPI,
                         uint16 *puiRxData )
{    
//    tuiSTATUS tuiStatus = eSTATUS_OK;
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( puiRxData );
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    // signal that the Tx/Rx is starting
    if( spidrv_fnSignalStartTxRx() != eSTATUS_OK )
    {
        return( eSTATUS_ERR );
    }

    // send dummy data to generate a clock to read data from spi
    spidrv_fnSendDataToTxBuffer( ptzConfig, 0x0000 );

    // If this func doesn't get the completed tx/rx signal within a certain
    // amount of time, it means that the ISR was not called in time.
    if( spidrv_fnWaitForTxRxComplete( ptzConfig ) == eSTATUS_OK )
    {
        *puiRxData = ptzConfig->ReceiveData;
    }
    else
    {
        return( eSTATUS_ERR );
    }

    return( eSTATUS_OK );
} // SPIDRV_fnRead


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnReleaseLock

PURPOSE:
    Release exclusive access to the SPI driver

INPUTS:
    hSPI: handle to the device releasing exclusive access

OUTPUTS:
    tuiSTATUS : eSTATUS_OK - the exclusive lock was successfully released
                eSTATUS_ERR - an invalid SPI driver handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Mar. 07, 2005  By: Trevor Monk
    - Created.

*******************************************************************************/
tuiSTATUS SPIDRV_fnReleaseLock( SpiDrvHandle hSPI )
{
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    // ask the SPICLIENT to handle exclusive access for us
    SPICLIENT_fnReleaseLock();

    return eSTATUS_OK;
} // SPIDRV_fnReleaseLock


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnReset

PURPOSE:
    Reset SPI module

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI was put into reset mode
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
#if ( SPIDRV_RESET_ENABLE == TRUE )
tuiSTATUS SPIDRV_fnReset( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mRESET();

    // store the updated SPICCR register
    ptzConfig->SPICCR = SpiaRegs.SPICCR.all;

    return( eSTATUS_OK );
} // SPIDRV_fnReset
#endif


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnRxIsr

PURPOSE:
    SpiDrvHandle events generated by the SPI.

INPUTS:
    none

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 20, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: FEB-21-2005  By: Horst Maurer
    - removed IER bit setting/clearing; IER control done in asm isr

Version: 1.20  Date: Mar 08 2005  By: Trevor Monk
    - modified to use the SPI handle

*******************************************************************************/
void SPIDRV_fnRxIsr( void )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)ActiveHandle;

    // read the data in the rx buffer to clear the interrupt flag
    if ( ptzConfig )
        SPIDRV_mGET_RECEIVED_DATA( ptzConfig->ReceiveData );

    // signal that the tx/rx is complete
    SPICLIENT_fnTxRxComplete();

    PieCtrlRegs.PIEACK.bit.ACK6 = 1;        // Issue PIE ACK
} // SPIDRV_fnRxIsr


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnSetCfg

PURPOSE:
    Set the configuration of the SPI.

INPUTS:
    hSPI:       handle to the SPI instance to be modified
    CtrlMode:   slave or master mode
    ClkPol:     clock polarity
    ClkPhs:     clock phase
    uiBitRate:  requested serial communication rate (bits/sec)
    uiLength:   Character length

OUTPUTS:
    tuiSTATUS - eSTATUS_OK : the SPI configuration was set
                eSTATUS_ERR : an invalid SPI driver handle or configuration
                              option was specified

NOTES:
    None:

VERSION HISTORY:

Version: 1.00  Date: Sept. 27, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: FEB-17-2005  By: Horst Maurer
    - merged local spidrv_fnSetCfgReg contents into here
    - added returns to default cases
    - code review changes

Version: 1.20  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle
    - changed prescalar argument to clock frequency

*******************************************************************************/
tuiSTATUS SPIDRV_fnSetCfg( SpiDrvHandle hSPI,
                           SPIDRV_teCTRL_MODE CtrlMode,
                           SPIDRV_teCLK_POL   ClkPol,
                           SPIDRV_teCLK_PHS   ClkPhs,
                           uint32             uiBitRate,
                           uint16             uiLength )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;
    uint16 Prescaler;

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    if (ptzConfig != NULL)
    {
        // force the SPI to the reset state before configuring it.
        spidrv_mRESET();

        // configure the control mode
        switch( CtrlMode )
        {
            case SPIDRV_eSLAVE:
                spidrv_mSET_SLAVE_MODE();
                break;

            case SPIDRV_eMASTER:
                spidrv_mSET_MASTER_MODE();
                break;

            // an invalid control mode was passed to this function, set error
            //  and leave.
            default:
                assert( 0 );
                return( eSTATUS_ERR );
        }

        // update setting variable
        ptzConfig->CtrlMode = CtrlMode;

        // configure the clock polarity
        switch( ClkPol )
        {
            case SPIDRV_eRISING_EDGE:
                spidrv_mSET_RISING_EDGE();
                break;

            case SPIDRV_eFALLING_EDGE:
                spidrv_mSET_FALLING_EDGE();
                break;

            // an invalid clock polarity was passed to this function, set error
            default:
                assert( 0 );
                return( eSTATUS_ERR );
        }

        // update setting variable
        ptzConfig->ClkPol = ClkPol;

        // configure the clock phase
        switch( ClkPhs )
        {
            case SPIDRV_eWITHOUT_DELAY:
                spidrv_mCLK_PHASE_WITHOUT_DELAY();
                break;

            case SPIDRV_eWITH_DELAY:
                spidrv_mCLK_PHASE_WITH_DELAY();
                break;

            // an invalid clock phase was passed to this function, set error
            default:
                assert( 0 );
                return( eSTATUS_ERR );
        }

        // update setting variable
        ptzConfig->ClkPhs = ClkPhs;

        // calculate the pre-scalar based on the requested clock frequency
        Prescaler = ( SYSCLK_fnGetLoSpeedPeriphClk() / uiBitRate ) - 1;

        // only set the baud rate divisor if it is within acceptable parameters
        assert( Prescaler >= SPI_MIN_BAUD_RATE_DIVISOR );
        assert( Prescaler <= SPI_MAX_BAUD_RATE_DIVISOR );

        // set the baud rate divisor
        spidrv_mSET_BAUD_RATE_DIV( Prescaler );

        //check Length setting
        assert( uiLength >= SPI_MIN_DATA_LENGTH );
        assert( uiLength <= SPI_MAX_DATA_LENGTH );

        //set charactor length
        spidrv_mSET_CHAR_LEN( uiLength - 1 );
        ptzConfig->Length = uiLength;

        // get copies of the SPI registers for fast configuration later
        ptzConfig->SPIBRR = SpiaRegs.SPIBRR;
        ptzConfig->SPICTL = SpiaRegs.SPICTL.all;
        ptzConfig->SPICCR = SpiaRegs.SPICCR.all;

        // all the parameters were set without any problems so get out of
        // the reset mode.
        spidrv_mSTART();

        return eSTATUS_OK;
    }
    else
    {
        // an invalid handle was specified, so abort
        return eSTATUS_ERR;
    }
} // SPIDRV_fnSetCfg


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnSetCharLength

PURPOSE:
    Set character length for SPI

INPUTS:
    hSPI:       handle to the SPI instance to be modified
    uiLength:   Character length

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - character length updated
               eSTATUS_ERR  - an invalid SPI driver handle was specified
                            - an invalid length setting was specified

NOTES:
    None

VERSION HISTORY:

Version: 1.00  Date:Oct. 4, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005 By: Trevor Monk
    - modified to use SPI handle

Version: 1.11  Date: Apr 19, 2005 By: Trevor Monk
    - moved asserts inside "if" statement (code review changes)
    
*******************************************************************************/
tuiSTATUS SPIDRV_fnSetCharLength( SpiDrvHandle hSPI,
                                  uint16 uiLength )
{
    spidrv_tzConfig *ptzConfig = ( spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    // check length setting
    if( ( uiLength < SPI_MIN_DATA_LENGTH ) ||
        ( uiLength > SPI_MAX_DATA_LENGTH ) )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    //set charactor length
    spidrv_mSET_CHAR_LEN( uiLength - 1 );

    //update setting variable
    ptzConfig->Length = uiLength;

    return( eSTATUS_OK );
} // SPIDRV_fnSetCharLength


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnStart

PURPOSE:
    Start SPI operation.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI was started successfully
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
#if ( SPIDRV_START_ENABLE == TRUE )
tuiSTATUS SPIDRV_fnStart( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mSTART();

    // store the updated SPICCR register
    ptzConfig->SPICCR = SpiaRegs.SPICCR.all;

    return( eSTATUS_OK );
} // SPIDRV_fnStart
#endif // #if ( SPIDRV_START_ENABLE == TRUE )


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnWrite

PURPOSE:
    Write data to the SPI. Use this fnc if you don't care what is received. If
    you do care, use the SPIDRV_fnWriteAndRead function.

INPUTS:
    hSPI:       handle to the SPI instance to be modified
    uiTxData:   the data to be sent

OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 14, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

Version: 1.`11  Date: Aug 3, 2005  By: Josephine Tsen
    - Pass in configuration pointer to spidrv_fnWaitForTxRxComplete() so that
      the receive data can be copied from to the SPI receive buffer into this
      structure.

*******************************************************************************/
tuiSTATUS SPIDRV_fnWrite( SpiDrvHandle hSPI,
                          uint16 uiTxData )
{
    tuiSTATUS tuiStatus = eSTATUS_OK;   // assume everything is ok upon entry
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    // signal that the Tx/Rx is starting
    if( spidrv_fnSignalStartTxRx() != eSTATUS_OK )
    {
        return( eSTATUS_ERR );
    }

    // if this SPI is the master,
    if( ptzConfig->CtrlMode == SPIDRV_eMASTER )
    {
        spidrv_fnSendDataToTxBuffer( ptzConfig, 
                                     uiTxData );

        tuiStatus = spidrv_fnWaitForTxRxComplete( ptzConfig );
   }

    // if the SPI is in slave mode and the SPISTE pin is low, it's ok
    //  to xmit make sure this io is set for SPI model use
    else if( ( ptzConfig->CtrlMode == SPIDRV_eSLAVE ) &&
             ( spidrv_mIs_SPISTEA_LOW() ) )
    {
        spidrv_fnSendDataToTxBuffer( ptzConfig, 
                                     uiTxData );

        tuiStatus = spidrv_fnWaitForTxRxComplete( ptzConfig );
    }
    else
    {
       // the SPI is not configured correctly so set an error
       assert( 0 );
       mWRITE_STATUS_AND_ERRNO( SPIDRV_eERRNO_WRITE );
    }

    return( tuiStatus );
} // SPIDRV_fnWrite


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnWriteAndRead

PURPOSE:
    Write data out and then read the rx buffer.

INPUTS:
    hSPI:       handle to the SPI instance to be modified
    uiTxData:   the data to be sent
    puiRxData:  a pointer to a buffer where the received data will be stored

OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 20, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
#if ( SPIDRV_WRITE_AND_READ_ENABLE == TRUE )
tuiSTATUS SPIDRV_fnWriteAndRead( SpiDrvHandle hSPI,
                                 uint16 uiTxData,
                                 uint16 *puiRxData )
{
    tuiSTATUS tuiStatus = eSTATUS_OK; // assume everything is ok upon entry
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    assert( hSPI );

    // only run the function if the ctor was called
    assert( puiRxData );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    //send out transmission data
    tuiStatus = SPIDRV_fnWrite( hSPI, 
                                uiTxData );

    //get received data
    if( tuiStatus == eSTATUS_OK )
    {
        SPIDRV_mGET_RECEIVED_DATA( *puiRxData );

        if ( NULL != ptzConfig )
        {
            SPIDRV_mGET_RECEIVED_DATA( ptzConfig->ReceiveData );
        }
    }

    return( tuiStatus );
} // SPIDRV_fnWriteAndRead
#endif // #if ( SPIDRV_WRITE_AND_READ_ENABLE == TRUE )


/*******************************************************************************

FUNCTION NAME:
    spidrv_fnInit

PURPOSE:
    Fast initialization of the SPI hardware

INPUTS:
    hSPI:   handle to the SPI instance containing the new configuration

OUTPUTS:
    None

NOTES:
    - SPIDRV_fnSetCfg must have been called before this function, since
      this function uses the register values which were set up in
      SPIDRV_fnSetCfg

VERSION HISTORY:

Version: 1.00  Date: Mar. 08, 2005  By: Trevor Monk
    - Created.

*******************************************************************************/
inline void spidrv_fnInit( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = ( spidrv_tzConfig *) hSPI;

    // force the SPI to the reset state before configuring it.
    spidrv_mRESET();

    // Set the baud rate divisor to Prescaler
    spidrv_mSET_BAUD_RATE_DIV( ptzConfig->SPIBRR );

    // Set the CTL register
    spidrv_mSET_CTL( ptzConfig->SPICTL );

    // Set the CCR register
    spidrv_mSET_CCR( (uchar8)ptzConfig->SPICCR );

    // all the parameters have been set so get out of the reset mode
    spidrv_mSTART();
} // spidrv_fnInit


/*******************************************************************************

FUNCTION NAME:
    spidrv_fnSendDataToTxBuffer

PURPOSE:
    Send data to the transmit buffer.

INPUTS:
    ptzConfig:   pointer to the config data for the SPI device
    TxData:      data to be transmitted via the SPI device

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 20, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
static void spidrv_fnSendDataToTxBuffer( spidrv_tzConfig *ptzConfig,
                                         uint16 uiTxData )
{
    // data must be left justified in the TX buf so shift the data an
    //  appropriate number of spaces.
    SpiaRegs.SPITXBUF = uiTxData << ( SPI_MAX_DATA_LENGTH - ptzConfig->Length );
}

/*******************************************************************************

FUNCTION NAME:
    spidrv_fnSignalStartTxRx

PURPOSE:
    Signal that transmit or receive is about to start. This is a wrapper around
    the SPICLIENT function that relies on interrupts to signal that the SPI access
    has completed.

    This function ensures that interrupts have been properly enabled before
    it calls the SPICLIENT function. Otherwise it does nothing.

INPUTS:
    none
    
OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Aug 2, 2005  By: Josephine Tsen
    - Created.
Version: 01.01    Date: 08-Dec-2005    By: Huey Duong
    - Removed annoying compiler warning
*******************************************************************************/
static tuiSTATUS spidrv_fnSignalStartTxRx( void )
{
   if( TRUE == UseInterrupts )
   {
        // signal that the Tx/Rx is starting
        if( SPICLIENT_fnSignalStartTxRx() != eSTATUS_OK )
        {
            errno = SPIDRV_eERRNO_CHNL_BUSY;
            return( eSTATUS_ERR );
        }
    }

    return( eSTATUS_OK );
} //spidrv_fnSignalStartTxRx

/*******************************************************************************

FUNCTION NAME:
    spidrv_fnWaitForTxRxComplete

PURPOSE:
    Wait for transmit or receive to complete. This is a wrapper around
    the SPICLIENT function that relies on interrupts to signal that the SPI access
    has completed.

    This function ensures that interrupts have been properly enabled before
    it calls the SPICLIENT function. Otherwise it polls the interrupt bit.

INPUTS:
    ptzConfig:   pointer to the config data for the SPI device

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Aug 2, 2005  By: Josephine Tsen
    - Create
Version: 1.01  Date: Aug 2, 2005  By: Josephine Tsen
    - Pass in pointer to configuration structure and copy data from SPI receive
      buffer into this structure.

*******************************************************************************/
static tuiSTATUS spidrv_fnWaitForTxRxComplete( spidrv_tzConfig *ptzConfig )
{
    uint16             LoopCnt;
    tuiSTATUS          tuiStatus = eSTATUS_ERR;
    
    if( TRUE == UseInterrupts )
    {
        // if the tx/rx has not been signalled as completed, then it's an error
        tuiStatus = SPICLIENT_fnWaitForTxRxComplete();
    }
    else
    {   
        LoopCnt = 0;
        
        // keep looping until sending and receiving has been completed
        while( spidrv_mTX_RX_BUSY() == TRUE )
        {
        
            // keep a counter because we don't want to be in an infinite loop
            // if data doesn't transmit or receive for some reason
            // a maximum loop count is specified so that there should be
            // more than enought time under normal circumstances for the data to
            // arrive
            LoopCnt++;
            if( LoopCnt == SPIDRV_MAX_LOOP_COUNT )
            {
                assert( 0 );
          
                // we have timed out, assume that the data didn't go through 
                return( eSTATUS_ERR );
            }
        }

        // Read receive buffer to clear interrupt bit
        SPIDRV_mGET_RECEIVED_DATA( ptzConfig->ReceiveData );
        
        tuiStatus = eSTATUS_OK;
    }
    
    return( tuiStatus );
 } // spidrv_fnWaitForTxRxComplete

