/*==============================================================================
Copyright 2005 Xantrex International.  All rights reserved.

This source file is proprietary to Xantrex International and protected by
copyright. The reproduction, in whole or in part, by anyone without the written
approval of Xantrex is prohibited.

FILE NAME:  spidrv.c

PURPOSE:
    Provide SPI services.

FUNCTION(S):
    SPIDRV_fnCtor           - Configure and initialize the SPI to it's default
                              parameters.
    SPIDRV_fnDtor           - Destroy an instance of an SPI.
    SPIDRV_fnAcquireLock    - Acquire an exclusive lock to the SPI driver
    SPIDRV_fnReleaseLock    - Release the exclusive lock to the SPI driver
    SPIDRV_fnCreateHandle   - Create an SPI device handle
    SPIDRV_fnDeleteHandle   - Delete an SPI device handle
    SPIDRV_fnSetCfg         - Set the configuration of the SPI.
    SPIDRV_fnGetCfg         - Get the current configuration of the SPI, the
                              parameters are placed into the locations
                              indicated by the pointers being passed.
    SPIDRV_fnSetCharLength  - set communication character length
    SPIDRV_fnRead           - Read data from the SPI buffer. No actual
                              communications occurs.
    SPIDRV_fnWrite          - Write data to the SPI. Use this fnc if you don't
                              care what is received. If you do care, use the
                              spi_fnWriteAndRead function.
    SPIDRV_fnWriteAndRead   - Write data out and then read the rx buffer.
    SPIDRV_fnEnTx           - Enable the SPI transmission.
    SPIDRV_fnDisTx          - Disable the SPI transmission.
    SPIDRV_fnEnInt          - Enable the tx/rx interrupt.
    SPIDRV_fnDisInt         - Disable the tx/rx interrupt.
    SPIDRV_fnEnOvrRunInt    - Enable the rx buffer overrun interrupt.
    SPIDRV_fnDisOvrRunInt   - Disable the rx buffer overrun interrupt.
    SPIDRV_fnReset          - Reset SPI module
    SPIDRV_fnStart          - Start SPI module
    SPIDRV_fnCheckEvent     - provide SPI un-processed event
    SPIDRV_fnRxISR          - events generated by the SPI.


    local:
        spidrv_fnSendDataToTxBuffer - Send data to the transmit buffer.
        spidrv_fnInit               - Fast initialization of the SPI

NOTES:
    The SPI Driver is only responsible for shifting bits into and out
    of the SPI hardware.  It does not concern itself with enabling/disabling
    external devices.

    The SPI Driver should never be called by the application layer directly,
    it should only be called by other device drivers to make use of its
    services.  For example, the EEPROM driver; IO Driver; and possibly others
    will make calls to the SPI driver.

    Any driver which makes use of the SPI driver must use the
    SPIDRV_fnCreateHandle function to obtain a "handle" to the SPI device.
    The handle is usually created in the Ctor function of the driver which
    is intending to use the SPI device.

    The handle encapsulates all of the settings of the SPI device, like
    bit rate, clock phase, interrupt enables, etc.  In this way, each
    user of the SPI driver can maintain their own settings.

    Before calling any function in the SPI driver, each device driver must
    lock the SPI device for exclusive access using the SPIDRV_fnAcquireLock
    function. When the driver has finished accessing the SPI driver, it MUST
    call the SPIDRV_fnReleaseLock function to make the SPI driver available
    to other drivers.

    The general mechanism for using the SPI driver is as follows:

    1. Create an SPI Handle (in the driver constructor function)

    2. Lock the SPI Driver for exclusive access

    3. Enable or select the external device to be addressed

    4. Read or write some data to the external device

    5. Disable the external device

    6. Release the SPI Driver lock

CHANGE HISTORY:
$Log: spidrv.c $

    ***********************************************
    Revision: NovaPfrmB_JohnB/2
    User: JohnB     Date: 03/22/05  Time: 07:38PM
    Added compile time switch for building the Dtor (default is don't build
    it).

    ***********************************************
    Revision: NovaPfrmB_JohnB/1
    User: JohnB     Date: 03/22/05  Time: 12:55AM
    Update ISR setup.  Each driver now writes to the Pie vector table, the
    address of the ISR is cares about.

    Updated Main to call the default ISR copying.

    ***********************************************
    Revision: NovaPfrmB_TrevorM/2
    User: TrevorM     Date: 03/19/05  Time: 12:48AM
    Added run-time check for valid SPI handle

   ***********************************************
   Revision: NovaPfrmB_TrevorM/1
   User: TrevorM     Date: 03/11/05  Time: 07:42PM
   Modified to support SPI driver handles and exclusive access modes

    ***********************************************
    Revision: NovaPfrmB_Local_HorstM/5
    User: HorstM     Date: 02/22/05  Time: 11:30PM
    renamed and trimmed isr



    ***********************************************
    Revision: NovaPfrmB_Local_HorstM/4
    User: HorstM     Date: 02/22/05  Time: 06:33PM
    removed IER bit setting/clearing - IER control done in asm isr; fixed bug with
    static 'used' flag


    ***********************************************
    Revision: NovaPfrmB_Local_HorstM/3
    User: HorstM     Date: 02/18/05  Time: 01:04AM
    restored local variable for tuiSTATUS to allow macros to work


    ***********************************************
    Revision: NovaPfrmB_Local_HorstM/2
    User: HorstM     Date: 02/17/05  Time: 07:20PM
    code review changes


    ***********************************************
    Revision: NovaPfrmB_Local_HorstM/1
    User: HorstM     Date: 02/14/05  Time: 05:41PM
    added interrupt enabling/disabling in isr


    ***********************************************
    Revision: NovaPfrmB_BaldeeshK/1
    User: BaldeeshK     Date: 12/08/04  Time: 05:01PM
    - Initial version for Accurev



==============================================================================*/


/*==============================================================================
                              Includes
==============================================================================*/
#include <errno.h>          // driver level error codes
#include <limits.h>         // for CHAR_BIT
#include <stdlib.h>         // for malloc
#include <string.h>         // for memset
#include "spiclient.h"      // for spiclient interface (externs below)
#include "xassert.h"        // allow the use of assert( n )
#include "Device.h"         // TI device headers
#include "devicemacro.h"    // macros to enable PIE
#include "sysclk.h"         // for clock speed calcs
#include "spidrv.h"         // SPI driver defines

/*==============================================================================
                              Defines
==============================================================================*/

// The following MIN/MAX parameters are determined by the hardware. Do not
//  change these parameters unless you are absolutely sure the hardware will
//  accept them.
//
// define the min and max size of the data packet in # of bits.
#define SPI_MIN_DATA_LENGTH         ( 1 )
#define SPI_MAX_DATA_LENGTH         ( 16 )

// define the min and max baud rate divisor.
//
// The baud rate for the SPI = (CLKOUT)/(Baud Rate prescaler + 1 )
//  where (Baud Rate Divisor)=3..127
#define SPI_MIN_BAUD_RATE_DIVISOR   ( 3 )
#define SPI_MAX_BAUD_RATE_DIVISOR   ( 127 )

#define SPIDRV_ACTIVE_LOCK          ( 13123 )

/*==============================================================================
                              Macros
==============================================================================*/
// Put the SPI into reset mode
#define spidrv_mRESET()    ( SpiaRegs.SPICCR.bit.SPISWRESET = 0 )

// Get out the SPI of reset mode.
#define spidrv_mSTART()    ( SpiaRegs.SPICCR.bit.SPISWRESET = 1 )

// Configure the appropriate port pins so the SPI can be used.
#define spidrv_mMODULE_INIT()   EALLOW;\
                                GpioMuxRegs.GPFMUX.bit.SPISIMOA_GPIOF0 = 1;\
                                GpioMuxRegs.GPFMUX.bit.SPISOMIA_GPIOF1 = 1;\
                                GpioMuxRegs.GPFMUX.bit.SPICLKA_GPIOF2 = 1;\
                                GpioMuxRegs.GPFMUX.bit.SPISTEA_GPIOF3 = 1;\
                                EDIS

// Enable the SPI clock
#define spidrv_mCLK_ENABLE()   EALLOW;\
                               SysCtrlRegs.PCLKCR.bit.SPIENCLK = 1;\
                               EDIS

// Put SPI in slave/master mode
#define spidrv_mSET_SLAVE_MODE()    ( SpiaRegs.SPICTL.bit.MASTER_SLAVE = 0 )
#define spidrv_mSET_MASTER_MODE()   ( SpiaRegs.SPICTL.bit.MASTER_SLAVE = 1 )

// Set SPI to react to rising/falling clock edge
#define spidrv_mSET_RISING_EDGE()   ( SpiaRegs.SPICCR.bit.CLKPOLARITY = 0 )
#define spidrv_mSET_FALLING_EDGE()  ( SpiaRegs.SPICCR.bit.CLKPOLARITY = 1 )

// set SPI to tx & rx in/out of clock phase
#define spidrv_mCLK_PHASE_WITHOUT_DELAY() ( SpiaRegs.SPICTL.bit.CLK_PHASE = 0 )
#define spidrv_mCLK_PHASE_WITH_DELAY()    ( SpiaRegs.SPICTL.bit.CLK_PHASE = 1 )

// Set the baud rate divisor to Prescaler
#define spidrv_mSET_BAUD_RATE_DIV( Prescaler )  ( SpiaRegs.SPIBRR = Prescaler )

// Set the CCR register
#define spidrv_mSET_CCR( CCR ) ( SpiaRegs.SPICCR.all = CCR )

// Set the CTL register
#define spidrv_mSET_CTL( CTL ) ( SpiaRegs.SPICTL.all = CTL )

// Set the char length to Lengh.
#define spidrv_mSET_CHAR_LEN( Lengh )  ( SpiaRegs.SPICCR.bit.SPICHAR = Lengh )

// Dis/En-able the rx buffer overrun interrupt
#define spidrv_mRX_OVR_RUN_INT_EN()    ( SpiaRegs.SPICTL.bit.OVERRUNINTENA = 1 )
#define spidrv_mRX_OVR_RUN_INT_DIS()   ( SpiaRegs.SPICTL.bit.OVERRUNINTENA = 0 )

// Dis/En-able the SPI tx/rx interrupt.
#define spidrv_mINT_EN()               ( SpiaRegs.SPICTL.bit.SPIINTENA = 1 )
#define spidrv_mINT_DIS()              ( SpiaRegs.SPICTL.bit.SPIINTENA = 0 )

// Dis/En-able SPI transmissions
#define spidrv_mDIS_TX()               ( SpiaRegs.SPICTL.bit.TALK = 0 )
#define spidrv_mEN_TX()                ( SpiaRegs.SPICTL.bit.TALK = 1 )

/*==============================================================================
                                Enums
==============================================================================*/


/*=============================================================================
                              Structures
==============================================================================*/


/*=============================================================================
                              Types
==============================================================================*/
typedef struct spidrv_zSettings
{
    SPIDRV_teCTRL_MODE      CtrlMode;
    SPIDRV_teCLK_POL        ClkPol;
    SPIDRV_teCLK_PHS        ClkPhs;
    uint16                  Length;
    uint16                  ReceiveData;
    uint16                  SPICCR;
    uint16                  SPICTL;
    uint16                  SPIBRR;
} spidrv_tzConfig;


/*==============================================================================
                           Local/Private Constants
==============================================================================*/


/*==============================================================================
                           Local/Private Variables
==============================================================================*/

// used to prevent unauthorized access
static SpiDrvHandle ActiveHandle;

//variable indication of the creation of this package
static tucBOOL SpiCreated = FALSE;


/*==============================================================================
                        Local/Private Function Protoypes
==============================================================================*/
static void spidrv_fnSendDataToTxBuffer( spidrv_tzConfig *ptzConfig, uint16 );
inline void spidrv_fnInit( SpiDrvHandle hSPI );
extern void ISR_fnSPIRXINTA( void );

/*==============================================================================
                           Function Definitions
==============================================================================*/

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnCtor

PURPOSE:
    constructor and Configuration.

INPUTS:
    None

OUTPUTS:
    tuiSTATUS - eSTATUS_OK : SPI driver created successfully
                eSTATUS_ERR : an error occurred creating the SPI driver

NOTES:
    None

VERSION HISTORY:

Version: 1.00  Date: Sept. 13, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: FEB-17-2005  By: Horst Maurer
    - moved EALLOW/EDIS pairs into macro defn's
    - code review changes

Version: 1.20  Date: FEB-17-2005  By: Horst Maurer
    - moved setting of SpiCreated to prevent failure on assert in setCfg fn

Version: 1.30  Date: Mar-10-2005  By: Trevor Monk
    - major architecture changes to support SPI Handles

Version: 1.40    Date: March 21, 2005  By: John Bellini
    - Added initialization of ISR to the vector table.

*******************************************************************************/
tuiSTATUS SPIDRV_fnCtor( void )
{
    //this function should not have been called
    assert( SpiCreated != TRUE );

    // initialize the active handle
    ActiveHandle = NULL;

    // force the SPI to the reset state before configuring it.
    spidrv_mRESET();

    // cfg the port pins to SPI functions
    spidrv_mMODULE_INIT();

    // enable the spi clock
    spidrv_mCLK_ENABLE();

    // set SPIDRV package constructed flag to TRUE (tentative);
    // moved up in execution sequence so following merged setCfg fn
    // doesn't fail on first assert
    SpiCreated = TRUE;

    // setup the tx/rx signal synchronization
    if( SPICLIENT_fnCtor() != eSTATUS_OK )
    {
        // the SPI could not be setup so there is a serious error.
        assert( 0 );
        SpiCreated = FALSE;
        return( eSTATUS_ERR );
    }


    // Initialize interrupt vectors
    //
    DEVICE_mACCESS_EN();
    PieVectTable.T1PINT = &ISR_fnSPIRXINTA;
    DEVICE_mACCESS_DIS();

    // all the parameters were set without any problems so get out of reset
    // mode.
    spidrv_mSTART();

    // ensure the SPI int can be enabled.
    PieCtrlRegs.PIECRTL.bit.ENPIE = 1;      // Enable the PIE block
    PieCtrlRegs.PIEIER6.bit.INTx1 = 1;      // Enable PIE Group 6, INT 1
    DEVICE_mINT6_EN();

    return( eSTATUS_OK );
}


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnDtor

PURPOSE:
    Destroy an instance of an SPI.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS - eSTATUS_OK : SPI driver was destroyed successfully
              - eSTATUS_ERR : the SPI driver could not be destroyed

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 13, 2004  By: Yingran Duan
    - Created.

Version: 1.01  Date: Mar 11, 2005    By: Trevor Monk
    - updated comments

*******************************************************************************/
#ifdef GLBL_DTOR_EN
tuiSTATUS SPIDRV_fnDtor( void )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    if( SPICLIENT_fnDtor() == eSTATUS_OK )
    {
        // disable everything.
        spidrv_mRX_OVR_RUN_INT_DIS();
        spidrv_mDIS_TX();
        spidrv_mINT_DIS();
        spidrv_mRESET();

        SpiCreated = FALSE;
        return( eSTATUS_OK );
    }

    return( eSTATUS_ERR );
}
#endif

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnSetCfg

PURPOSE:
    Set the configuration of the SPI.

INPUTS:
    hSPI:       handle to the SPI instance to be modified
    CtrlMode:   slave or master mode
    ClkPol:     clock polarity
    ClkPhs:     clock phase
    uiBitRate:  requested serial communication rate (bits/sec)
    uiLength:   Character length

OUTPUTS:
    tuiSTATUS - eSTATUS_OK : the SPI configuration was set
                eSTATUS_ERR : an invalid SPI driver handle or configuration
                              option was specified

NOTES:
    None:

VERSION HISTORY:

Version: 1.00  Date: Sept. 27, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: FEB-17-2005  By: Horst Maurer
    - merged local spidrv_fnSetCfgReg contents into here
    - added returns to default cases
    - code review changes

Version: 1.20  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle
    - changed prescalar argument to clock frequency

*******************************************************************************/
tuiSTATUS SPIDRV_fnSetCfg( SpiDrvHandle hSPI,
                           SPIDRV_teCTRL_MODE CtrlMode,
                           SPIDRV_teCLK_POL   ClkPol,
                           SPIDRV_teCLK_PHS   ClkPhs,
                           uint32             uiBitRate,
                           uint16             uiLength )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;
    uint16 Prescaler;

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    if (ptzConfig != NULL)
    {
        // force the SPI to the reset state before configuring it.
        spidrv_mRESET();

        // configure the control mode
        switch( CtrlMode )
        {
            case SPIDRV_eSLAVE:
                spidrv_mSET_SLAVE_MODE();
                break;

            case SPIDRV_eMASTER:
                spidrv_mSET_MASTER_MODE();
                break;

            // an invalid control mode was passed to this function, set error
            //  and leave.
            default:
                assert( 0 );
                return( eSTATUS_ERR );
        }

        // update setting variable
        ptzConfig->CtrlMode = CtrlMode;

        // configure the clock polarity
        switch( ClkPol )
        {
            case SPIDRV_eRISING_EDGE:
                spidrv_mSET_RISING_EDGE();
                break;

            case SPIDRV_eFALLING_EDGE:
                spidrv_mSET_FALLING_EDGE();
                break;

            // an invalid clock polarity was passed to this function, set error
            default:
                assert( 0 );
                return( eSTATUS_ERR );
        }

        // update setting variable
        ptzConfig->ClkPol = ClkPol;

        // configure the clock phase
        switch( ClkPhs )
        {
            case SPIDRV_eWITHOUT_DELAY:
                spidrv_mCLK_PHASE_WITHOUT_DELAY();
                break;

            case SPIDRV_eWITH_DELAY:
                spidrv_mCLK_PHASE_WITH_DELAY();
                break;

            // an invalid clock phase was passed to this function, set error
            default:
                assert( 0 );
                return( eSTATUS_ERR );
        }

        // update setting variable
        ptzConfig->ClkPhs = ClkPhs;

        // calculate the pre-scalar based on the requested clock frequency
        Prescaler = ( SYSCLK_fnGetLoSpeedPeriphClk() / uiBitRate ) - 1;

        // only set the baud rate divisor if it is within acceptable parameters
        assert( Prescaler >= SPI_MIN_BAUD_RATE_DIVISOR );
        assert( Prescaler <= SPI_MAX_BAUD_RATE_DIVISOR );

        // set the baud rate divisor
        spidrv_mSET_BAUD_RATE_DIV( Prescaler );

        //check Length setting
        assert( uiLength >= SPI_MIN_DATA_LENGTH );
        assert( uiLength <= SPI_MAX_DATA_LENGTH );

        //set charactor length
        spidrv_mSET_CHAR_LEN( uiLength - 1 );
        ptzConfig->Length = uiLength;

        // get copies of the SPI registers for fast configuration later
        ptzConfig->SPIBRR = SpiaRegs.SPIBRR;
        ptzConfig->SPICTL = SpiaRegs.SPICTL.all;
        ptzConfig->SPICCR = SpiaRegs.SPICCR.all;

        // all the parameters were set without any problems so get out of
        // the reset mode.
        spidrv_mSTART();

        return eSTATUS_OK;
    }
    else
    {
        // an invalid handle was specified, so abort
        return eSTATUS_ERR;
    }
}


/*******************************************************************************

FUNCTION NAME:
    spidrv_fnInit

PURPOSE:
    Fast initialization of the SPI hardware

INPUTS:
    hSPI:   handle to the SPI instance containing the new configuration

OUTPUTS:
    None

NOTES:
    - SPIDRV_fnSetCfg must have been called before this function, since
      this function uses the register values which were set up in
      SPIDRV_fnSetCfg

VERSION HISTORY:

Version: 1.00  Date: Mar. 08, 2005  By: Trevor Monk
    - Created.

*******************************************************************************/
inline void spidrv_fnInit( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // force the SPI to the reset state before configuring it.
    spidrv_mRESET();

    // Set the baud rate divisor to Prescaler
    spidrv_mSET_BAUD_RATE_DIV( ptzConfig->SPIBRR );

    // Set the CTL register
    spidrv_mSET_CTL( ptzConfig->SPICTL );

    // Set the CCR register
    spidrv_mSET_CCR( (uchar8)ptzConfig->SPICCR );

    // all the parameters have been set so get out of the reset mode
    spidrv_mSTART();
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnSetCharLength

PURPOSE:
    Set character length for SPI

INPUTS:
    hSPI:       handle to the SPI instance to be modified
    uiLength:   Character length

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - character length updated
               eSTATUS_ERR  - an invalid SPI driver handle was specified
                            - an invalid length setting was specified

NOTES:
    None

VERSION HISTORY:

Version: 1.00  Date:Oct. 4, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005 By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnSetCharLength( SpiDrvHandle hSPI,
                                  uint16 uiLength )
{
    spidrv_tzConfig *ptzConfig = ( spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    assert( hSPI );

    //check Length setting
    assert( uiLength >= SPI_MIN_DATA_LENGTH );
    assert( uiLength <= SPI_MAX_DATA_LENGTH );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    // check length setting
    if( ( uiLength < SPI_MIN_DATA_LENGTH ) ||
        ( uiLength > SPI_MAX_DATA_LENGTH ) )
    {
        return( eSTATUS_ERR );
    }

    //set charactor length
    spidrv_mSET_CHAR_LEN( uiLength - 1 );

    //update setting variable
    ptzConfig->Length = uiLength;

    return( eSTATUS_OK );
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnGetCfg

PURPOSE:
    Get the current configuration of the SPI, the parameters are placed into the
    locations indicated by the pointers being passed.

INPUTS:
    hSPI:    handle to the SPI instance to be queried
    *CtrlMode: slave or master mode
    *ClkPol:   clock polarity
    *ClkPhs:   clock phase
    *puiBitRate: SPI bit rate (bits/sec)
    *puiLength:  Character length

OUTPUTS:
    None.

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 14, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
void SPIDRV_fnGetCfg( SpiDrvHandle hSPI,
                      SPIDRV_teCTRL_MODE *CtrlMode,
                      SPIDRV_teCLK_POL   *ClkPol,
                      SPIDRV_teCLK_PHS   *ClkPhs,
                      uint32             *puiBitRate,
                      uint16             *puiLength )
{
    spidrv_tzConfig *ptzConfig = ( spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( hSPI );
    assert( CtrlMode );
    assert( ClkPol );
    assert( ClkPhs );
    assert( puiBitRate );
    assert( puiLength );

    *CtrlMode = ptzConfig->CtrlMode;
    *ClkPol = ptzConfig->ClkPol;
    *ClkPhs = ptzConfig->ClkPhs;
    *puiBitRate = SYSCLK_fnGetLoSpeedPeriphClk() / ( ptzConfig->SPIBRR + 1 );
    *puiLength = ptzConfig->Length;
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnRead

PURPOSE:
    Read data from the SPI buffer. Transmits 0x0000

INPUTS:
    hSPI:   handle to the SPI instance to be queried
    puiRxData: a pointer to a buffer where the received data will be stored

OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 14, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: FEB-17-2005  By: Horst Maurer
    - removed local variable for tuiSTATUS return value
    - code review changes

Version: 1.11  Date: FEB-17-2005  By: Horst Maurer
    - restored local variable for tuiSTATUS to allow macros to work

Version: 1.20  Date: Mar 08, 2005 By: Trevor Monk
    - modified to use SPI handle
    - fixed return status OK bug

*******************************************************************************/
tuiSTATUS SPIDRV_fnRead( SpiDrvHandle hSPI,
                         uint16 *puiRxData )
{
    tuiSTATUS tuiStatus;
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( puiRxData );
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    // signal that the Tx/Rx is starting
    if( SPICLIENT_fnSignalStartTxRx() != eSTATUS_OK )
    {
        mWRITE_STATUS_AND_ERRNO( SPIDRV_eERRNO_CHNL_BUSY );
        return( eSTATUS_ERR );
    }

    // send dummy data to generate a clock to read data from spi
    spidrv_fnSendDataToTxBuffer( ptzConfig, 0x0000 );

    // If this func doesn't get the completed tx/rx signal within a certain
    // amount of time, it means that the ISR was not called in time.
    if( SPICLIENT_fnWaitForTxRxComplete() == eSTATUS_OK )
    {
        *puiRxData = ptzConfig->ReceiveData;
    }
    else
    {
        mWRITE_STATUS_AND_ERRNO( SPIDRV_eERRNO_READ );
        return( eSTATUS_ERR );
    }

    return( eSTATUS_OK );
}


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnWrite

PURPOSE:
    Write data to the SPI. Use this fnc if you don't care what is received. If
    you do care, use the SPIDRV_fnWriteAndRead function.

INPUTS:
    hSPI:       handle to the SPI instance to be modified
    uiTxData:   the data to be sent

OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 14, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnWrite( SpiDrvHandle hSPI,
                          uint16 uiTxData )
{
    tuiSTATUS tuiStatus = eSTATUS_OK;   // assume everything is ok upon entry
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    // signal that the Tx/Rx is starting
    if( SPICLIENT_fnSignalStartTxRx() != eSTATUS_OK )
    {
        mWRITE_STATUS_AND_ERRNO( SPIDRV_eERRNO_CHNL_BUSY );
        return( eSTATUS_ERR );
    }

    // if this SPI is the master,
    if( ptzConfig->CtrlMode == SPIDRV_eMASTER )
    {
        spidrv_fnSendDataToTxBuffer( ptzConfig, uiTxData );

        // if the tx/rx has not been signalled as completed, then it's an error
        tuiStatus = SPICLIENT_fnWaitForTxRxComplete();
    }

    // if the SPI is in slave mode and the SPISTE pin is low, it's ok
    //  to xmit make sure this io is set for SPI model use
    else if( ( ptzConfig->CtrlMode == SPIDRV_eSLAVE ) &&
             ( GpioDataRegs.GPFDAT.bit.GPIOF3  == 0 ) )
    {
        spidrv_fnSendDataToTxBuffer( ptzConfig, uiTxData );

        tuiStatus = SPICLIENT_fnWaitForTxRxComplete();
    }
    else
    {
       // the SPI is not configured correctly so set an error
       assert( 0 );
       mWRITE_STATUS_AND_ERRNO( SPIDRV_eERRNO_WRITE );
    }

    return( tuiStatus );
}


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnEnTx

PURPOSE:
    Enable the SPI Tx.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI transmitter was enabled successfully
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnEnTx( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mEN_TX();

    // store the updated SPICTL register
    ptzConfig->SPICTL = SpiaRegs.SPICTL.all;

    return( eSTATUS_OK );
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnDisTx

PURPOSE:
    Disable the SPI tx.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI transmitter was disabled successfully
               eSTATUS_ERR - an invalid handle was specified
NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnDisTx( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mDIS_TX();

    // store the updated SPICTL register
    ptzConfig->SPICTL = SpiaRegs.SPICTL.all;

    return( eSTATUS_OK );
}

/*******************************************************************************

FUNCTION NAME:
    SPI_fnEnInt

PURPOSE:
    Enable the SPI interrupt.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI interrupt was enabled successfully
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnEnInt( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mINT_EN();

    // store the updated SPICTL register
    ptzConfig->SPICTL = SpiaRegs.SPICTL.all;

    return( eSTATUS_OK );
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnDisInt

PURPOSE:
    Disable the SPI interrupt.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI interrupt was disabled successfully
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnDisInt( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mINT_DIS();

    // store the updated SPICTL register
    ptzConfig->SPICTL = SpiaRegs.SPICTL.all;

    return eSTATUS_OK;
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnEnOvrRunInt

PURPOSE:
    Enable the SPI receive overrun interrupt.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI overrun interrupt was enabled successfully
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnEnOvrRunInt( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mRX_OVR_RUN_INT_EN();

    // store the updated SPICTL register
    ptzConfig->SPICTL = SpiaRegs.SPICTL.all;

    return eSTATUS_OK;
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnDisOvrRunInt

PURPOSE:
    Disable the SPI receive overrun interrupt.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI overrun interrupt was disabled successfully
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnDisOvrRunInt( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mRX_OVR_RUN_INT_DIS();

    // store the updated SPICTL register
    ptzConfig->SPICTL = SpiaRegs.SPICTL.all;

    return( eSTATUS_OK );
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnReset

PURPOSE:
    Reset SPI module

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI was put into reset mode
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnReset( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mRESET();

    // store the updated SPICCR register
    ptzConfig->SPICCR = SpiaRegs.SPICCR.all;

    return( eSTATUS_OK );
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnStart

PURPOSE:
    Start SPI operation.

INPUTS:
    hSPI:   handle to the SPI instance to be modified

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - the SPI was started successfully
               eSTATUS_ERR - an invalid handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnStart( SpiDrvHandle hSPI )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    spidrv_mSTART();

    // store the updated SPICCR register
    ptzConfig->SPICCR = SpiaRegs.SPICCR.all;

    return( eSTATUS_OK );
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnCheckEvent

PURPOSE:
    provide SPI un-processed event

INPUTS:
    hSPI:   handle to the SPI instance to be queried

OUTPUTS:
    SPIDRV_teEVENT: one of:
        SPIDRV_eNONE - no event has occurred
        SPIDRV_eRX_OVERRUN - a received overrun event has occurred
        SPIDRV_eRX_FULL - an RX buffer full event has occurred
        SPIDRV_eTX_FULL - a TX buffer full event has occurred

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 20, 2004   By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005     By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
SPIDRV_teEVENT SPIDRV_fnCheckEvent( SpiDrvHandle hSPI )
{
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( SPIDRV_eNONE );
    }

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    //check whether there is an receiver overrun
    if( SpiaRegs.SPISTS.bit.OVERRUN_FLAG == 1 )
    {
        return( SPIDRV_eRX_OVERRUN );
    }

    //check whether there is an Receiving message
    else if( SpiaRegs.SPISTS.bit.INT_FLAG == 1 )
    {
        return( SPIDRV_eRX_FULL );
    }

    //check whether there is an transmission message need to send
    else if( SpiaRegs.SPISTS.bit.BUFFULL_FLAG == 1 )
    {
        return( SPIDRV_eTX_FULL );
    }

    //no other cases
    else
    {
        return( SPIDRV_eNONE );
    }
}

/*******************************************************************************

FUNCTION NAME:
    spidrv_fnSendDataToTxBuffer

PURPOSE:
    Send data to the transmit buffer.

INPUTS:
    ptzConfig:   pointer to the config data for the SPI device
    TxData:      data to be transmitted via the SPI device

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 20, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
static void spidrv_fnSendDataToTxBuffer( spidrv_tzConfig *ptzConfig,
                                         uint16 uiTxData )
{
    // data must be left justified in the TX buf so shift the data an
    //  appropriate number of spaces.
    SpiaRegs.SPITXBUF = uiTxData << ( SPI_MAX_DATA_LENGTH - ptzConfig->Length );
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnWriteAndRead

PURPOSE:
    Write data out and then read the rx buffer.

INPUTS:
    hSPI:       handle to the SPI instance to be modified
    uiTxData:   the data to be sent
    puiRxData:  a pointer to a buffer where the received data will be stored

OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 20, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: Mar 08, 2005    By: Trevor Monk
    - modified to use SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnWriteAndRead( SpiDrvHandle hSPI,
                                 uint16 uiTxData,
                                 uint16 *puiRxData )
{
    tuiSTATUS tuiStatus = eSTATUS_OK; // assume everything is ok upon entry
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)hSPI;

    assert( hSPI );

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( puiRxData );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    //send out transmission data
    tuiStatus = SPIDRV_fnWrite( hSPI, uiTxData );

    //get received data
    if( tuiStatus == eSTATUS_OK )
    {
        *puiRxData = SpiaRegs.SPIRXBUF;

        if ( ptzConfig )
            ptzConfig->ReceiveData = SpiaRegs.SPIRXBUF;
    }

    return( tuiStatus );
}


/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnRxIsr

PURPOSE:
    SpiDrvHandle events generated by the SPI.

INPUTS:
    none

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 20, 2004  By: Yingran Duan
    - Created.

Version: 1.10  Date: FEB-21-2005  By: Horst Maurer
    - removed IER bit setting/clearing; IER control done in asm isr

Version: 1.20  Date: Mar 08 2005  By: Trevor Monk
    - modified to use the SPI handle

*******************************************************************************/
void SPIDRV_fnRxIsr( void )
{
    spidrv_tzConfig *ptzConfig = (spidrv_tzConfig *)ActiveHandle;

    // read the data in the rx buffer to clear the interrupt flag
    if ( ptzConfig )
        ptzConfig->ReceiveData = SpiaRegs.SPIRXBUF;

    // signal that the tx/rx is complete
    SPICLIENT_fnTxRxComplete();

    PieCtrlRegs.PIEACK.bit.ACK6 = 1;        // Issue PIE ACK
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnAcquireLock

PURPOSE:
    Acquire exclusive access to the SPI driver

INPUTS:
    hSPI:      handle to the SPI instance acquiring exclusive access
    siWaitTicks: number if ticks to wait for exclusive access (see notes)

OUTPUTS:
    tuiSTATUS: eSTATUS_OK - an exclusive lock was acquired
               eSTATUS_ERR - exclusive access to the SPI is unavailable

NOTES:
    If siWaitTicks is negative, this function will try to obtain a lock
    without blocking and return immediately if an exclusive lock is unavailable.

    If siWaitTicks is zero, this function will wait forever until a lock
    is available

    If siWaitTicks is positive, this represents the maximum number of
    system ticks to wait for exclusive access

VERSION HISTORY:

Version: 1.00  Date: Mar. 07, 2005  By: Trevor Monk
    - Created.

Version: 1.10  Date: Mar 18, 2005   By: Trevor Monk
    - Added runtime check for valid SPI handle

*******************************************************************************/
tuiSTATUS SPIDRV_fnAcquireLock( SpiDrvHandle hSPI,
                                sint16 siWaitTicks )
{
    assert( hSPI );

    if( hSPI == NULL )
    {
        return( eSTATUS_ERR );
    }

    // ask the SPICLIENT to handle exclusive access for us
    if( SPICLIENT_fnAcquireLock( siWaitTicks ) == eSTATUS_OK )
    {
        ActiveHandle = hSPI;

        // since we have just got a lock, lets assume that the SPI needs to be
        // initialized with our settings
        spidrv_fnInit( hSPI );

        return eSTATUS_OK;
    }

    // we were unable to lock the SPIDRV for exclusive access
    return eSTATUS_ERR;
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnReleaseLock

PURPOSE:
    Release exclusive access to the SPI driver

INPUTS:
    hSPI: handle to the device releasing exclusive access

OUTPUTS:
    tuiSTATUS : eSTATUS_OK - the exclusive lock was successfully released
                eSTATUS_ERR - an invalid SPI driver handle was specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Mar. 07, 2005  By: Trevor Monk
    - Created.

*******************************************************************************/
tuiSTATUS SPIDRV_fnReleaseLock( SpiDrvHandle hSPI )
{
    assert( hSPI );

    // access to this function is only allowed to callers who have obtained
    // a valid lock
    if( hSPI != ActiveHandle )
    {
        assert( 0 );
        return( eSTATUS_ERR );
    }

    // ask the SPICLIENT to handle exclusive access for us
    SPICLIENT_fnReleaseLock();

    return eSTATUS_OK;
}

/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnCreateHandle()

PURPOSE:
    Creates a new SPI driver handle.

INPUTS:
    none

OUTPUTS:
    SpiDrvHandle - a newly created SPI driver handle

NOTES:
    This function is used to generate an SPI handle which must be used to
    gain access any other function in this module (with the exception of the
    creator and destructor functions).

    It is the callers responsibility to release the heap memory used by the
    handle by calling SPIDRV_fnDeleteHandle when they are finished with the
    handle.

    If a memory allocation failure occurs, this function will return NULL

VERSION HISTORY:

Version: 1.00  Date: Mar. 07, 2005  By: Trevor Monk
    - Created.

*******************************************************************************/
SpiDrvHandle SPIDRV_fnCreateHandle()
{
    spidrv_tzConfig *ptzConfig;

    // allocate an SPI driver structure from the heap
    ptzConfig = (spidrv_tzConfig *)malloc(sizeof(spidrv_tzConfig));
    if (ptzConfig == NULL)
    {
        return NULL;
    }

    // clear the SPI structure to zero
    memset(ptzConfig, 0, sizeof(spidrv_tzConfig));

    return (SpiDrvHandle)ptzConfig;
}



/*******************************************************************************

FUNCTION NAME:
    SPIDRV_fnDeleteHandle()

PURPOSE:
    Deletes an SPI driver handle

INPUTS:
    hSPI: the SPI handle to delete

OUTPUTS:
    tuiSTATUS : eSTATUS_OK - hSPI deleted successfully
                eSTATUS_ERR - invalid handle specified

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Mar. 08, 2005  By: Trevor Monk
    - Created.

*******************************************************************************/
tuiSTATUS SPIDRV_fnDeleteHandle( SpiDrvHandle hSPI )
{
    if( hSPI != NULL )
    {
        free( hSPI );
        return( eSTATUS_OK );
    }

    return( eSTATUS_ERR );
}
