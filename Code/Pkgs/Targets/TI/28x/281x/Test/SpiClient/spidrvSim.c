/*==============================================================================
Copyright 2004 Xantrex International.  All rights reserved.

This source file is proprietary to Xantrex International. and protected by
copyright. The reproduction, in whole or in part, by anyone without the written
approval of Xantrex is prohibited.

FILE NAME:  spidrv.c

PURPOSE:
    Provide SPI services.

FUNCTION(S):
    SPDRVI_fnCtor           - Configure and initialize the SPI to it's default 
                              parameters.
    SPIDRV_fnDtor           - Destroy an instance of an SPI.
    SPIDRV_fnSetCfg         - Set the configuration of the SPI.
    SPIDRV_fnGetCfg         - Get the vurrent configuration of the SPI, the
                              parameters are placed into the locations 
                              indicated by the pointers being passed.
    SPIDRV_fnSetCharLength  - set communication character length
    SPIDRV_fnRead           - Read data from the SPI buffer. No actual 
                              communications occurs.
    SPIDRV_fnWrite          - Write data to the SPI. Use this fnc if you don't 
                              care what is received. If you do care, use the
                              spi_fnWriteAndRead function.
    SPIDRV_fnWriteAndRead   - Write data out and then read the rx buffer.
    SPIDRV_fnEnASlave       - Enable a slave channel to do SPI communication
    SPIDRV_fnGetEnSlaveChnl - provide the slave channel id that is enabled
    SPIDRV_fnDisASlave      - Disable a slave channel
    SPIDRV_fnDisAllSlave    - Disable all slave channels
    SPIDRV_fnEnTx           - Enable the SPI transmission.
    SPIDRV_fnDisTx          - Disable the SPI transmission.
    SPIDRV_fnEnInt          - Enable the tx/rx interrupt.
    SPIDRV_fnDisInt         - Disable the tx/rx interrupt.
    SPIDRV_fnEnOvrRunInt    - Enable the rx buffer overrun interrupt.
    SPIDRV_fnDisOvrRunInt   - Disable the rx buffer overrun interrupt.
    SPIDRV_fnReset          - Reset SPI module 
    SPIDRV_fnStart          - Start SPI module 
    SPIDRV_fnCheckEvent     - provide SPI un-processed event 
    SPIDRV_fnISR            - Handle events generated by the SPI. 
    
    
    local:
        spidrv_fnSendDataToTxBuffer - Send data to the transmit buffer.
        spidrv_fnSetCfgReg          - Set the configuration of the SPI.
NOTES:
    None.    

CHANGE HISTORY:
$History: spidrvSim.c $
    
    *****************  Version 1  *****************
    User: Yingrand     Date: 11/03/04   Time: 2:39p
    Created in $/PD/Inverter_Charger/Nova_Series/Code/Baseline/C28x/Packages/Services/HALSVC/SPICLIENT/Test
    
    *****************  Version 1  *****************
    User: Yingrand     Date: 10/12/04   Time: 11:05a
    Created in $/PD/Common/Targets/TI/c28x/HAL/Test/spidrv
    
     
==============================================================================*/


/*==============================================================================
                              Includes
==============================================================================*/
#include "spidrv.h"
#include "spislavechnl.h"   //multi slave channel definition
#include "xassert.h"        // allow the use of assert( n )
#include "Device.h"         // TI device headers
#include "devicemacro.h"    // macros to enable PIE
#include <errno.h>          // driver level error codes
#include <limits.h>         // for CHAR_BIT

/*==============================================================================
                              Defines
==============================================================================*/
// Function enables. Set to TRUE if you want to use the function, otherwise,
//  set to FALSE.

// Enable SPIDRV_fnRead()
#define SPI_FN_READ_EN              ( TRUE )
// Enable SPIDRV_fnWriteAndRead()
#define SPI_FN_WRITE_AND_READ_EN    ( TRUE )
//enable SPIDRV_fnGetCfg
#define SPI_GET_CFG_EN              ( FALSE )
//enable SPIDRV_fnEnASlave          
#define SPI_EN_A_SLAVE_EN           ( FALSE )
//enable SPIDRV_fnGetEnSlaveChnl
#define SPI_GET_SLAVE_CHNL_EN       ( FALSE )
//enable SPIDRV_fnDisASlave
#define SPI_DIS_A_SLAVE_EN          ( FALSE )
//enable SPIDRV_fnDisAllSlave       
#define SPI_DIS_ALL_SLAVE_EN        ( FALSE )
//enable SPIDRV_fnEnTx
#define SPI_EN_TX_EN                ( TRUE )
//enable SPIDRV_fnDisTx 
#define SPI_DIS_TX_EN               ( FALSE ) 
//enable SPIDRV_fnEnInt
#define SPI_EN_INT_EN               ( TRUE )
//enable SPIDRV_fnDisInt
#define SPI_DIS_INT_EN              ( FALSE )
//enable SPIDRV_fnEnOvrRunInt   
#define SPI_EN_OVRRUN_INT_EN        ( FALSE )
//enable SPIDRV_fnDisOvrRunInt
#define SPI_DIS_OVRRUN_INT_EN       ( FALSE )
//enable SPIDRV_fnReset
#define SPI_RESET_EN                ( TRUE )
//enable SPIDRV_fnStart
#define SPI_START_EN                ( TRUE )
//enable SPIDRV_fnCheckEvent
#define SPI_CHECK_EVENT_EN          ( FALSE )


// The following MIN/MAX parameters are determined by the hardware. Do not
//  change these parameters unless you are absolutely sure the hardware will
//  accept them.
//
// define the min and max size of the data packet in # of bits.
#define SPI_MIN_CHAR_LENGTH         ( 1 )
#define SPI_MAX_CHAR_LENGTH         ( 16 )

// define the min and max baud rate divisor.
//  
// The baud rate for the SPI = (CLKOUT)/(Baud Rate prescaler + 1 )
//  where (Baud Rate Divisor)=3..127
#define SPI_MIN_BAUD_RATE_DIVISOR   ( 3 )
#define SPI_MAX_BAUD_RATE_DIVISOR   ( 127 )

//None slave channel has been enabled
#define SPI_NONE_SLAVE_CHANNEL_ENABLED  ( 0xFFFF )

/*==============================================================================
                              Macros
==============================================================================*/
// Put the SPI into reset mode 
#define SPIDRV_mRESET()    ( SpiaRegs.SPICCR.bit.SPISWRESET = 0 )
// Get out the SPI of reset mode.
#define SPIDRV_mSTART()    ( SpiaRegs.SPICCR.bit.SPISWRESET = 1 )

// Configure the appropriate port pins so the SPI can be used.
#define SPIDRV_mMODLE_INIT()    ( GpioMuxRegs.GPFMUX.bit.SPISIMOA_GPIOF0 = 1 );\
                                ( GpioMuxRegs.GPFMUX.bit.SPISOMIA_GPIOF1 = 1 );\
                                ( GpioMuxRegs.GPFMUX.bit.SPICLKA_GPIOF2 = 1 );\
                                ( GpioMuxRegs.GPFMUX.bit.SPISTEA_GPIOF3 = 1 );\
                                ( SysCtrlRegs.PCLKCR.bit.SPIENCLK = 1 )

// Put SPI in slave/master mode
#define SPIDRV_mSET_SLAVE_MODE()    ( SpiaRegs.SPICTL.bit.MASTER_SLAVE = 0 )
#define SPIDRV_mSET_MASTER_MODE()   ( SpiaRegs.SPICTL.bit.MASTER_SLAVE = 1 )

// Set SPI to react to rising/falling clock edge
#define SPIDRV_mSET_RISING_EDGE()   ( SpiaRegs.SPICCR.bit.CLKPOLARITY = 0 )
#define SPIDRV_mSET_FALLING_EDGE()  ( SpiaRegs.SPICCR.bit.CLKPOLARITY = 1 )

// set SPI to tx & rx in/out of clock phase
#define SPIDRV_mCLK_PHASE_WITHOUT_DELAY() ( SpiaRegs.SPICTL.bit.CLK_PHASE = 0 )
#define SPIDRV_mCLK_PHASE_WITH_DELAY()    ( SpiaRegs.SPICTL.bit.CLK_PHASE = 1 )

// Set the baud rate divisor to Prescaler
#define SPIDRV_mSET_BAUD_RATE_DIV( Prescaler )  ( SpiaRegs.SPIBRR = Prescaler )

// Set the char length to Lengh. 
#define SPIDRV_mSET_CHAR_LEN( Lengh )  ( SpiaRegs.SPICCR.bit.SPICHAR = Lengh ) 

// Dis/En-able the rx buffer overrun interrupt
#define SPIDRV_mRX_OVR_RUN_INT_EN()    ( SpiaRegs.SPICTL.bit.OVERRUNINTENA = 1 )
#define SPIDRV_mRX_OVR_RUN_INT_DIS()   ( SpiaRegs.SPICTL.bit.OVERRUNINTENA = 0 )

// Dis/En-able the SPI tx/rx interrupt.
#define SPIDRV_mINT_EN()               ( SpiaRegs.SPICTL.bit.SPIINTENA = 1 )
#define SPIDRV_mINT_DIS()              ( SpiaRegs.SPICTL.bit.SPIINTENA = 0 )

// Dis/En-able SPI transmissions
#define SPIDRV_mDIS_TX()               ( SpiaRegs.SPICTL.bit.TALK = 0 )
#define SPIDRV_mEN_TX()                ( SpiaRegs.SPICTL.bit.TALK = 1 )

/*==============================================================================
                            Type Definitions
==============================================================================*/


/*==============================================================================
                                Enums
==============================================================================*/


/*=============================================================================
                              Structures
==============================================================================*/


/*==============================================================================
                           Local/Private Constants
==============================================================================*/


/*==============================================================================
                           Local/Private Variables
==============================================================================*/
//variable indication of the creation of this package
static tucBOOL SpiCreated = FALSE;

//SPI configuration setings
static SPIDRV_teCTRL_MODE CtrlModeSet;
static uint16 LengthSet;

//spi received data
static uint16 ReceiveData;

//store enabled slave channel
static uint16 EnabledSlaveChnl = SPI_NONE_SLAVE_CHANNEL_ENABLED;
/*==============================================================================
                        Local/Private Function Protoypes
==============================================================================*/
tuiSTATUS spidrv_fnSetCfgReg( SPIDRV_teCTRL_MODE CtrlMode,   
                              SPIDRV_teCLK_POL   ClkPol,     
                              SPIDRV_teCLK_PHS   ClkPhs,     
                              uint16             Prescaler,
                              uint16             Length ); 

static void spidrv_fnSendDataToTxBuffer( uint16 ); 

/*==============================================================================
                           Function Definitions
==============================================================================*/

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnCtor
  
PURPOSE: 
    constructor and Configuration.

INPUTS: 
    CtrlMode: slave or master mode
    ClkPol:   clock polarity
    ClkPhs:   clock phase
    Prescaler:prescaler on specific processor's clock to get baut rate
    Length:   Character length

OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    none

VERSION HISTORY:

Version: 1.00  Date: Sept. 13, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
tuiSTATUS SPIDRV_fnCtor( SPIDRV_teCTRL_MODE CtrlMode,   
                         SPIDRV_teCLK_POL   ClkPol,     
                         SPIDRV_teCLK_PHS   ClkPhs,     
                         uint16             Prescaler,
                         uint16             Length ) 
{
    //this function should not have been called
    assert( SpiCreated != TRUE );

    //turn off all slave port, if this is used as master
    if( CtrlMode == SPIDRV_eMASTER )
    {
        EALLOW;
        SPISLAVECHNL_mINIT();
        EDIS;
        SPISLAVECHNL_mDISABLE_ALL();
    }

    // force the SPI to the reset state before configuring it.
    SPIDRV_mRESET();
        
    // cfg the port pins to SPI functions
    EALLOW;
    SPIDRV_mMODLE_INIT();
    EDIS;
                        
    // set up the SPI configuration.
    if( spidrv_fnSetCfgReg( CtrlMode,   
                            ClkPol,     
                            ClkPhs,     
                            Prescaler,
                            Length ) != eSTATUS_OK )
    {
        // the SPI could not be setup so there is a serious error.
        assert( 0 );
        return( eSTATUS_ERR );
    }
        
    // setup the tx/rx signal synchronization
    if( SPICLIENT_fnCtor() != eSTATUS_OK )
    {
        // the SPI could not be setup so there is a serious error.
        assert( 0 );
        return( eSTATUS_ERR );
    }
    
    // all the parameters were set without any problems so get out of reset 
    // mode. 
    SPIDRV_mSTART();

    // ensure the SPI int can be enabled. 
    PieCtrlRegs.PIECRTL.bit.ENPIE = 1;      // Enable the PIE block
    PieCtrlRegs.PIEIER6.bit.INTx1 = 1;      // Enable PIE Group 6, INT 1
    DEVICE_mINT6_EN();

    //SPIDRV package constructed
    SpiCreated = TRUE;
        
    return( eSTATUS_OK );
}


/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnDtor
  
PURPOSE: 
    Destroy an instance of an SPI. 

INPUTS: 
    none

OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 13, 2004  By: Yingran Duan
    - Created.
    

*******************************************************************************/
#ifdef GLBL_DTOR_EN
tuiSTATUS SPIDRV_fnDtor( void )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    if( SPICLIENT_fnDtor() == eSTATUS_OK )
    {
        // disable everything.    
        SPIDRV_mRX_OVR_RUN_INT_DIS();
        SPIDRV_mDIS_TX();
        SPIDRV_mINT_DIS();
        SPIDRV_mRESET();

        SpiCreated = FALSE;
        return( eSTATUS_OK );
    }
    
    return( eSTATUS_ERR ); 
}
#endif // #ifdef GLBL_DTOR_EN


/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnSetCfg
  
PURPOSE: 
    Set the configuration of the SPI.

INPUTS: 
    CtrlMode: slave or master mode
    ClkPol:   clock polarity
    ClkPhs:   clock phase
    Prescaler:prescaler on specific processor's clock to get baut rate
    Length:   Character length

OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    refer to spidrv_fnSetCfg    

VERSION HISTORY:

Version: 1.00  Date: Sept. 27, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
tuiSTATUS SPIDRV_fnSetCfg( SPIDRV_teCTRL_MODE CtrlMode,   
                           SPIDRV_teCLK_POL   ClkPol,     
                           SPIDRV_teCLK_PHS   ClkPhs,     
                           uint16             Prescaler,
                           uint16             Length ) 

{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    return( spidrv_fnSetCfgReg( CtrlMode,   
                                ClkPol,     
                                ClkPhs,     
                                Prescaler,
                                Length ) );

}

/*******************************************************************************

FUNCTION NAME: 
    spidrv_fnSetCfgReg
  
PURPOSE: 
    Set the configuration of the SPI.

INPUTS: 
    CtrlMode: slave or master mode
    ClkPol:   clock polarity
    ClkPhs:   clock phase
    Prescaler:prescaler on specific processor's clock to get baut rate
    Length:   Character length

OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    - When the function first starts, clear the SPI SW Reset bit so that if 
      there is an exit due to an error, we will be able to tell the SPI is not
      ready to xmit or rcv. Set this bit ONLY when everything is confirmed to be
      ok.

    - This cfg function only has the 4 parameters so that it shares the same
      interface with the Miata SPI Cfg function. All TI specific SPI 
      configurations have their own interface functions in this package.
    
    - The baud rate for the SPI = (CLKOUT)/(Baud Rate Divisor) 
      where (Baud Rate Divisor) = 4..128
      and CLKOUT is the CPU clock frequency of the device
      
      For SPIBRR = 0,1,2,3 -> (Baud Rate Divisor) = 4
      For SPIBRR = 4..127  -> (Baud Rate Divisor) = SPIBRR + 1
    

VERSION HISTORY:

Version: 1.00  Date:Sept, 23, 2004  By: Yingran Duan
    - Created.


*******************************************************************************/
tuiSTATUS spidrv_fnSetCfgReg( SPIDRV_teCTRL_MODE CtrlMode,   
                              SPIDRV_teCLK_POL   ClkPol,     
                              SPIDRV_teCLK_PHS   ClkPhs,     
                              uint16             Prescaler,
                              uint16             Length ) 
{
    //turn off all slave port, if this is used as master
    if( CtrlMode == SPIDRV_eMASTER )
    {
        SPISLAVECHNL_mDISABLE_ALL();
    }

    // force the SPI to the reset state before configuring it.
    SPIDRV_mRESET();

    // configure the control mode
    switch( CtrlMode )
    {
        case SPIDRV_eSLAVE:
            SPIDRV_mSET_SLAVE_MODE();
            break;
    
        case SPIDRV_eMASTER:
            SPIDRV_mSET_MASTER_MODE();
            break;
    
        // an invalid control mode was passed to this function, set error
        //  and leave.
        default:
            assert( 0 );
    }
    //update setting variable
    CtrlModeSet = CtrlMode;
            
    // configure the clock polarity
    switch( ClkPol )
    {
        case SPIDRV_eRISING_EDGE:
            SPIDRV_mSET_RISING_EDGE();
            break;
    
        case SPIDRV_eFALLING_EDGE:
            SPIDRV_mSET_FALLING_EDGE();
            break;                 
    
        // an invalid clock polarity was passed to this function, set error
        default:
            assert( 0 );
    }

    // configure the clock phase
    switch( ClkPhs )
    {
        case SPIDRV_eWITHOUT_DELAY:
            SPIDRV_mCLK_PHASE_WITHOUT_DELAY();
            break;
    
        case SPIDRV_eWITH_DELAY:
            SPIDRV_mCLK_PHASE_WITH_DELAY();
            break;

        // an invalid clock phase was passed to this function, set error
        default:
            assert( 0 );
    }

    // only set the baud rate divisor if it is within acceptable parameters
    assert( Prescaler >= SPI_MIN_BAUD_RATE_DIVISOR );
    assert( Prescaler <= SPI_MAX_BAUD_RATE_DIVISOR );

    // set the baud rate divisor 
    SPIDRV_mSET_BAUD_RATE_DIV( Prescaler );

    //check Length setting
    assert( Length >= SPI_MIN_CHAR_LENGTH );
    assert( Length <= SPI_MAX_CHAR_LENGTH );
    //set charactor length
    SPIDRV_mSET_CHAR_LEN( Length - 1 );
    //update setting variable
    LengthSet = Length;
     
    // all the parameters were set without any problems so get out of the reset
    //  mode. 
    SPIDRV_mSTART();
    
    return( eSTATUS_OK );
}

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnSetCharLength
  
PURPOSE: 
    Set character length for spi.

INPUTS: 
    Length:   Character length

OUTPUTS:
    none

NOTES:
    none

VERSION HISTORY:

Version: 1.00  Date:Oct. 4, 2004  By: Yingran Duan
    - Created.


*******************************************************************************/
void SPIDRV_fnSetCharLength( uint16 Length ) 
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    //check Length setting
    assert( Length >= SPI_MIN_CHAR_LENGTH );
    assert( Length <= SPI_MAX_CHAR_LENGTH );
    //set charactor length
    SPIDRV_mSET_CHAR_LEN( Length - 1 );
    //update setting variable
    LengthSet = Length;

}

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnGetCfg

PURPOSE: 
    Get the current configuration of the SPI, the parameters are placed into the
    locations indicated by the pointers being passed.

INPUTS: 
    *CtrlMode: slave or master mode
    *ClkPol:   clock polarity
    *ClkPhs:   clock phase
    *Prescaler:prescaler on specific processor's clock to get baut rate
    *Length:   Character length
    
OUTPUTS:
    no return value.

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 14, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( defined( SPIDRV_UNIT_TEST ) || SPI_GET_CFG_EN == TRUE ) 
void SPIDRV_fnGetCfg( SPIDRV_teCTRL_MODE *CtrlMode,  
                      SPIDRV_teCLK_POL   *ClkPol,          
                      SPIDRV_teCLK_PHS   *ClkPhs,          
                      uint16             *Prescaler,
                      uint16             *Length )   
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( CtrlMode );
    assert( ClkPol );
    assert( ClkPhs );      
    assert( Prescaler );
    assert( Length );

    // check to see if the SPI is in MASTER mode
    if( SpiaRegs.SPICTL.bit.MASTER_SLAVE == 1 )
    {
        *CtrlMode = SPIDRV_eMASTER;
    }
    else
    {
        *CtrlMode = SPIDRV_eSLAVE;    
    }
    //update setting variable
    CtrlModeSet = *CtrlMode;

    // check to see which clock polarity the SPI is using
    if( SpiaRegs.SPICCR.bit.CLKPOLARITY == 1 )
    {
        *ClkPol = SPIDRV_eFALLING_EDGE;
    }
    else
    {
        *ClkPol = SPIDRV_eRISING_EDGE;    
    }
    
    // check to see which clock phase the SPI is using
    if( SpiaRegs.SPICTL.bit.CLK_PHASE == 1 )
    {
        *ClkPhs = SPIDRV_eWITH_DELAY;
    }
    else
    {
        *ClkPhs = SPIDRV_eWITHOUT_DELAY;    
    }
 
    // check to see the baut rate prescaler
    *Prescaler = SpiaRegs.SPIBRR;

    //get character lengh
    *Length = SpiaRegs.SPICCR.bit.SPICHAR + 1;
    //update setting variable
    LengthSet = *Length;

}
#endif                                                       
                                                       
/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnRead
  
PURPOSE: 
    Read data from the SPI buffer. Transmits 0x0000

INPUTS: 
    uint16 *RxData - a pointer to a buffer where the received data will be
                        stored
    
OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 14, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( SPI_FN_READ_EN == TRUE || defined( SPIDRV_UNIT_TEST ) )
tuiSTATUS SPIDRV_fnRead( uint16 *RxData )
{
    tuiSTATUS tuiStatus = eSTATUS_OK;
    
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( RxData );

    // signal that the Tx/Rx is starting
    if( SPICLIENT_fnSignalStartTxRx() != eSTATUS_OK )
    {
        mWRITE_STATUS_AND_ERRNO( SPIDRV_eERRNO_CHNL_BUSY );
        return( eSTATUS_ERR );
    }

    // send nothing.
    spidrv_fnSendDataToTxBuffer( 0x0000 );
    
    // If this func doesn't get the completed tx/rx signal within a certain amount
    //  of time, it means that the ISR was not called in time. 
    if( SPICLIENT_fnWaitForTxRxComplete() == eSTATUS_OK )
    {
        *RxData = ReceiveData;
    }
    else
    {
        mWRITE_STATUS_AND_ERRNO( SPIDRV_eERRNO_READ );
    }

    return( tuiStatus );
}
#endif // #if( SPI_FN_READ_EN == TRUE )


/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnWrite
  
PURPOSE: 
    Write data to the SPI. Use this fnc if you don't care what is received. If
    you do care, use the SPIDRV_fnWriteAndRead function.

INPUTS: 
    uint16 TxData - the data to be sent 
    
OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 14, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
tuiSTATUS SPIDRV_fnWrite( uint16 TxData )
{
    tuiSTATUS tuiStatus = eSTATUS_OK;   // assume everything is ok upon entry

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );


    // signal that the Tx/Rx is starting
    if( SPICLIENT_fnSignalStartTxRx() != eSTATUS_OK )
    {
        mWRITE_STATUS_AND_ERRNO( SPIDRV_eERRNO_CHNL_BUSY );
        return( eSTATUS_ERR );
    }

    
    // if this SPI is the master, 
    if( CtrlModeSet == SPIDRV_eMASTER )
    {
        spidrv_fnSendDataToTxBuffer( TxData );
        
        // if the tx/rx has not been signalled as completed, then it's an error
        tuiStatus = SPICLIENT_fnWaitForTxRxComplete();

    } // if( CtrlMode == eSPI_MASTER )
    
    // if the SPI is in slave mode and the SPISTE pin is low, it's ok
    //  to xmit make sure this io is set for SPI model use
    else if( ( CtrlModeSet == SPIDRV_eSLAVE ) && 
             ( GpioDataRegs.GPFDAT.bit.GPIOF3  == 0 ) ) 
    {
        spidrv_fnSendDataToTxBuffer( TxData );

        tuiStatus = SPICLIENT_fnWaitForTxRxComplete();
    }
    else
    {
       // the SPI is not configured correctly so set an error
       assert( 0 );
       mWRITE_STATUS_AND_ERRNO( SPIDRV_eERRNO_WRITE );
    }

    return( tuiStatus );
}


/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnEnTx
  
PURPOSE: 
    Enable the SPI Tx.

INPUTS: 
    none

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( defined( SPIDRV_UNIT_TEST ) || SPI_EN_TX_EN == TRUE )
void SPIDRV_fnEnTx( void )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    SPIDRV_mEN_TX();
}
#endif

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnDisTx
  
PURPOSE: 
    Disable the SPI tx.

INPUTS: 
    none

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( defined( SPIDRV_UNIT_TEST ) || SPI_DIS_TX_EN == TRUE )
void SPIDRV_fnDisTx( void )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    SPIDRV_mDIS_TX();
}

#endif

/*******************************************************************************

FUNCTION NAME: 
    SPI_fnEnInt
  
PURPOSE: 
    Enable the SPI interrupt.

INPUTS: 
    none

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( defined( SPIDRV_UNIT_TEST ) || SPI_EN_INT_EN == TRUE )
void SPIDRV_fnEnInt( void )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    SPIDRV_mINT_EN();
}
#endif

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnDisInt
  
PURPOSE: 
    Disable the SPI interrupt.

INPUTS: 
    none

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( defined( SPIDRV_UNIT_TEST ) || SPI_DIS_INT_EN == TRUE )
void SPIDRV_fnDisInt( void )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    SPIDRV_mINT_DIS();
}

#endif

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnEnOvrRunInt
  
PURPOSE: 
    Enable the SPI receive overrun interrupt.

INPUTS: 
    none

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( defined( SPIDRV_UNIT_TEST ) || SPI_EN_OVRRUN_INT_EN == TRUE )
void SPIDRV_fnEnOvrRunInt( void )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    SPIDRV_mRX_OVR_RUN_INT_EN();
}
#endif

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnDisOvrRunInt
  
PURPOSE: 
    Disable the SPI receive overrun interrupt.

INPUTS: 
    none

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( defined( SPIDRV_UNIT_TEST ) || SPI_DIS_OVRRUN_INT_DIS == TRUE )
void SPIDRV_fnDisOvrRunInt( void )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    SPIDRV_mRX_OVR_RUN_INT_DIS();
}

#endif

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnReset
  
PURPOSE: 
    Reset SPI module

INPUTS: 
    none

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( defined( SPIDRV_UNIT_TEST ) || SPI_RESET_EN == TRUE )
void SPIDRV_fnReset( void )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    SPIDRV_mRESET();
}
#endif

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnStart
  
PURPOSE: 
    Start SPI operation.

INPUTS: 
    none

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( defined( SPIDRV_UNIT_TEST ) || SPI_START_EN == TRUE )
void SPIDRV_fnStart( void )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    SPIDRV_mSTART();
}

#endif

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnCheckEvent
  
PURPOSE: 
    provide SPI un-processed event

INPUTS: 
    none

OUTPUTS:
    SPIDRV_teEVENT

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 20, 2004   By: Yingran Duan
    - Created.

*******************************************************************************/
#if( defined( SPIDRV_UNIT_TEST ) || SPI_CHECK_EVENT_EN == TRUE )
SPIDRV_teEVENT SPIDRV_fnCheckEvent( void  )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    //check whether there is an receiver overrun
    if( SpiaRegs.SPISTS.bit.OVERRUN_FLAG == 1 )
    {
        return( SPIDRV_eRX_OVERRUN );
    }

    //check whether there is an Receiving message
    else if( SpiaRegs.SPISTS.bit.INT_FLAG == 1 )
    {
        return( SPIDRV_eRX_FULL );
    }

    //check whether there is an transmission message need to send
    else if( SpiaRegs.SPISTS.bit.BUFFULL_FLAG == 1 )
    {
        return( SPIDRV_eTX_FULL );
    }

    //no other cases
    else
    {
        return( SPIDRV_eNONE );
    }
}

#endif

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnDisAllSlave
  
PURPOSE: 
    Disable all slave channels

INPUTS: 
    None.

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( defined( SPIDRV_UNIT_TEST ) || SPI_DIS_ALL_SLAVE_EN == TRUE )
void SPIDRV_fnDisAllSlave( void )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    SPISLAVECHNL_mDISABLE_ALL();

    EnabledSlaveChnl = SPI_NONE_SLAVE_CHANNEL_ENABLED;
}

#endif

/*******************************************************************************

FUNCTION NAME: 
    spidrv_fnSendDataToTxBuffer
  
PURPOSE: 
    Send data to the transmit buffer.

INPUTS: 
    TxData

OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 20, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
static void spidrv_fnSendDataToTxBuffer( uint16 TxData )
{
    // data must be left justified in the TX buf so shift the data an
    //  appropriate number of spaces.
    SpiaRegs.SPITXBUF = TxData << ( SPI_MAX_CHAR_LENGTH - LengthSet );
}


/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnEnASlave
  
PURPOSE: 
    enable a slave channel.

INPUTS: 
    SlaveId - slave channel ID

OUTPUTS:
    tuiSTATUS

NOTES:
    There should be only one slave channel enabled at any time.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( SPI_EN_A_SLAVE_EN == TRUE || defined( SPIDRV_UNIT_TEST ) )
tuiSTATUS SPIDRV_fnEnASlave( uchar8 SlaveId )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    //only one slave channel can be enabled at any time
    if( EnabledSlaveChnl != SPI_NONE_SLAVE_CHANNEL_ENABLED )
    {
        return( eSTATUS_ERR );
    }

    switch( SlaveId )
    {
        case SPISLAVECHNL_ID_1:
            SPISLAVECHNL_1 = SPISLAVECHNL_ENABLE;
            break;
            
        case SPISLAVECHNL_ID_2:
            SPISLAVECHNL_2 = SPISLAVECHNL_ENABLE;
            break;

        case SPISLAVECHNL_ID_3:
            SPISLAVECHNL_3 = SPISLAVECHNL_ENABLE;
            break;

        default:
            assert( 0 );
            return( eSTATUS_ERR );
    }

    EnabledSlaveChnl = SlaveId;
    return( eSTATUS_OK );

}
#endif

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnGetEnSlaveChnl
  
PURPOSE: 
    provide the slave channel ID that is currently enabled

INPUTS: 
    *SlaveId - to store slave channel ID

OUTPUTS:
    tuiSTATUS

NOTES:
    There should be only one slave channel enabled at any time.

VERSION HISTORY:

Version: 1.00  Date: Sept. 30, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( SPI_GET_SLAVE_CHNL_EN == TRUE || defined( SPIDRV_UNIT_TEST ) )
tuiSTATUS SPIDRV_fnGetEnSlaveChnl( uchar8 *SlaveId ) 
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    //return error if none slave channel has enabled
    if( EnabledSlaveChnl == SPI_NONE_SLAVE_CHANNEL_ENABLED )
    {
        return( eSTATUS_ERR );
    }

    *SlaveId = EnabledSlaveChnl;
    return( eSTATUS_OK );
}
#endif

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnDisASlave
  
PURPOSE: 
    Disable a slave channel

INPUTS: 
    SlaveId - slave channel id

OUTPUTS:
    None

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 17, 2004   By: Yingran Duan
    - Created.

*******************************************************************************/
#if( SPI_DIS_A_SLAVE_EN == TRUE || defined( SPIDRV_UNIT_TEST ) )
void SPIDRV_fnDisASlave( uchar8 SlaveId )
{
    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );

    //upate enabled slave channel
    if( EnabledSlaveChnl == SlaveId )
    {
        EnabledSlaveChnl = SPI_NONE_SLAVE_CHANNEL_ENABLED;
    }
        
    switch( SlaveId )
    {
        case SPISLAVECHNL_ID_1:
            SPISLAVECHNL_1 = SPISLAVECHNL_DISABLE;
            break;
            
        case SPISLAVECHNL_ID_2:
            SPISLAVECHNL_2 = SPISLAVECHNL_DISABLE;
            break;

        case SPISLAVECHNL_ID_3:
            SPISLAVECHNL_3 = SPISLAVECHNL_DISABLE;
            break;

        default:
            assert( 0 );
    }
}
#endif 

/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnWriteAndRead
  
PURPOSE: 
    Write data out and then read the rx buffer.

INPUTS: 
    uint16 TxData - the data to be sent 
    uint16 *RxData - a pointer to a buffer where the received data will be
                        stored

OUTPUTS:
    tuiSTATUS - Status code (either OK or an error code)

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 20, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
#if( defined( SPIDRV_UNIT_TEST ) || SPI_FN_WRITE_AND_READ_EN == TRUE )
tuiSTATUS SPIDRV_fnWriteAndRead( uint16 TxData,  
                                 uint16 *RxData )
{
    tuiSTATUS tuiStatus = eSTATUS_OK; // assume everything is ok upon entry

    // only run the function if the ctor was called
    assert( SpiCreated != FALSE );
    assert( RxData );

    //send out transmission data
    tuiStatus = SPIDRV_fnWrite( TxData );

    //get received data
    if( tuiStatus == eSTATUS_OK )
    {
        *RxData = ReceiveData;
    }

    return( tuiStatus );    
}
#endif // #if( SPI_FN_WRITE_AND_READ_EN == TRUE )


/*******************************************************************************

FUNCTION NAME: 
    SPIDRV_fnIsr
  
PURPOSE: 
    Handle events generated by the SPI.

INPUTS: 
    none
    
OUTPUTS:
    none

NOTES:
    None.

VERSION HISTORY:

Version: 1.00  Date: Sept. 20, 2004  By: Yingran Duan
    - Created.

*******************************************************************************/
void SPIDRV_fnIsr( void )
{

    // read the data in the rx buffer to clear the interrupt flag
    ReceiveData = SpiaRegs.SPIRXBUF;

    // signal that the tx/rx is complete
    SPICLIENT_fnTxRxComplete();

    PieCtrlRegs.PIEACK.bit.ACK6 = 1;        // Issue PIE ACK

}
