/*==============================================================================
Copyright 2005 Xantrex International.  All rights reserved.

This source file is proprietary to Xantrex International and protected by
copyright. The reproduction, in whole or in part, by anyone without the written
approval of Xantrex is prohibited.

FILE NAME:  
    spidrv.h

PURPOSE:
    Provide service functions for the serial peripheral interface (SPI).

FUNCTION(S):
    SPDRVI_fnCtor           - Configure and initialize the SPI to it's default 
                              parameters.
    SPIDRV_fnDtor           - Destroy an instance of an SPI.
    SPIDRV_fnAcquireLock    - Acquire exclusive access to the SPI driver
    SPIDRV_fnReleaseLock    - Release exclusive access to the SPI driver 
    SPIDRV_fnCreateHandle   - Create an SPI handle
    SPIDRV_fnDeleteHandle   - Delete an SPI handle
    SPIDRV_fnSetCfg         - Set the configuration of the SPI.
    SPIDRV_fnGetCfg         - Get the vurrent configuration of the SPI, the
                              parameters are placed into the locations 
                              indicated by the pointers being passed.
    SPIDRV_fnSetCharLength  - set communication character length
    SPIDRV_fnRead           - Read data from the SPI buffer. No actual 
                              communications occurs.
    SPIDRV_fnWrite          - Write data to the SPI. Use this fnc if you don't 
                              care what is received. If you do care, use the
                              spi_fnWriteAndRead function.
    SPIDRV_fnWriteAndRead   - Write data out and then read the rx buffer.
    SPIDRV_fnEnTx           - Enable the SPI transmission.
    SPIDRV_fnDisTx          - Disable the SPI transmission.
    SPIDRV_fnEnInt          - Enable the tx/rx interrupt.
    SPIDRV_fnDisInt         - Disable the tx/rx interrupt.
    SPIDRV_fnEnOvrRunInt    - Enable the rx buffer overrun interrupt.
    SPIDRV_fnDisOvrRunInt   - Disable the rx buffer overrun interrupt.
    SPIDRV_fnReset          - Reset SPI module 
    SPIDRV_fnStart          - Start SPI module 
    SPIDRV_fnCheckEvent     - provide SPI un-processed event 
    SPIDRV_fnRxISR          - events generated by the SPI.
               
    local:
        None
           
NOTES:
    The SPI Driver is only responsible for shifting bits into and out
    of the SPI hardware.  It does not concern itself with enabling/disabling
    external devices.
    
    The SPI Driver should never be called by the application layer directly,
    it should only be called by other device drivers to make use of its 
    services.  For example, the EEPROM driver; IO Driver; and possibly others
    will make calls to the SPI driver.
    
    Any driver which makes use of the SPI driver must use the 
    SPIDRV_fnCreateHandle function to obtain a "handle" to the SPI device.
    The handle is usually created in the Ctor function of the driver which
    is intending to use the SPI device.  
    
    The handle encapsulates all of the settings of the SPI device, like 
    bit rate, clock phase, interrupt enables, etc.  In this way, each 
    user of the SPI driver can maintain their own settings.
    
    Before calling any function in the SPI driver, each device driver must 
    lock the SPI device for exclusive access using the SPIDRV_fnAcquireLock
    function. When the driver has finished accessing the SPI driver, it MUST 
    call the SPIDRV_fnReleaseLock function to make the SPI driver available 
    to other drivers.
    
    The general mechanism for using the SPI driver is as follows:
    
    1. Create an SPI Handle (in the driver constructor function)
    
    2. Lock the SPI Driver for exclusive access
    
    3. Enable or select the external device to be addressed
    
    4. Read or write some data to the external device
    
    5. Disable the external device
    
    6. Release the SPI Driver lock

CHANGE HISTORY:
$Log: spidrv.h $

   ***********************************************
   Revision: NovaPfrmB_TrevorM/1
   User: TrevorM     Date: 03/11/05  Time: 07:42PM
   Modified to support SPI driver handles and exclusive access modes

    ***********************************************
    Revision: NovaPfrmB_Local_HorstM/3
    User: HorstM     Date: 02/22/05  Time: 11:26PM
    renamed isr

    

    ***********************************************
    Revision: NovaPfrmB_Local_HorstM/2
    User: HorstM     Date: 02/22/05  Time: 06:34PM
    fixed declaration naming error - missed in code review
    

    ***********************************************
    Revision: NovaPfrmB_Local_HorstM/1
    User: HorstM     Date: 02/17/05  Time: 07:11PM
    moved spiclient function headers to spidrv.c
    

    ***********************************************
    Revision: NovaPfrmB_BaldeeshK/1
    User: BaldeeshK     Date: 12/09/04  Time: 12:50AM
    - Initial add to Accurev, modified to enable logging of history
    
    
   
==============================================================================*/
#ifndef SPIDRV_H
#define SPIDRV_H


/*==============================================================================
                              Includes
==============================================================================*/
#include "LIB_stdtype.h"    //Requres and architecture defintion in the compiler
#include "LIB_stddefs.h"    //Standard defintions for all projects
#include "HALErrBase.h"     //HAL error code definition

 
/*==============================================================================
                            Type Definitions
==============================================================================*/

/*==============================================================================
                                Enums
==============================================================================*/
// the allowable modes of control for the SPI
typedef enum SPIDRV_eCTRL_MODE
{
    SPIDRV_eCTRL_MODE_INVL = 0,
    SPIDRV_eSLAVE,
    SPIDRV_eMASTER
} SPIDRV_teCTRL_MODE;

// The clocking scheme is determined by the two bits: CLOCK POLARITY and CLOCK
//  PHASE.
typedef enum SPIDRV_eCLK_POL
{
    SPIDRV_eCLK_POL_INVL = 0,
    SPIDRV_eRISING_EDGE,
    SPIDRV_eFALLING_EDGE
} SPIDRV_teCLK_POL;

typedef enum SPIDRV_eCLK_PHS
{
    SPIDRV_eCLK_PHS_INVL = 0,
    SPIDRV_eWITHOUT_DELAY,
    SPIDRV_eWITH_DELAY
} SPIDRV_teCLK_PHS;

// the allowable event triggered by SPI
typedef enum SPIDRV_eEVENT
{
    SPIDRV_eNONE = 0,
    SPIDRV_eRX_FULL,
    SPIDRV_eRX_OVERRUN,
    SPIDRV_eTX_FULL
} SPIDRV_teEVENT;

//errno codes based on errbase.h  Note:  errno is an ANSI standard and can be
//found in "The C Programming Language" by K & R for reference.
typedef enum SPIDRV_eERRNO
{
    SPIDRV_eERRNO_CTOR = ERR_SPI_DRV, // cannot construct the SPI driver
    SPIDRV_eERRNO_DTOR,
    SPIDRV_eERRNO_INVL_CTRL_MODE,
    SPIDRV_eERRNO_INVL_CLK_POL,
    SPIDRV_eERRNO_INVL_CLK_PHS,
    SPIDRV_eERRNO_INVL_BAUD_RATE_DIVISOR,
    SPIDRV_eERRNO_INVL_CHAR_LENGTH,
    SPIDRV_eERRNO_WRITE,
    SPIDRV_eERRNO_READ,    
    SPIDRV_eERRNO_RX_BUFFER_NOT_FULL,     
    SPIDRV_eERRNO_TIMEOUT,
    SPIDRV_eERRNO_CHNL_BUSY,
    SPIDRV_eERRNO_MAX = ERR_SPI_DRV_MAX   //Max val not to be used
} SPIDRV_teERRNO;

typedef void * SpiDrvHandle;

/*==============================================================================
                              Defines
==============================================================================*/
#define SPIDRV_LOCK_NOWAIT ( -1 )

/*=============================================================================
                              Structures
==============================================================================*/


/*==============================================================================
                          External/Public Constants
==============================================================================*/


/*==============================================================================
                          External/Public Variables
==============================================================================*/


/*==============================================================================
                      External/Public Function Protoypes
==============================================================================*/

//SPIDRV_fnCreateHandle
//      SPI handle creation function
//Input: none
//Output: a new SPI driver Handle
//Note: If a driver handle can not be created, this function will return NULL
SpiDrvHandle SPIDRV_fnCreateHandle( void );

//SPIDRV_fnDeleteHandle
//       SPI handle deletion function
//Input: handle - handle to be deleted
//Output: tuiSTATUS - eSTATUS_OK - handle was deleted successfully
//                  - eSTATUS_ERR - an invalid handle was specified
tuiSTATUS SPIDRV_fnDeleteHandle( SpiDrvHandle hSPI );

//SPIDRV_fnCtor
//      SPI constructor, configuration.
//
//Input: none
//Output: tuiSTATUS - eSTATUS_OK : the SPI driver was created
//                  - eSTATUS_ERR : an error occurred while creating the SPI
//NOTE: No other SPI functions can be called unless the Ctor is first called.
tuiSTATUS SPIDRV_fnCtor( void );  

//SPIDRV_fnDtor
//      SPI destructor - if this is called, no other SPI func (except for Ctor) 
//          can be called.
//
//Input: none
//Output: tuiSTATUS - eSTATUS_OK : the SPI driver was destroyed ok
//                  - eSTATUS_ERR : the SPI driver could not be destroyed
tuiSTATUS SPIDRV_fnDtor( void ); 

//SPIDRV_fnSetCfg
//      Set the configuration of the SPI.
//
//Input: hSPI:   handle to the SPI device to be configured
//       CtrlMode: slave or master mode
//       ClkPol:   clock polarity
//       ClkPhs:   clock phase
//       uiBitRate: requested bit rate (bits/second)
//       uiLength:   Character length
//Output: tuiSTATUS
tuiSTATUS SPIDRV_fnSetCfg( SpiDrvHandle       hSPI,
                           SPIDRV_teCTRL_MODE CtrlMode,   
                           SPIDRV_teCLK_POL   ClkPol,     
                           SPIDRV_teCLK_PHS   ClkPhs,     
                           uint32             uiBitRate,
                           uint16             uiLength ); 


//SPIDRV_fnGetCfg
//      Get the configuration of the SPI.
//
//Input: hSPI:    handle to the SPI instance to query
//       *CtrlMode: slave or master mode
//       *ClkPol:   clock polarity
//       *ClkPhs:   clock phase
//       *puiBitRate: SPI bit rate (bits/second)
//       *puiLength:   Character length
//Output: none
void SPIDRV_fnGetCfg( SpiDrvHandle hSPI,
                      SPIDRV_teCTRL_MODE *CtrlMode,  
                      SPIDRV_teCLK_POL   *ClkPol,          
                      SPIDRV_teCLK_PHS   *ClkPhs,          
                      uint32             *puiBitRate,
                      uint16             *puiLength );   


//SPIDRV_fnSetCharLength
//      Set spi communication character length
//
//Input:  hSPI, handle to the SPI driver
//        uiLength: char length.
//Output: tuiSTATUS - eSTATUS_OK: character length updated
//                  - eSTATUS_ERR: character length update denied
tuiSTATUS SPIDRV_fnSetCharLength ( SpiDrvHandle hSPI, uint16 uiLength ); 

//SPIDRV_fnRead
//      Read the rx Data, transmits 0x0000.
//
//Input:  hSPI, handle to the SPI driver
//        *puiRxData: pointer to a location to store the read data
//Output: tuiSTATUS - eSTATUS_OK: read data successful
//                  - eSTATUS_ERR: read data error occurred
tuiSTATUS SPIDRV_fnRead ( SpiDrvHandle hSPI, uint16 *puiRxData ); 

                                           
//SPIDRV_fnWrite
//      Write data and ignore the rx data
//
//Input:  hSPI, handle to the SPI driver
//        uiTxData: write data.
//Output: tuiSTATUS - eSTATUS_OK: write data successful
//                  - eSTATUS_ERR: write data error occurred
tuiSTATUS SPIDRV_fnWrite( SpiDrvHandle hSPI, uint16 uiTxData ); 


//SPIDRV_fnWriteAndRead
//      Write data out and read the rx data in
//
//Input: hSPI, handle to the SPI driver
//       uiTxData:  write data.
//       *puiRxData: read data
//Output: tuiSTATUS - eSTATUS_OK: write/read data successful
//                  - eSTATUS_ERR: write/read data error occurred
tuiSTATUS SPIDRV_fnWriteAndRead( SpiDrvHandle hSPI,
                                 uint16 uiTxData,     
                                 uint16 *puiRxData ); 

//SPIDRV_fnEnTx
//      Enable SPI transmission 
//
//Input:  hSPI, handle to the SPI driver
//Output: tuiSTATUS - eSTATUS_OK : SPI transmission was enabled
//                  - eSTATUS_ERR : SPI transmission could not be enabled
tuiSTATUS SPIDRV_fnEnTx( SpiDrvHandle hSPI ); 

//SPIDRV_fnDisTx
//      Disable SPI transmission 
//
//Input:  hSPI, handle to the SPI driver
//Output: tuiSTATUS - eSTATUS_OK : SPI transmission was disabled
//                  - eSTATUS_ERR : SPI transmission could not be disabled
tuiSTATUS SPIDRV_fnDisTx( SpiDrvHandle hSPI ); 

//SPIDRV_fnEnInt
//      Enable SPI receive and transmission interrupt
//
//Input:  hSPI, handle to the SPI driver
//Output: tuiSTATUS - eSTATUS_OK : the interrupt was enabled
//                  - eSTATUS_ERR : the interrupt could not be enabled
tuiSTATUS SPIDRV_fnEnInt( SpiDrvHandle hSPI ); 

//SPIDRV_fnDisInt
//      Disable SPI receive and transmission interrupt
//
//Input:  hSPI, handle to the SPI driver
//Output: tuiSTATUS - eSTATUS_OK : the interrupt was disabled
//                  - eSTATUS_ERR : the interrupt could not be disabled
tuiSTATUS SPIDRV_fnDisInt( SpiDrvHandle hSPI );

//SPIDRV_fnEnOvrRunInt
//      Enable SPI receive overrun interrupt
//
//Input:  hSPI, handle to the SPI driver
//Output: tuiSTATUS - eSTATUS_OK : the RX overrun interrupt was enabled
//                  - eSTATUS_ERR : the interrupt could not be enabled
tuiSTATUS SPIDRV_fnEnOvrRunInt( SpiDrvHandle hSPI ); 

//SPIDRV_fnDisOvrRunInt
//      Disable SPI receive overrun interrupt
//
//Input:  hSPI, handle to the SPI driver
//Output: tuiSTATUS - eSTATUS_OK : the RX overrun interrupt was disabled
//                  - eSTATUS_ERR : the interrupt could not be disabled
tuiSTATUS SPIDRV_fnDisOvrRunInt( SpiDrvHandle hSPI ); 

//SPIDRV_fnReset
//      Reset SPI module
//
//Input:  hSPI, handle to the SPI driver
//Output: tuiSTATUS - eSTATUS_OK : the SPI driver was reset
//                  - eSTATUS_ERR : the SPI driver could not be reset
//Note: some procesosr requires to reset SPI before do any reconfiguration
tuiSTATUS SPIDRV_fnReset( SpiDrvHandle hSPI ); 

//SPIDRV_fnStart
//      Start SPI module
//
//Input:  hSPI, handle to the SPI driver
//Output: tuiSTATUS - eSTATUS_OK : the SPI driver was started
//                  - eSTATUS_ERR : the SPI driver could not be started
//Note: this function may need to get called after to reset SPI to resume SPI
tuiSTATUS SPIDRV_fnStart( SpiDrvHandle hSPI ); 

//SPIDRV_fnCheckEvent
//       provide SPI un-processed event
//
//Input:  hSPI, handle to the SPI driver
//Output: SPIDRV_teEVENT
//Note:This function provides SPI status polling for application to check
//      This is not needed if interrupt approach is used     
SPIDRV_teEVENT SPIDRV_fnCheckEvent( SpiDrvHandle hSPI ); 

//SPIDRV_fnRxIsr
//       process SPI events ISR
//
//Input: none
//Output: none
void SPIDRV_fnRxIsr( void ); 

// SPIDRV_fnAcquire
//       SPI driver acquire exclusive access
//
//Input:  hSPI, handle to the SPI driver
//        siWaitTicks, number of ticks to wait for exclusive access
//Output: tuiSTATUS - eSTATUS_OK : an exclusive lock was acquired
//                  - eSTATUS_ERR : an exclusive lock could not be acquired
//Notes:
//  If siWaitTicks is negative, this function will try to obtain a lock
//  without blocking and return immediately if an exclusive lock is unavailable.
//    
//  If siWaitTicks is zero, this function will wait forever until a lock
//  is available
//    
//  If siWaitTicks is positive, this represents the maximum number of 
//  system ticks to wait for exclusive access 
//
tuiSTATUS SPIDRV_fnAcquireLock( SpiDrvHandle hSPI, sint16 siWaitTicks );

// SPIDRV_fnRelease
//      SPI driver release exclusive access
//Input: hSPI, handle to the SPI driver
//Output: tuiSTATUS - eSTATUS_OK : the lock was released successfully
//                  - eSTATUS_ERR : an invalid handle was specified
tuiSTATUS SPIDRV_fnReleaseLock( SpiDrvHandle hSPI );

#endif  // SPIDRV_H

